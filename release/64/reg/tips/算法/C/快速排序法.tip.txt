快速排序法（详解）

李小白~

于 2019-07-01 17:27:49 发布

328127
 收藏 4472
分类专栏： 基础算法
版权

基础算法
专栏收录该内容
7 篇文章43 订阅
订阅专栏
假设对以下10个数进行快速排序：

6	1	2	7	9	3	4	5	10	8
我们先模拟快速排序的过程：首先，在这个序列中随便找一个数作为基准数，通常为了方便，以第一个数作为基准数。

6	1	2	7	9	3	4	5	10	8
在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k kk。现在就需要寻找这个k kk，并且以第k位为分界点，左边的数都≤ 6 \le6≤6，右边的数都≥ 6 \ge6≥6。那么如何找到这个位置k kk呢？

我们要知道，快速排序其实是冒泡排序的一种改进，冒泡排序每次对相邻的两个数进行比较，这显然是一种比较浪费时间的。

而快速排序是分别从两端开始”探测”的，先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i ii和j jj，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i ii”和“哨兵j jj”。刚开始的时候让哨兵i ii指向序列的最左边，指向数字6。让哨兵j jj指向序列的最右边，指向数字8。

6	1	2	7	9	3	4	5	10	8
i									j
首先哨兵j jj开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j jj先出动，这一点非常重要。哨兵j jj一步一步地向左挪动（即j = j − 1 j = j-1j=j−1），直到找到一个小于6的数停下来。接下来哨兵i ii再一步一步向右挪动（即i = i + 1 i=i+1i=i+1），直到找到一个数大于6的数停下来。最后哨兵j jj停在了数字5面前，哨兵i ii停在了数字7面前。

6	1	2	7	9	3	4	5	10	8
i				j		
现在交换哨兵$i$和哨兵$j$所指向的元素的值。交换之后的序列如下。
6	1	2	5	9	3	4	7	10	8
i				j		
到此，第一次交换结束。接下来开始哨兵j jj继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4 < 6 4<64<6，停下来。哨兵i ii也继续向右挪动的，他发现了9 > 6 9>69>6，停下来。此时再次进行交换，交换之后的序列如下。

6	1	2	5	4	3	9	7	10	8
i		j			
第二次交换结束。哨兵j jj继续向左挪动，他发现了3 < 6 3<63<6，又停下来。哨兵i ii继续向右移动，此时哨兵i ii和哨兵j jj相遇了，哨兵i ii和哨兵j jj都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下。

3	1	2	5	4	6	9	7	10	8
i,j				
到此第一轮“探测”真正结束。现在基准数6已经归位，此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j jj的使命就是要找小于基准数的数，而哨兵i ii的使命就是要找大于基准数的数，直到i ii和j jj碰头为止。

现在我们将第一轮“探测"结束后的序列，以6为分界点拆分成两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

3	1	2	5	4	6	 	 	 	 
重复第一轮的过程，应该得到如下序列：

2	1	3	5	4	6	 	 	 	 
OK，现在3已经归位。接下来需要处理3左边的序列：

2	1	3	 	 	6	 	 	 	 
处理之后，2已经归位，序列“1”只有一个数，也不需要进行任何处理，因此“1”也归位。

1	2	3	 	 	6	 	 	 	 
对于基数右边的序列，采用和左边相同的过程；最终将会得到这样的序列，如下。

1	2	3	4	5	6	7	8	9	10
细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。接下来用图示的方法来展示完整的过程：

快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O ( n 2 ) O(n^2)O(n 
2
 )，它的平均时间复杂度为O ( n log ⁡ 2 n ) O(n\log_2n)O(nlog 
2
​
 n)。

实现快速排序的代码如下：

void Quick_Sort(int *arr, int begin, int end){
    if(begin > end)
        return;
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(j > i){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[begin] = arr[i];
    arr[i] = tmp;
    Quick_Sort(arr, begin, i-1);
    Quick_Sort(arr, i+1, end);
}
————————————————
版权声明：本文为CSDN博主「李小白~」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_40941722/article/details/94396010