@Bean
@Service
@Controller
@ComponentScan
@Autowired
@Configuration

@ConditionalOnClass({ freemarker.template.Configuration.class,
　　　　FreeMarkerConfigurationFactory.class })
@EnableConfigurationProperties(FreeMarkerProperties.class)
@Import({ FreeMarkerServletWebConfiguration.class,
　　　　FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfigura
　　　　　　tion.class })
@ConfigurationProperties(prefix = "spring.freemarker")
@Configuration
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ Servlet.class, FreeMarkerConfigurer.class })
@AutoConfigureAfter(WebMvcAutoConfiguration.class)


@Conditional
@ConditionalOnBean
@ConditionalOnClass
@ConditionalOnExpression
@ConditionalOnMissingBean
@ConditionalOnMissingClass
@ConditionalOnNotWebApplication
@EnableAutoConfiguration
@Profile
@RequestMapping("/hello")
@ResponseBody

@Override

@ComponentScan(basePackages = { "com.easy.Spring Boot"})
@EnableWebMvc // 启用 WebMVC 配置





==============
·组件扫描（Component Scan）：Spring去自动发现应用上下文中创建的Bean。
·自动装配（Autowired）：Spring自动创建Bean之间的依赖。
·通过JavaConfig方式实现Java代码配置Bean。

条件注解@Conditional
假如你想一个或多个Bean只有在应用的路径下包含特定的库时才创建，那么使用这节我们所要介绍的@Conditional注解定义条件化的Bean就再适合不过了。

条件注解
@ConditionalOnBean
 --仅在当前上下文中存在某个对象时，才会实例化一个Bean
@ConditionalOnClass
 --当class位于类路径上，才会实例化一个Bean
@ConditionalOnExpression
 --当表达式为true的时候，才会实例化一个Bean
@ConditionalOnMissingBean
 --仅在当前上下文中不存在某个对象时，才会实例化一个Bean
@ConditionalOnMissingClass
 --当类路径上不存在某个class的时候，才会实例化一个Bean
@ConditionalOnNotWebApplication
 --当不是一个Web应用时


3.3.1 @EnableAutoConfiguration注解
Spring Boot中通过@EnableAutoConfiguration启用Spring应用程序上下文的自动配置，这个注解会导入一个EnableAutoConfigurationImportSelector的类，而AutoConfigurationImportSelector这个类会去读取一个spring.factories下key为EnableAutoConfiguration对应的类全限定名的值。其中的关键代码如下：
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata,
　　　　AnnotationAttributes attributes) {
　　List<String> configurations = SpringFactoriesLoader.loadFactoryNames(
　　　　　　getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
　　Assert.notEmpty(configurations,
　　　　　　"No auto configuration classes found in META-INF/spring.factories.
　　　　　　　　If you "
　　　　　　　　　　+ "are using a custom packaging, make sure that file
　　　　　　　　　　　　is correct.");
　　return configurations;
}
这个spring.factories里面配置的那些类，主要作用是告诉Spring Boot这个stareter所需要加载的那些*AutoConfiguration类，也就是你真正的要自动注册的那些Bean或功能。然后，再实现一个spring.factories指定的类，标上@Configuration注解，一个starter就定义完了。通过org.springframework.boot.autoconfigure.AutoConfigurationImportSelector里面的getCandidateConfigurations方法，获取到候选类的名字列表List<String>。
其中，loadFactoryNames的第1个参数是getSpringFactoriesLoaderFactoryClass（）方法直接返回的是EnableAutoConfiguration.class，代码如下：




@EnableConfigurationProperties，表示启动对FreeMarkerProperties.class的内嵌配置支持，自动将FreeMarkerProperties注册为一个Bean。这个FreeMarkerProperties类里面就是关于FreeMarker属性的配置：