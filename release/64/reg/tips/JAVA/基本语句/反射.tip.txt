https://zhuanlan.zhihu.com/p/86293659#:~:text=%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89%20%E6%98%AF%20Java%20%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%EF%BC%8C%E5%AE%83%E5%85%81%E8%AE%B8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%20Java%20%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%87%AA%E8%BA%AB%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%22%E8%87%AA%E5%AE%A1%22%EF%BC%8C%E5%B9%B6%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%82.%20%E5%8F%8D%E5%B0%84%E6%98%AF%E4%B8%80%E9%A1%B9%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%22%E9%BB%91%E7%A7%91%E6%8A%80%22%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%8F%8D%E5%B0%84%E5%B9%B6%E4%B8%8D%E6%98%AF,Java%20%E7%8B%AC%E6%9C%89%E7%9A%84%EF%BC%8C%E8%AE%B8%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%E3%80%82.%20%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E9%9D%A2%E8%AF%95%E5%AE%98%E4%B9%9F%E7%BB%8F%E5%B8%B8%E5%AF%B9%E5%8F%8D%E5%B0%84%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E8%80%83%E5%AF%9F%EF%BC%8C%E5%8F%8D%E5%B0%84%E6%98%AF%E6%89%80%E6%9C%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%B0%A4%E5%85%B6%E5%9C%A8%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%EF%BC%8C%E6%9C%89%E4%B8%8D%E5%8F%AF%E6%9B%BF%E4%BB%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82.%20%E5%85%B3%E4%BA%8E%E5%8F%8D%E5%B0%84%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E8%80%83%E5%AF%9F%E7%82%B9%E5%8C%85%E6%8B%AC%EF%BC%9A.%20%E5%A6%82%E4%BD%95%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%20Class%20%E5%AF%B9%E8%B1%A1.


详解面试中常考的 Java 反射机制
力扣（LeetCode）
力扣（LeetCode）
​
已认证账号
155 人赞同了该文章
反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。

反射是一项高级开发人员应该掌握的“黑科技”，其实反射并不是 Java 独有的，许多编程语言都提供了反射功能。在面试中面试官也经常对反射问题进行考察，反射是所有注解实现的原理，尤其在框架设计中，有不可替代的作用。关于反射，常见的面试考察点包括：

如何反射获取 Class 对象
如何反射获取类中的所有字段
如何反射获取类中的所有构造方法
如何反射获取类中的所有非构造方法
本篇我们就一起来学习一下 Java 反射机制。




反射是什么？
反射的概念是由 Smith 在 1982 年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。通俗地讲，一提到反射，我们就可以想到镜子。镜子可以明明白白地照出我是谁，还可以照出别人是谁。反映到程序中，反射就是用来让开发者知道这个类中有什么成员，以及别的类中有什么成员。


为什么要有反射
有的同学可能会疑惑，Java 已经有了封装为什么还要有反射呢？反射看起来像是破坏了封装性。甚至让私有变量都可以被外部访问到，使得类变得不那么安全了。我们来看一下 Oracle 官方文档中对反射的描述：

Uses of Reflection
Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.

Extensibility FeaturesAn application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.
Class Browsers and Visual Development EnvironmentsA class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.
Debuggers and Test ToolsDebuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.
从 Oracle 官方文档中可以看出，反射主要应用在以下几方面：

反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。
反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。
测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。
也就是说，Oracle 希望开发者将反射作为一个工具，用来帮助程序员实现本不可能实现的功能（perform operations which would otherwise be impossible）。正如《人月神话》一书中所言：软件工程没有银弹。很多程序架构，尤其是三方框架，无法保证自己的封装是完美的。如果没有反射，对于外部类的私有成员，我们将一筹莫展，所以我们有了反射这一后门，为程序设计提供了更大的灵活性。工具本身并没有错，关键在于如何正确地使用。




反射 API
Java 类的成员包括以下三类：属性字段、构造函数、方法。反射的 API 也是与这几个成员相关：


Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。
Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。
Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。
Class 类：表示正在运行的 Java 应用程序中的类的实例。
Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。
接下来，我们通过一个典型的例子来学习反射。先做准备工作，新建 com.test.reflection 包，在此包中新建一个 Student 类：

package com.test.reflection;

public class Student {

    private String studentName;
    public int studentAge;

    public Student() {
    }

    private Student(String studentName) {
        this.studentName = studentName;
    }

    public void setStudentAge(int studentAge) {
        this.studentAge = studentAge;
    }

    private String show(String message) {
        System.out.println("show: " + studentName + "," + studentAge + "," + message);
        return "testReturnValue";
    }
}
可以看到，Student 类中有两个字段、两个构造方法、两个函数，且都是一个私有，一个公有。由此可知，这个测试类基本涵盖了我们平时常用的所有类成员。



3.1 获取 Class 对象的三种方式
获取 Class 对象有三种方式：

// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名
Class studentClass = Class.forName("com.test.reflection.Student");
// 2.通过类的class属性
Class studentClass2 = Student.class;
// 3.通过对象的getClass()函数
Student studentObject = new Student();
Class studentClass3 = studentObject.getClass();
第一种方法是通过类的全路径字符串获取 Class 对象，这也是我们平时最常用的反射获取 Class 对象的方法；
第二种方法有限制条件：需要导入类的包；
第三种方法已经有了 Student 对象，不再需要反射。
通过这三种方式获取到的 Class 对象是同一个，也就是说 Java 运行时，每一个类只会生成一个 Class 对象。

我们将其打印出来测试一下：

System.out.println("class1 = " + studentClass + "\n" +
        "class2 = " + studentClass2 + "\n" +
        "class3 = " + studentClass3 + "\n" +
        "class1 == class2 ? " + (studentClass == studentClass2) + "\n" +
        "class2 == class3 ? " + (studentClass2 == studentClass3));
运行程序，输出如下：

class1 = class com.test.reflection.Student
class2 = class com.test.reflection.Student
class3 = class com.test.reflection.Student
class1 == class2 ? true
class2 == class3 ? true
OK，拿到 Class 对象之后，我们就可以为所欲为啦！



3.2 获取成员变量
获取字段有两个 API：getDeclaredFields和getFields。他们的区别是:getDeclaredFields用于获取所有声明的字段，包括公有字段和私有字段，getFields仅用来获取公有字段：

// 1.获取所有声明的字段
Field[] declaredFieldList = studentClass.getDeclaredFields();
for (Field declaredField : declaredFieldList) {
    System.out.println("declared Field: " + declaredField);
}
// 2.获取所有公有的字段
Field[] fieldList = studentClass.getFields();
for (Field field : fieldList) {
    System.out.println("field: " + field);
}
运行程序，输出如下：

declared Field: private java.lang.String com.test.reflection.Student.studentName
declared Field: public int com.test.reflection.Student.studentAge
field: public int com.test.reflection.Student.studentAge


3.3 获取构造方法
获取构造方法同样包含了两个 API：用于获取所有构造方法的 getDeclaredConstructors和用于获取公有构造方法的getConstructors:

// 1.获取所有声明的构造方法
Constructor[] declaredConstructorList = studentClass.getDeclaredConstructors();
for (Constructor declaredConstructor : declaredConstructorList) {
    System.out.println("declared Constructor: " + declaredConstructor);
}
// 2.获取所有公有的构造方法
Constructor[] constructorList = studentClass.getConstructors();
for (Constructor constructor : constructorList) {
    System.out.println("constructor: " + constructor);
}
运行程序，输出如下：

declared Constructor: public com.test.reflection.Student()
declared Constructor: private com.test.reflection.Student(java.lang.String)
constructor: public com.test.reflection.Student()


3.4.获取非构造方法
同样地，获取非构造方法的两个 API 是：获取所有声明的非构造函数的 getDeclaredMethods 和仅获取公有非构造函数的 getMethods：

// 1.获取所有声明的函数
Method[] declaredMethodList = studentClass.getDeclaredMethods();
for (Method declaredMethod : declaredMethodList) {
    System.out.println("declared Method: " + declaredMethod);
}
// 2.获取所有公有的函数
Method[] methodList = studentClass.getMethods();
for (Method method : methodList) {
    System.out.println("method: " + method);
}
运行程序，输出如下：

declared Method: public void com.test.reflection.Student.setStudentAge(int)
declared Method: private java.lang.String com.test.reflection.Student.show(java.lang.String)
method: public void com.test.reflection.Student.setStudentAge(int)
method: public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
method: public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
method: public final void java.lang.Object.wait() throws java.lang.InterruptedException
method: public boolean java.lang.Object.equals(java.lang.Object)
method: public java.lang.String java.lang.Object.toString()
method: public native int java.lang.Object.hashCode()
method: public final native java.lang.Class java.lang.Object.getClass()
method: public final native void java.lang.Object.notify()
method: public final native void java.lang.Object.notifyAll()
从输出中我们看到，getMethods 方法不仅获取到了我们声明的公有方法setStudentAge，还获取到了很多 Object 类中的公有方法。这是因为我们前文已说到：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。 而getDeclaredMethods是无法获取到父类中的方法的。




实践
学以致用，让我们来一个实际的应用感受一下。还是以 Student 类为例，如果此类在其他的包中，并且我们的需求是要在程序中通过反射获取他的构造方法，构造出 Student 对象，并且通过反射访问他的私有字段和私有方法。那么我们可以这样做：

// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名
Class studentClass = Class.forName("com.test.reflection.Student");
// 2.获取声明的构造方法，传入所需参数的类名，如果有多个参数，用','连接即可
Constructor studentConstructor = studentClass.getDeclaredConstructor(String.class);
// 如果是私有的构造方法，需要调用下面这一行代码使其可使用，公有的构造方法则不需要下面这一行代码
studentConstructor.setAccessible(true);
// 使用构造方法的newInstance方法创建对象，传入构造方法所需参数，如果有多个参数，用','连接即可
Object student = studentConstructor.newInstance("NameA");
// 3.获取声明的字段，传入字段名
Field studentAgeField = studentClass.getDeclaredField("studentAge");
// 如果是私有的字段，需要调用下面这一行代码使其可使用，公有的字段则不需要下面这一行代码
// studentAgeField.setAccessible(true);
// 使用字段的set方法设置字段值，传入此对象以及参数值
studentAgeField.set(student,10);
// 4.获取声明的函数，传入所需参数的类名，如果有多个参数，用','连接即可
Method studentShowMethod = studentClass.getDeclaredMethod("show",String.class);
// 如果是私有的函数，需要调用下面这一行代码使其可使用，公有的函数则不需要下面这一行代码
studentShowMethod.setAccessible(true);
// 使用函数的invoke方法调用此函数，传入此对象以及函数所需参数，如果有多个参数，用','连接即可。函数会返回一个Object对象，使用强制类型转换转成实际类型即可
Object result = studentShowMethod.invoke(student,"message");
System.out.println("result: " + result);
程序的逻辑注释已经写得很清晰了，我们再梳理一下：

先用第一种全路径获取 Class 的方法获取到了 Student 的 Class 对象
然后反射调用它的私有构造方法 private Student(String studentName)，构建出 newInstance
再将其公有字段 studentAge 设置为 10
最后反射调用其私有方法 show，传入参数 “message”，并打印出这个方法的返回值。
其中，setAccessible 函数用于动态获取访问权限，Constructor、Field、Method 都提供了此方法，让我们得以访问类中的私有成员。

运行程序，输出如下：

show: NameA,10,message
result: testReturnValue


互动话题
本篇文章主要介绍了基本 Java 反射机制的重要内容，你在面试中有被问到过其他关于反射的面试考点么？不妨在评论区告诉我们哦～



本文作者：Alpinist Wang

声明：本文归 “力扣” 版权所有，如需转载请联系。文章封面图来源于网络，为非商业用途使用，如有侵权联系删除。

发布于 2019-10-31 10:53
Java
程序员
编程语言
​赞同 155​
​6 条评论
​分享
​喜欢
​收藏
​申请转载
​