__attribute__((__aligned__(n)))对结构体对齐的影响

世事依然

于 2018-11-24 22:29:51 发布

8148
 收藏 23
文章标签： __attribute__ C 语言 结构体 字节对齐 aligned
版权
1. __attribute__ 是什么？
__attribute__是GCC里的编译参数，用法有很多种，感兴趣可以阅读一下gcc的相关文档。这里说一下__attribute__对变量和结构体对齐的影响。这里的影响大概分为两个方面，对齐和本身占用的字节数的大小，即sizeof（变量）的值。

2. __attribute__((__aligned__(n)))对变量的影响
使用的语法如下：
int a attribute((aligned(64))) = 10;
这个修饰的影响主要是对齐，所谓对齐是存储为值的起始地址。变量a的地址&a,本来是4字节对齐，变成了64字节对齐（有的环境对最大对齐数值有限制）。64字节对齐就是&a的最后6位为0。
sizeof（a） = 4; //a 占用的字节数还是4个字节

下面看看在使用了typedef之后对对齐和变量大小的影响：
typedef int myint attribute((aligned(64))) ；
sizeof(myint) = 4; //占用的字节数还是4个字节
这样说明myint 声明的变量按照64字节对齐，大小是4字节，这样就会有一个问题，这个变量不能定义数组：
myint myarray[2]; //这样定义编译器会报err

报错的原因是数组的存储在内存中是连续的，而myint只有4字节确要64字节对齐，这样对齐和连续就不能同时保证，就会报错。

3. __attribute__((__aligned__(n)))对结构体的影响
先定义一个结构体
typedef struct st_tag {
int a;
char b;
} ST1;
ST1 myst；
在没有对齐的情况下：
sizeof（ST1） = sizeof(myst) = 8;
结构体对齐的原则可以总结为：

结构体起始地址（&myst）按最大变量字节数（sizeof（int））对齐；
结构体内每个变量按照自身字节数对齐；
结构体的大小（sizeof(myst)）是最大变量字节数的整数倍（8/4=2）；
typedef struct st_tag {
int a;
char b;
} attribute((aligned(64))) ST1;
ST1 myst；
sizeof（ST1） = sizeof(myst) = 64;

对比：
typedef struct st_tag {
int a;
char b;
} ST1 attribute((aligned(64)));
ST1 myst；
sizeof（ST1） = sizeof(myst) =8 ;
这第二种情况可以理解为__attribute__((aligned(64)))作用于变量ST1 ，只影响对齐，不影响结构的大小。
————————————————
版权声明：本文为CSDN博主「世事依然」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lzc285115059/article/details/84454497