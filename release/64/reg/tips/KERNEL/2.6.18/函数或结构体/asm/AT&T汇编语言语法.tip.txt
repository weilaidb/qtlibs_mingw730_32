Linux汇编语法格式
1.在AT&T汇编格式中，寄存器名要加上"%"作为前缀;而Intel汇编格式中，寄存器名不需要加前缀。例如:
AT&T格式     Intel格式
pushl %eax   push eax

2.在AT&T汇编格式中，用"$"前缀表示一个立即操作数；而在Intel汇编格式中，立即数的表示不用带任何前缀。例如:
AT&T格式     Intel格式
pushl $1     push 1 
3.在AT&T汇编格式中源操作数和目标操作数的位置正好相反。在Intel汇编格式中，目标操作数在源操作数的左边；而在AT&%汇编格式中，目标操作数在源操作数的右边。例如:
AT&T格式     Intel格式
addl $1,%eax  add eax,1

4.在AT&T汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀"b"、"w"、"l"分别表示操作数为字节(byte, 8b)、字(word,16b)和长字(long, 32b);而在Intel汇编格式中，操作数的字长是用"byte ptr"和"word ptr"等前缀来表示的。例如:
AT&T格式     Intel格式
movb val %al mov al,byte ptr val

5.在AT&T汇编格式中，绝对转移和调用指令(jump/call)的操作数前要加上"*"作为前缀，而在Intel格式中则不需要。

6.远程转换指令和远程子调用指令的操作码，在AT&T汇编格式中为"ljump"和"lcall"，而在Intel汇编格式中则为"jmp far"和"call far",即
AT&T格式                Intel格式
ljump $section,$offset  jmp far section:offset
lcall $section,$offset  call far section:offset

7.在AT&T汇编格式中,内存操作数的寻址为:
section:disp(base,index,scale)
而在Intel汇编格式中，内存操作数的寻址方式为:
section:[base+index*scale+disp]

由于Linux工作在保护模式下，用的是32位线性地址，所以在计算地址时不用考虑段基址和偏移量，而是采用如下的计算方法:
disp+base+index*scale。

