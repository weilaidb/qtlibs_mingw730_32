3：Makefile中的变量以$开头，使用$(VAR)或${VAR}来引用变量的定义。 所以，为了避免和shell的变量冲突，shell的变量以$$开头



注意：Makefile中在对一些简单变量的引用，我们也可以不使用“（）”和“{}”来标记变量名，而直接使用“$x”的格式来实现，此种用法仅限于变量名为单字符的情况。另外自动化变量也使用这种格式。对于一般多字符变量的引用必须使用括号了标记，否则make将把变量名的首字母作为作为变量而不是整个字符串（“$PATH”在Makefile中实际上是“$(P)ATH”）。这一点和shell中变量的引用方式不同。shell中变量的引用可以是“${xx}”或者“$xx”格式。但在Makefile中多字符变量名的引用只能是“$(xx)”或者“${xx}”格式。



================================》》》》》》》
makefile中的shell语法

qingfengtsing

于 2014-03-14 21:17:26 发布

28732
 收藏 12
分类专栏： BCM SDK

BCM SDK
专栏收录该内容
13 篇文章0 订阅
订阅专栏
在Makefile中写shell代码有点诡异，和不同的shell语法不太一样，如果不了解，看Makefile会莫名其妙。下面总结了一些。

Makefile本质上来讲也是shell脚本，即每条command都是shell进程，运行完shell进程都会退出

假如/root#

test:

gcc -c main.c -o main.o 

gcc -c a.c -o a.o

这样输入make test，结果相当于两个进程，都退出了。

等价于在shell下输命令一样。

my_test:

cd /home;mkdir test

这里make my_test，结果相当于一个进程。当前目录是/root

而own_test:

cd /home

mkdir test

此时make own_test，相当于两个进程，第一个进程是cd /home,运行完回到了/root#。这时再运行第二个shell命令就会在/root下创建一个test目录.(makefile中的shell进程命令，跟直接在shell输的命令相同，但是它都会结束本身，即exit)

1：尽在Makefile文件的目标项冒号后的另起一行的代码才是shell代码。
eg：xx=xx1

第一种方式：

xx = xx1         // 这里时makefile代码

第二种方式：
yy：xx = xx2   // 这是是makefile代码，makefile允许变量赋值时，'='号两边留空格  ？？？？？？可以吗

第三种方式：
yy：
    xx=xx3 // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。

yy:

    xx= xx3 // 只有这里是shell代码 ，shell不允许‘=’号两边有空格哦。

注意此时xx的值是" xx3"，多了一个空格
有一个例外：
xx=$(shell 这里的代码也是shell代码)

2：Makefile中的shell，每一行是一个进程，不同行之间变量值不能传递。所以，Makefile中的shell不管多长也要写在一行。
eg：
SUBDIR=src example

all:

    @for subdir in $(SUBDIR); /      // 这里往下是一行shell

    do/

        echo "building " $$subdir; /

    done



3：Makefile中的变量以$开头，使用$(VAR)或${VAR}来引用变量的定义。 所以，为了避免和shell的变量冲突，shell的变量以$$开头



注意：Makefile中在对一些简单变量的引用，我们也可以不使用“（）”和“{}”来标记变量名，而直接使用“$x”的格式来实现，此种用法仅限于变量名为单字符的情况。另外自动化变量也使用这种格式。对于一般多字符变量的引用必须使用括号了标记，否则make将把变量名的首字母作为作为变量而不是整个字符串（“$PATH”在Makefile中实际上是“$(P)ATH”）。这一点和shell中变量的引用方式不同。shell中变量的引用可以是“${xx}”或者“$xx”格式。但在Makefile中多字符变量名的引用只能是“$(xx)”或者“${xx}”格式。




eg1：从当前目录路径中提取出 /application 或 /base_class 之前的部分
PROJECT_ROOT_DIR = $(shell pwd | awk -F'/application|/base_class' '{print  $$1 }')
eg2：上例中 $$subdir就是shell中的变量， 而$(SUBDIR)是Makefile的中的变量

=============================================================================================
1、在Makefile中只能在target中调用Shell脚本，其他地方是不能输出的。比如如下代码就是没有任何输出：

VAR="Hello"
echo "$(VAR)"

all:
   .....
以上代码任何时候都不会输出，没有在target内，如果上述代码改为如下：

VAR="Hello"

all:
    echo "$(VAR)"
    .....
以上代码，在make all的时候将会执行echo命令。

最后打印结果是:

echo ""Hello""

"Hello"

2、在Makefile中执行shell命令，一行创建一个进程来执行。这也是为什么很多Makefile中有很多行的末尾都是“;  \”，以此来保证代码是一行而不是多行，这样Makefile可以在一个进程中执行，例如：

SUBDIR=src example
all:
    @for subdir in $(SUBDIR); \
    do\
        echo "building "; \
    done
上述可以看出for循环中每行都是以”; \”结尾的。

3、Makefile中所有以$打头的单词都会被解释成Makefile中的变量。如果你需要调用shell中的变量（或者正则表达式中锚定句位$），都需要加两个$符号（$$）。实例如下：

PATH="/data/"

all:
    echo ${PATH}/*Makefile中变量，即"/data"*/
    echo $$PATH /*shell中的变量*/
例子中的第一个${PATH}引用的是Makefile中的变量，而不是shell中的PATH环境变量，后者引用的事Shell中的PATH环境变量。

     以上三点的是Makefile调用shell应该注意的地方，写Makefile一定要注意。


原文：
http://my.unix-center.net/~Simon_fu/?p=648