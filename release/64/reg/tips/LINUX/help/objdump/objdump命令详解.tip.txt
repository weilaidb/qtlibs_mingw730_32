objdump命令详解

p0inter

于 2020-04-07 22:47:06 发布

15678
 收藏 43
分类专栏： 软件使用
版权

软件使用
专栏收录该内容
4 篇文章0 订阅
订阅专栏
objdump命令是用查看目标文件或者可执行的目标文件的构成的gcc工具。

选项
--archive-headers 
-a 
显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 

-b bfdname 
--target=bfdname 
指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： 

objdump -b oasys -m vax -h fu.o 
显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 

-C 
--demangle 
将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 

--debugging 
-g 
显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 

-e 
--debugging-tags 
类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 

--disassemble 
-d 
从objfile中反汇编那些特定指令机器码的section。

-D 
--disassemble-all 
与 -d 类似，但反汇编所有section.

-EB 
-EL 
--endian={big|little} 
指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. 


-f 
--file-headers 
显示objfile中每个文件的整体头部摘要信息。

-h 
--section-headers 
--headers 
显示目标文件各个section的头部摘要信息。  

-H 
--help 
简短的帮助信息。 

-i 
--info 
显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 

-j name
--section=name 
仅仅显示指定名称为name的section的信息 

-l
--line-numbers 
用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 

-m machine 
--architecture=machine 
指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. 

--reloc 
-r 
显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 

--dynamic-reloc 
-R 
显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 

-s 
--full-contents 
显示指定section的完整内容。默认所有的非空section都会被显示。

-S 
--source 
尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 

--show-raw-insn 
反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--no-show-raw-insn 
反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--start-address=address 
从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 

--stop-address=address 
显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 

-t 
--syms 
显示文件的符号表入口。类似于nm -s提供的信息 


-T 
--dynamic-syms 
显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 

-V 
--version 
版本信息 

--all-headers 
-x 
显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 

-z 
--disassemble-zeroes 
一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。

@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
实例
首先，在给出后面大部分测试所基于的源代码以及编译指令。 源代码如下：
mytest.cpp

#include<stdio.h>
void exploit()
{
    system("/bin/sh");
}
void func()
{
    char str[0x20];
    read(0, str, 0x50);
}
int main()
{
    func();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
编译：

gcc -c -g -o mytest mytest.c

1
2
在这里插入图片描述
查看当前使用的objdump的版本号：

objdump -V 
1
在这里插入图片描述
显示可用的架构和目标结构列表：

objdump -i
1
在这里插入图片描述
显示mytest文件中的text段的内容：

objdump --section=.text -s mytest
1
在这里插入图片描述
这里注意，不能单独使用-j或者–section，例如objdump --section=.text mytest是不会运行成功的。

反汇编mytest中的text段内容，并尽可能用源代码形式表示：

objdump -j .text -S mytest
1
在这里插入图片描述
这里注意，不能单独使用-j或者–section，例如objdump -j .text mytest是不会运行成功的。另外-S命令对于包含调试信息的目标文件，显示的效果比较好，如果编译时没有指定-g选项，那么目标文件就不包含调试信息，那么显示效果就差多了。

反汇编出mytest.o的源代码:

objdump -S mytest
1
在这里插入图片描述
这里，尤其当编译的时候指定了-g这种调试参数时，反汇编的效果比较明显。隐含了-d参数。

显示文件的符号表入口:

objdump -t mytest
1
在这里插入图片描述
显示文件的符号表入口，将底层符号解码并表示成用户级别:

**objdump -t -C mytest**
1
在这里插入图片描述

反汇编目标文件的特定机器码段：

objdump -d mytest
1
在这里插入图片描述
这里，对text段的内容进行了反汇编。

反汇编特定段，并将汇编代码对应的文件名称和行号对应上：

objdump -d -l mytest
1
在这里插入图片描述
这里，项"-d"从objfile中反汇编那些特定指令机器码的section，而使用"-l"指定用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用，使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。

显示目标文件各个段的头部摘要信息：

objdump -h mytest
1
在这里插入图片描述
这里，更多的内容参见man objdump中的这个选项。