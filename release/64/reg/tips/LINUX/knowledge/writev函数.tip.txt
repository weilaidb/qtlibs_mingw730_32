writev函数
转自：https://blog.csdn.net/weixin_36750623/article/details/84579243

1.read/write与readv/writev
read/write:
因为使用read()将数据读到不连续的内存、使用write()将不连续的内存发送出去，要经过多次的调用read、write。

如果要从文件中读一片连续的数据至进程的不同区域，有两种方案：

①使用read()一次将它们读至一个较大的缓冲区中，然后将它们分成若干部分复制到不同的区域；
②调用read()若干次分批将它们读至不同区域。
但是多次系统调用+拷贝会带来较大的开销，所以UNIX提供了另外两个函数—readv()和writev()，它们只需一次系统调用就可以实现在文件和进程的多个缓冲区之间传送数据，免除了多次系统调用或复制数据的开销。

2.readv/writev
在一次函数调用中：
① writev以顺序iov[0]、iov[1]至iov[iovcnt-1]从各缓冲区中聚集输出数据到fd。
② readv则将从fd读入的数据按同样的顺序散布到各缓冲区中，readv总是先填满一个缓冲区，然后再填下一个。

复制代码
#include <sys/uio.h>
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
struct iovec {
    void  *iov_base;    /* Starting address */
    size_t iov_len;     /* Number of bytes to transfer */
};
复制代码
(1) 参数：readv和writev的第一个参数fd是个文件描述符，第二个参数是指向iovec数据结构的一个指针，其中iov_base为缓冲区首地址，iov_len为缓冲区长度，参数iovcnt指定了iovec的个数。
(2) 返回值：函数调用成功时返回读、写的总字节数，失败时返回-1并设置相应的errno。



 

 2.例子
复制代码
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/uio.h>

int main()
{
    char *str0 = "hello ";
    char *str1 = "world\n";
    struct iovec iov[2];
    ssize_t nwritten;
    ssize_t nwritten2;
    ssize_t nwritten3;

    iov[0].iov_base = str0;
    iov[0].iov_len = strlen(str0) + 1;
    iov[1].iov_base = str1;
    iov[1].iov_len = strlen(str1) + 1;

    nwritten = writev(STDOUT_FILENO, iov, 2);
    nwritten2 = writev(STDOUT_FILENO, iov, 2);
   
    iov[0].iov_len=0;//将第一缓冲区长度设置为0，验证输出结果
    nwritten3= writev(STDOUT_FILENO, iov, 2);
    printf("%ld bytes written.\n", nwritten);
    printf("%ld bytes written.\n", nwritten2);
    printf("%ld bytes written.\n", nwritten3);

    exit(EXIT_SUCCESS);
}
复制代码
输出：

复制代码
hello world
hello world
world
14 bytes written.
14 bytes written.
7 bytes written.
复制代码
经过上述代码说明：

writev多次调用，并不会改变参数iovec*的内容，长度也不会改变，所以在while循环写入时可能要调整指针位置；
写入时首先根据第三个参数iovcnt来遍历每个结构体，然后对读取结构体中以iov_base开始的iovlen个长度，如果iovlen=0的话，是不会读取的。
 

标签: 高性能服务器