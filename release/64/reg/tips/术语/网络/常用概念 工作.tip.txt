交换芯片原理:
Input pipeline
Fifo(qos)
output pipeline


入方向的处理:
L2查找(mac表查询)
Acl
L3查找(路由表查询)

出方向的处理:与入方向类似处理

Acl按优先级查找
Key:匹配报文特征字段
Action:
Copy 2cpu
Redirect
Drop

Copy 2cpu拷贝一份通过pcie到cpu,遗留的源报文按照默认处理，通常为丢弃，还有别的处理？

Acl如果都没有匹配，按照默认处理，通常为丢失。

Bpdu报文:国际标准定义的格式，通常有专用寄存器对这个进行处理，lacp/mstp/zesr协议报文











Pvid:端口默认vlan,特指对入方向报文，打标签
Untag,tag:特指vlan报文，出方向是的动作

如果pvid指的默认vlan,光口进来打上vlan，那么光口出去的应该是去掉vlan的才对。？？？
如果这样的话，端口针对报文处理，一入一出。入看pvid,出看tag/untag

光口的出方向属性是untag
下背板的是tagged
接口板进报文的端口pvid应该是x,属性是untag




协议报文:两个节点间终结的报文，比如
Arp
Ppp
Pppoe
Ospf
这个名称有歧义，改成节点间报文比较合适
问题:如果这样，报文中是不是就可以没有ip地址了？










数据报文:跨越两个节点的报文
Ftp
Sftp
Udp
Tcp
Dhcp
Ping icmp
Ip包


Mac表:
mac
Vlan
端口
的映射表





路由表:
目的Ip
掩码
端口
下一跳ip


判断是否走三层路由，有一个L3 interface,包含:
Vid
Mac
Port
如果有匹配，查找三层路由表，
如果不匹配，查找二层mac表


Pc和接入网元连接时，pc给非接入网元发送的报文da其实还是接入网元的mac,

三层路由的da,sa在不断变更，每走一段，重新封装l2包头

三层的sa用处不大，除非有防火墙的要求

报文正常建链的过程其实是最终目的，两段的端口类型必须一致的，比如ppp/eth/pppoe类型，如果端口类型不一致，那么通信的报文无法解析，无法识别。

Ppp属于私有报文格式，无法通用，格式为
Da,SA,ETHERTYPE,PPP头，IP头，DATA



两个ip网段是否可以通信，看ip网段是否可以相互包含，按精确匹配，最长长度进行判断规则





L3路由表:下一跳可以是学习过来的ip,也可以是指定出端口
芯片类似于fpga,cpu通过sdk接口来操作交换芯片


上行报文:
物理端口
交换芯片
Linix物理口
Linux虚拟口
Tcp/ip层
Raw socket
Pdc
Rosng协议栈(包含协议报文和数据报文)



Raw socket是应用层打开后，linux协议栈拷贝一份数据传递给应用层，如果应用层打开多个raw socket,则会复制多份


报文会经过linux协议栈的处理，如果没有匹配的处理，最终会丢掉


报文经过实网口后，会按照规则分发给虚网口，比如按vlan或者mac


Wason属于应用进程，操作eth8端口(也是虚拟出来的)，路由配置需要在rosng协议栈，交换芯片上配置，同时linux配置一条缺省路由，即下行报文的路径。



如果linux 网口和rosng生成的端口都配置了相同ip,可能存在应答两份的问题，这种不正常的。



光口的是否走路由判断是光口vlan id+ mac00d4,符合这个去查找l3,判断是走本机还是硬转发到别的端口

show ipuc下一跳中的macda ，去往网管的mac是学习不到的，因为不在一个网段，学习到的是经过的交换机上的端口mac,


L3要路由的报文，其实da sa 都是需要重新封装的，一般不关注sa,每经过一段，da需要重新修改掉，唯一不变的是ip层中的dest ip和 src ip













