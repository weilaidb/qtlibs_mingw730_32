为什么需要序列化

阿肯那顿

于 2018-02-22 10:31:10 发布

20240
 收藏 31
分类专栏： java 文章标签： java

java
专栏收录该内容
22 篇文章0 订阅
订阅专栏
MSDN的定义：序列化是将对象状态转换为可保持或可传输的形式的过程。序列化的补集是反序列化，后者将流转换为对象。这两个过程一起保证数据易于存储和传输。

大家关心的是为什么需要序列化，用传统的方法也能实现这种需求吗，它存在的价值是什么，低层的原理、实质、基因的区别是什么？这也是我的疑问，通过在网上搜集，找到了较满意的答案，分享给大家。

答案一
序列化是用来通信的，服务端把数据序列化，发送到客户端，客户端把接收到的数据反序列化后对数据进行操作，完成后再序列化发送到服务端，服务端再反序列化数据后对数据进行操作。说白了，数据需要序列化以后才能在服务端和客户端之间传输。这个服务端和客户端的概念是广义的，可以在网络上，也可以在同一台机器的不同进程中，甚至在同一个进程中进行通信。在传统编程中，对象是通过调用栈间接的与客户端交互，但在面向服务的编程中，客户端永远都不会直接调用实例。不知道说的明不明白。

好吧，我说的确实不够明白，你问的是为什么需要序列化，我只是说了序列化的一个应用。那我就来说说序列化的好处吧。不序列化也可以传输，但是无法跨平台，安全性也无法保障。我说的是面向服务编程中的作用，在传统编程中，你在表示层实例化一个业务对象，然后调用业务对象中的方法，你想过为什么能这样调用吗？这样做耦合度太高，很不好。如果序列化以后通过特定的协议传输数据就不一样了，表示层通过代理或通道向服务层发送特定的数据格式，这个数据就是序列化以后的，比如XML，服务端接收到以后要进行反序列化，生成服务端可识别的数据格式，比如一个类，然后对数据进行操作，再序列化发送到客户端，客户端再反序列化。这样客户端可以使用和服务端完全不同的开发平台，只要它能够对xml数据进行反序列化，而xml是具有工业标准的数据格式，基本各平台都支持。这也适用于在进程间通信。如果在进程内通信，也可以做到更高的安全性，对象不再通过调用栈交互，而是通过代理或通道。

答案二
这个更进一步的解释了其真正的价值。

简单来说序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化，流的概念这里不用多说(就是I/O)，我们可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间(注：要想将对象传输于网络必须进行流化)！在对对象流进行读写操作时会引发一些问题，而序列化机制正是用来解决这些问题的！

问题的引出：
如上所述，读写对象会有什么问题呢？比如：我要将对象写入一个磁盘文件而后再将其读出来会有什么问题吗？别急，其中一个最大的问题就是对象引用！举个例子来说：假如我有两个类，分别是A和B，B类中含有一个指向A类对象的引用，现在我们对两个类进行实例化{ A a = new A(); B b = new B(); }，这时在内存中实际上分配了两个空间，一个存储对象a，一个存储对象b，接下来我们想将它们写入到磁盘的一个文件中去，就在写入文件时出现了问题！因为对象b包含对对象a的引用，所以系统会自动的将a的数据复制一份到b中，这样的话当我们从文件中恢复对象时(也就是重新加载到内存中)时，内存分配了三个空间，而对象a同时在内存中存在两份，想一想后果吧，如果我想修改对象a的数据的话，那不是还要搜索它的每一份拷贝来达到对象数据的一致性，这不是我们所希望的！

以下序列化机制的解决方案：

保存到磁盘的所有对象都获得一个序列号(1, 2, 3等等)
当要保存一个对象时，先检查该对象是否被保存了。
如果以前保存过，只需写入”与已经保存的具有序列号x的对象相同”的标记，否则，保存该对象
通过以上的步骤序列化机制解决了对象引用的问题！

总结：
描述数据的传输格式，这样可以方便自己组织数据传输格式，以至于避免一些麻烦及错误
如果是跨平台的序列化，则发送方序列化后，接收方可以用任何其支持的平台反序列化成相应的版本，比如 Java序列化后， 用.net、phython等反序列化