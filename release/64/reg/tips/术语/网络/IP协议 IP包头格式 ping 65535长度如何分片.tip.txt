相应标注在RFC791

格式为
版本  头部长度 服务类型  总长度  (4 4 8 16) 单位bit
标识符  标记  分片偏移           (16 3 13)
生存时间 协议  头部校验          (8 8 16)
源地址                           (32)
目的地址                         (32)
可选项 填充项                    (24 8)



总长度最大为65535，去除IP 20个字节，生下65515



最后，我们来计算一下该数据包的长度：

默认的MTU
1.IP+ICMP+DATA = 1500字节
2.ping size指定的是data的大小.

第一个数据包的总长度为1500字节，减去IP头部长度20字节，减去ICMP头部长度8字节，即1500-20-8＝1472字节；
第二个数据包的总长度为548字节，减去IP头部长度20字节，即548-20＝528字节，两个数据包的净载荷1472+528＝2000，正好是我们发送的数据长度。
————————————————
版权声明：本文为CSDN博主「上善若水2020」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41486034/article/details/107629278



IP最大为两个字节最大值，长度为65535，如何分片？
Data长度 = 65535 - 20 - 8 = 65515(指定发送用户数据最大净荷)
前提:MTU = 1500
IP包总长：1514 = DA(6)+SA(6) + EtherType(2) + MTU + FCS(4,没有这个？)

第一片:IP + ICMP + DATA = 20 + 8 + 1472 = 1500 (Data长度是1472)
第二片:IP + DATA = 20 + 1480（Data长度是1480）
第三片:IP + DATA = 20 + 1480
。。。。

第45片:IP + DATA = 20 + 403

65515/1480.0 = 44.2668918919
可以看出要分为45包
Data长度 65515 - 1472 - 43 * 1480 = 403
tcpdump IP包大小：14 + 20 + 403 = 437


====================
windows长最多大小为65500 （净荷）
C:\Users\weilaidb>ping 49.234.85.12 -l 65500 -n 1

正在 Ping 49.234.85.12 具有 65500 字节的数据:
来自 49.234.85.12 的回复: 字节=65500 时间=40ms TTL=53

49.234.85.12 的 Ping 统计信息:
    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 40ms，最长 = 40ms，平均 = 40ms


总长度为65500，如何分片？
!!!!!65500是真正的用户数据，不包含IP头部20个字节
!!!!!65500是真正的用户数据，不包含IP头部20个字节
!!!!!65500是真正的用户数据，不包含IP头部20个字节
Data用户数据总长度 = 65500
前提:MTU = 1500
IP包总长：1514 = DA(6)+SA(6) + EtherType(2) + MTU + FCS(4,没有这个？)

第一片:IP + ICMP + DATA = 20 + 8 + 1472 = 1500 (Data长度是1472)
第二片:IP + DATA = 20 + 1480（Data长度是1480）
第三片:IP + DATA = 20 + 1480
。。。。

第45片:IP + DATA = 20 + 388


65472/1480.0 = 44.2378378378
可以看出要分为45包
Data长度 65500- 1472 - 43 * 1480 = 388
65500 - 1480 * 44 + 8 = 388

最后一包IP总长度应该为
DA(6)+SA(6) + EtherType(2) + MTU = 14 + 20 + 388 = 422


分片中IP总长度分别为（不是IP数据包长）：
1500 * 44 + 408 = 66408
66408 - 20*45 - 8 = 65500

最后一包tcpdump 报文长度 422
tcpdump报文长度分别为:
第一包:1500 + 14 = 1514




