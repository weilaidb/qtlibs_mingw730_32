__inline__ __attribute__((always_inline))学习

机器人小雪
0.567
2016.09.12 11:17:05
字数 453
阅读 7,905
1.在YYModel中发现如下的一个宏.

#define force_inline __inline__ __attribute__((always_inline))
2.百度 __inline__ __attribute__((always_inline)) 的意思是强制内联.所有加 __inline__ __attribute__((always_inline)) 修饰的函数在被调用的时候不会被编译成函数调用,而是直接扩展到调用函数体内.

具体什么意思呢?

需要理解下,我们写的代码并不是直接去运行的.是编译器将我们的代码先编译成底层可以识别的代码.c或者汇编.

当我们用__inline__ __attribute__((always_inline))修饰一个函数的时候,编译器会将我们的代码编译.在调用的地方将我们的函数,插入到调用的地方.
举个栗子:

__attribute__((always_inline)) void a(){
    print("a"); 
}

void b()
{
  a();
}
编译以后就是:

 void b()
｛
      print("a"); 
｝
总结

内联函数在编译器最终生成的代码中是 没有定义的. 这个函数是不存在的.
内联函数也就没有普通函数调用时的额外开销 (压榨,跳转,返回)

内联函数是一种特殊的函数,具有普通函数的特征.
他是对编译器的一种请求.因此,编译器有可能拒绝这种请求.
内联函数 由 编译器处理,直接将编译后的函数体插入调用的地方.

另外:宏代码片段 由预处理器处理,进行简单的文本替换,没有任何编译过程.

C++中 内联编译限制:
1.不能存在任何形式的循环语句.
2.不能存在过多的条件判断语句.
3.函数体不能过于庞大.
4.不能对函数进行取址操作.
5.内联函数声明必须在调用语句之前.

当函数体的执行开销大于压栈,跳转和返回所用的开销时,那么内联将无意义.