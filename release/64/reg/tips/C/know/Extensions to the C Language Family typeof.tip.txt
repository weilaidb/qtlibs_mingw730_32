Next: C++ Implementation, Previous: C Implementation, Up: Top

6 Extensions to the C Language Family
GNU C provides several language features not found in ISO standard C. (The -pedantic option directs GCC to print a warning message if any of these features is used.) To test for the availability of these features in conditional compilation, check for a predefined macro __GNUC__, which is always defined under GCC.

These extensions are available in C and Objective-C. Most of them are also available in C++. See Extensions to the C++ Language, for extensions that apply only to C++.

Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.

Statement Exprs: Putting statements and declarations inside expressions.
Local Labels: Labels local to a block.
Labels as Values: Getting pointers to labels, and computed gotos.
Nested Functions: As in Algol and Pascal, lexical scoping of functions.
Constructing Calls: Dispatching a call to another function.
Typeof: typeof: referring to the type of an expression.
Conditionals: Omitting the middle operand of a `?:' expression.
Long Long: Double-word integers---long long int.
__int128: 128-bit integers---__int128.
Complex: Data types for complex numbers.
Floating Types: Additional Floating Types.
Half-Precision: Half-Precision Floating Point.
Decimal Float: Decimal Floating Types.
Hex Floats: Hexadecimal floating-point constants.
Fixed-Point: Fixed-Point Types.
Named Address Spaces: Named address spaces.
Zero Length: Zero-length arrays.
Variable Length: Arrays whose length is computed at run time.
Empty Structures: Structures with no members.
Variadic Macros: Macros with a variable number of arguments.
Escaped Newlines: Slightly looser rules for escaped newlines.
Subscripting: Any array can be subscripted, even if not an lvalue.
Pointer Arith: Arithmetic on void-pointers and function pointers.
Initializers: Non-constant initializers.
Compound Literals: Compound literals give structures, unions or arrays as values.
Designated Inits: Labeling elements of initializers.
Cast to Union: Casting to union type from any member of the union.
Case Ranges: `case 1 ... 9' and such.
Mixed Declarations: Mixing declarations and code.
Function Attributes: Declaring that functions have no side effects, or that they can never return.
Attribute Syntax: Formal syntax for attributes.
Function Prototypes: Prototype declarations and old-style definitions.
C++ Comments: C++ comments are recognized.
Dollar Signs: Dollar sign is allowed in identifiers.
Character Escapes: `\e' stands for the character <ESC>.
Variable Attributes: Specifying attributes of variables.
Type Attributes: Specifying attributes of types.
Alignment: Inquiring about the alignment of a type or variable.
Inline: Defining inline functions (as fast as macros).
Volatiles: What constitutes an access to a volatile object.
Extended Asm: Assembler instructions with C expressions as operands. (With them you can define ``built-in'' functions.)
Constraints: Constraints for asm operands
Asm Labels: Specifying the assembler name to use for a C symbol.
Explicit Reg Vars: Defining variables residing in specified registers.
Alternate Keywords: __const__, __asm__, etc., for header files.
Incomplete Enums: enum foo;, with details to follow.
Function Names: Printable strings which are the name of the current function.
Return Address: Getting the return or frame address of a function.
Vector Extensions: Using vector instructions through built-in functions.
Offsetof: Special syntax for implementing offsetof.
Atomic Builtins: Built-in functions for atomic memory access.
Object Size Checking: Built-in functions for limited buffer overflow checking.
Other Builtins: Other built-in functions.
Target Builtins: Built-in functions specific to particular targets.
Target Format Checks: Format checks specific to particular targets.
Pragmas: Pragmas accepted by GCC.
Unnamed Fields: Unnamed struct/union fields within structs/unions.
Thread-Local: Per-thread variables.
Binary constants: Binary constants using the `0b' prefix.






















Next: Conditionals, Previous: Constructing Calls, Up: C Extensions

6.6 Referring to a Type with typeof
Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.

There are two ways of writing the argument to typeof: with an expression or with a type. Here is an example with an expression:

     typeof (x[0](1))
This assumes that x is an array of pointers to functions; the type described is that of the values of the functions.

Here is an example with a typename as the argument:

     typeof (int *)
Here the type described is that of pointers to int.

If you are writing a header file that must work when included in ISO C programs, write __typeof__ instead of typeof. See Alternate Keywords.

A typeof-construct can be used anywhere a typedef name could be used. For example, you can use it in a declaration, in a cast, or inside of sizeof or typeof.

The operand of typeof is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.

typeof is often useful in conjunction with the statements-within-expressions feature. Here is how the two together can be used to define a safe “maximum” macro that operates on any arithmetic type and evaluates each of its arguments exactly once:

     #define max(a,b) \
       ({ typeof (a) _a = (a); \
           typeof (b) _b = (b); \
         _a > _b ? _a : _b; })
The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for a and b. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.

Some more examples of the use of typeof:

This declares y with the type of what x points to.
          typeof (*x) y;
     
This declares y as an array of such values.
          typeof (*x) y[4];
     
This declares y as an array of pointers to characters:
          typeof (typeof (char *)[4]) y;
     
It is equivalent to the following traditional C declaration:

          char *y[4];
     
To see the meaning of the declaration using typeof, and why it might be a useful way to write, rewrite it with these macros:

          #define pointer(T)  typeof(T *)
          #define array(T, N) typeof(T [N])
     
Now the declaration can be rewritten this way:

          array (pointer (char), 4) y;
     
Thus, array (pointer (char), 4) is the type of arrays of 4 pointers to char.

Compatibility Note: In addition to typeof, GCC 2 supported a more limited extension which permitted one to write

     typedef T = expr;
with the effect of declaring T to have the type of the expression expr. This extension does not work with GCC 3 (versions between 3.0 and 3.2 will crash; 3.2.1 and later give an error). Code which relies on it should be rewritten to use typeof:

     typedef typeof(expr) T;
This will work with all versions of GCC.
