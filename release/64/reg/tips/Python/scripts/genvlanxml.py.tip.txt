#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#filename:genvlanxml.py
#function:生成VLAN配置的XML格式

##########
#1.规则端口的类型，比如xk
#2.规定VLAN的添加的类型范围
#3.根据VLAN的类型范围依次添加
#4.后续根据文件中解析出来对应的端口类型（扩展）
#缩略语
#xk:线卡
#bfpga:大逻辑
#cfpga:控制逻辑
#osc:光监控端口
#shell:子架级联端口
#ms:主备端口
#eth1:连接CPU的GE?
#eth2:连接CPU的10GE?
#使用方法:
#使用方法:
#使用方法:
#★type_port.txt :端口按类型定义，比如xk:12 表示类型:端口号
#★vlan_type.txt :VLAN和端口范围对应关系表，比如vlan1:xk,bfpga,cfpga 表示vlan1范围包含xk,bfpga,cfpga。
#★vlan.xml      :生成的最终文件xml，里面包含部分内容
#★脚本执行./a.py 实际路径，示例./a.py .
#★


import sys
sys.path.append('.')
#自定义公共函数
from public import *




#####定义结束标志，标志未修改时为正常退出，默认为异常值，正常值为0
quitflag=1

def setquitflag(flag):
    global quitflag
    quitflag = flag

def over():
    global add
    printlntips("quitflag",quitflag, False)
    if 0 != quitflag:
        print('异常退出，！！！！！！！！')
    else:
        print('正常结束，★★★★★★★★★★★★★★★★')


atexit.register(over)

########main proc
if __name__ == '__main__':
    print("===========main proc===========\n" * 3)
    if len(sys.argv) < 2:
        print("usage: ./eg.sh RootPath\n")
        exit(0)

    print(sys.argv)
    
    signmao=":"
    signdot=","
    signenter="\n"
    strvlan="vlan"
    strempty = ""
    result = ""

    rootpath=sys.argv[1]
    typefile=concat(rootpath, ("/type_port.txt"))
    vlanfile=concat(rootpath, ("/vlan_type.txt"))
    xmlfile=concat(rootpath , ("/vlan.xml"))

    # println(rootpath)
    # println(typefile)
    # println(vlanfile)
    # println(xmlfile)

    checkdirnoexistquit(rootpath)
    checkfilenoexistquit(typefile)
    checkfilenoexistquit(vlanfile)
    #执行前先删除XML文件
    filedelete(xmlfile)

    types = fileread(typefile)
    printlntips("==>port types list", types)

    vlans = fileread(vlanfile)
    printlntips("==>port vlans list", vlans)

    typelist = splitstrbyenternoempty(types)
    printlntips("typelist", typelist)


    typeonlylist = replacelistreg(typelist, r':.*', strempty)
    printlntips("typeonlylist", typeonlylist)

    vlanlist = splitstrbyenternoempty(vlans)
    lenlntips("vlan_type file line count", vlanlist)

    for vlan in vlanlist:
        println()
        println(vlan)
        vlanitems = splitstrbysignnoempty(vlan, signmao)
        if len(vlanitems) < 2:
            lenlntips("vlanitems size", vlanitems)
            println("vlanitems should like this, vlanx:xk,bfpga")
            exit(0)
        vlanfirst = replacestr(vlanitems[0],strvlan,strempty)
        vlantypesstr = vlanitems[1]
        vlantypes = splitstrbysignnoempty(vlantypesstr, signdot)
        lenlntips("vlantypes size", vlantypes)
        for vlantp in vlantypes:
            printlntips("vlan type", vlantp, False)
            
            #根据类型查找所有相关端口
            findonlytypelist = findstrinlist(vlantp, typeonlylist,True)
            lenlntips("findonlytypelist size", findonlytypelist)
            #判断当前类型是否在已知列表中
            if(0 == len(findonlytypelist)):
                print("!!!!!! invalid vlantp:%s for %s" % (vlantp, vlan))
                printlntips("support port types", findonlytypelist)
                exit(0)
                
            #根据类型查找所有相关端口
            findportlist = findstrinlist_replace(vlantp, typelist, r':.*', strempty,True)
            lenlntips("findportlist size", findportlist)
            
            #判断当前类型是否在已知列表中
            if(0 == len(findportlist)):
                print("!!!!!! invalid vlantp:%s for %s" % (vlantp, vlan))
                exit(0)

            for port in findportlist:
                #生成最终的XML配置，根据格式
                lastport = replacestrreg(port, r'.*:',strempty)
                lastport = stripstr(lastport)
                if(lastport.isdigit()) and (vlanfirst.isdigit()):
                    print("-->last xml, vlan-port:%s/%s" % (vlanfirst, lastport))
                    result = concat(result, vlanfirst)
                    result = concat(result, signmao)
                    result = concat(result, lastport)
                    result = concat(result, signenter)
                else:
                    print("!!!!!! invalid lastport:%s or vlanfirst:%s" % (lastport, vlanfirst))
                    exit(0)



    # print(sys._getframe().f_lineno)     # 获取当前行号(行数)
    println(result)
    filewrite(xmlfile, result)
    #设置成功标志
    setquitflag(0)