脚本前:
##处理带空格的文件名
MY_SAVEIFS=$IFS
#IFS=$(echo -en "\n\b")
IFS=$'\n'



脚本后:
#回复默认处理分割
IFS=$MY_SAVEIFS







Linux shell 技巧：对文件名中包含空格的处理方法

keypeople

于 2017-10-01 13:53:08 发布

10498
 收藏 3
文章标签： Linux shell 空格
版权
在Window中，我们对文件命名时候经常使用用空格，例如目录“meda a”。但是这种命名方式给Linux命令行工具和Shell带来了困扰，因为大多数命令中，都是默认以空格做为值与值之间的分隔符，而不是做为文件名的一部分。即环境变量IFS（the Internal Field Separator）为值为 空格、Tab、回车。

先来看下IFS的man page,
IFS: The Internal Field Separator that is used for word splitting after expansion and to split lines into words with the read built-in command. The default value is “<space><tab><new-line>”.


来看一个问题，让我们对问题有更清楚的认识：
Task：用shell脚本将某源目录下的所有文件质到某目标目录（目录或文件可能有空格）。其中， 目标目录为某工程目录（有很多很多文件）， 源目录下的文件为我们更改后（为修复bug，或其他的一些什么理由）的文件。

为描述简单，我们假设可通过 do_this 确定源目录（假设为files）和目标目录(假设为target)，通过do_that 完成其他工作。我们的任务就是把files目录中的文件（如有）拷贝到target目录下。

即假设各目录的结构如下（原谅我没装tree），


实现脚本如下，
  #!/bin/sh
 
  do_this()
  {
      echo done with this;
  }
 
  do_that()
  {
     echo done with that;
  }
 
  # Enter
  do_this
 
  cd files
  for file in `find . -type f`
  do
      #echo "$file"
      cp -v "$file" ../target/"$file"
 
  done
 
  do_that
 

运行结果如下：


我们发现shell 把目录 “ meda a ”解析成了两个目录：目录“meda”和目录“a”。

那么，为什么会有这样的问题，又如何解决这个问题呢？

问题产生的原因如前所述，是因为Linux命令行工具和Shell都是默认以空格、Tab、回车做为值与值之间的分隔符，而不是做为文件名的一部分，因为目录“meda a”中含有空格，所以shell认识是两个目录。

上面的问题，可以通过修改Linux命令行工具和Shell的默认分隔符来解决，修改上述shell脚本如下：
  #!/bin/sh
  
  do_this()
  {
      echo done with this;
  }
  
  do_that()
  {
     echo done with that;
  }
 
  # Enter
  do_this
 
  MY_SAVEIFS=$IFS
  #IFS=$(echo -en "\n\b")
  IFS=$'\n'
 
  cd files
  for file in `find . -type f`
  do
      #echo "$file"
      cp -v "$file" ../target/"$file"
 
  done
  IFS=$MY_SAVEIFS
 
  do_that

执行结果如下：


我们发现，此时脚本已经可以正确处理带有空格的文件（或目录）了。
————————————————
版权声明：本文为CSDN博主「keypeople」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/keypeople/article/details/78147288