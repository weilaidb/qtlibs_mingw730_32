MOC Meta-Object Compiler,MOC 
Qt的元对象编译器，是一个预处理器，在源程序被编译前先将这些Qt特性的程序转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。这就是为什么在使用信号与槽机制的类里，必须添加 Q_OBJECT 宏的原因，只有添加了这个宏，moc才能对类里的信号与槽的代码进行预处理。

class MainWindow : public QMainWindow
{
    Q_OBJECT


元对象系统由以下三个基础组成。
QObject类是所有使用元对象系统的类的基类。
Q_OBJECT
Q_OBJECT
Q_OBJECT
在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。
MOC（元对象编译器）为每个QObject的子类提供必要的代码来实现元对象系统的特性。
构建项目时，MOC工具读取C++源文件，当它发现类的定义里有Q_OBJECT宏时，它就会为这个类生成另外一个包含有元对象支持代码的C++源文件，这个生成的源文件连同类的实现文件一起被编译和连接。
除了信号与槽机制外，元对象还提供如下一些功能。

QObject::metaObject()函数返回类关联的元对象，元对象类QMetaObject包含了访问元对象的一些接口函数，例如QMetaObject::className()函数可在运行时返回类的名称字符串。

QObject *obj = new QPushButton;
obj->metaObject()->className();    // 返回 "QPushButton"
QMetaObject::newInstance()函数创建类的一个新的实例。
QObject::inherits(const char *className)函数判断一个对象实例是否是名称为className的类或QObject的子类的实例。例如：QTimer *timer = new QTimer;        // QTimer 是QObject的子类
timer->inherits("QTimer");         // 返回 true
timer->inherits("QObject");        // 返回 true
timer->inherits("QAbstractButton");//返回 false，不是QAbstractButton的子类


qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
对于QObject及其子类，还可以使用qobject_cast()函数进行动态投射（dynamic cast）。例如，假设QMyWidget是QWidget的子类并且在类定义中声明了Q_OBJECT宏。创建实例使用下面的语句：QObject *obj = new QMyWidget;
变量obj定义为QObject指针，但它实际指向QMyWidget类，所以可以正确投射为QWidget，即：QWidget *widget = qobject_cast<QWidget *>(obj);
从QObject到QWidget的投射是成功的，因为obj实际是QMyWidget类，是QWidget的子



connect()
connect()
connect()
．connect()函数的不同参数形式
QObject::connect()函数有多重参数形式，一种参数形式的函数原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
使用这种参数形式的connect()进行信号与槽函数的连接时，一般句法如下：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
这里使用了宏SIGNAL()和SLOT()指定信号和槽函数，而且如果信号和槽函数带有参数，还需注明参数类型，如：connect(spinNum, SIGNAL(valueChanged (int)), this, SLOT(updateStatus(int));
另外一种参数形式的connect()函数的原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method, Qt::ConnectionType type = Qt::AutoConnection)
对于具有默认参数的信号与槽（即信号名称是唯一的，没有参数不同而同名的两个信号），可以使用这种函数指针形式进行关联，如：connect(lineEdit, &QLineEdit::textChanged, this, &widget::on_textChanged);
QLineEdit只有一个信号textChanged(QString), 在自定义窗体类widget里定义一个槽函数on_textChanged(QString)，就可以用上面的语句将此信号与槽关联起来，无需出现函数参数。这在信号的参数比较多时更简便一些。
而对于具有不同参数的同名信号就不能采用函数指针的方式进行信号与槽的关联，例如QSpinBox有两个valueChanged()信号，分别是：void QSpinBox::valueChanged(int i)
void QSpinBox::valueChanged(const QString &text)
即使在自定义窗体widget里定义了一个槽函数，如：void onValueChanged(int i);
在使用下面的语句进行关联时，编译会出错。connect(spinNum, &QSpinBox::valueChanged , this, &widget::onValueChanged);
不管是哪种参数形式的connect()函数，最后都有一个参数Qt::ConnectionType type，缺省值为Qt::AutoConnection。枚举类型Qt::ConnectionType表示了信号与槽之间的关联方式，有以下几种取值。
Qt::AutoConnection（缺省值）：如果信号的接收者与发射者在同一个线程，就使用Qt::Direct Connection方式；否则使用Qt::QueuedConnection方式，在信号发射时自动确定关联方式。
Qt::DirectConnection：信号被发射时槽函数立即执行，槽函数与信号在同一个线程。
Qt::QueuedConnection：在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程。
Qt::BlockingQueuedConnection：与Qt::QueuedConnection相似，只是信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一个线程时绝对不能使用这种方式，否则会造成死锁。


propertyOffset
propertyOffset
propertyOffset
这种编写代码的方式一般用于为多个同类型组件的同一信号编写一个槽函数，在槽函数里区分信号来源分别做处理，避免为每个组件分别编写槽函数形成的代码冗余。
界面上“类的元对象信息”按钮的响应代码如下：void QmyWidget::on_btnClassInfo_clicked()
{//"类的元对象信息"按钮
   const QMetaObject *meta=boy->metaObject();
   ui->textEdit->clear();
   ui->textEdit->appendPlainText("==元对象信息==\n");
   ui->textEdit->appendPlainText(
            QString("类名称：%1\n").arg(meta->className()));
   ui->textEdit->appendPlainText("property");
   for (int i=meta->propertyOffset();i<meta->propertyCount();i++)
   {
      QMetaProperty prop=meta->property(i);
      const char* propName=prop.name();
      QString   propValue=boy->property(propName).toString();
      ui->textEdit->appendPlainText(
        QString("属性名称=%1，属性值=%2").arg(propName).arg(propValue));
   }

   ui->textEdit->appendPlainText("");
   ui->textEdit->appendPlainText("classInfo");
   for (int i=meta->classInfoOffset();i<meta->classInfoCount();++i)
   {
      QMetaClassInfo classInfo=meta->classInfo(i);
      ui->textEdit->appendPlainText(QString("Name=%1; Value=%2")
                  .arg(classInfo.name()).arg(classInfo.value()));
   }
}
代码里通过boy->metaObject()获得对象boy的元对象。元对象类QMetaObject封装了访问类的元对象的各种接口函数，例如，QMetaObject:: className()返回类的名称。
QMetaObject用于属性操作的函数有以下几种。
propertyOffset()：返回类的第一个属性的序号，第一个属性的序号不一定是0。
propertyCount()：返回类的属性个数。
QMetaProperty property(int index)：返回序号为index的属性对象，返回值是QMetaProperty类型，它封装了对属性的更多特征查询功能，以及属性值的读写功能。
QMetaClassInfo类封装了类的classInfo的访问接口函数，只有name()和value()两个接口函数。


3.2　Qt全局定义
<QtGlobal>头文件包含了Qt类库的一些全局定义，包括基本数据类型、函数和宏，一般的Qt类的头文件都会包含该文件，所以不用显式包含这个头文件也可以使用其中的定义。
3.2.1　数据类型定义
为了确保在各个平台上各数据类型都有统一确定的长度，Qt为各种常见数据类型定义了类型符号，如qint8就是signed char的类型定义，即：typedef  signed char   qint8;
<QtGlobal>中定义的数据类型见表3-1。
表3-1　Qt中的数据类型定义
Qt数据类型    等效定义        字节数
qint8         signed char       1
qint16        signed short      2
qint32		signed int		4
qint64		long long int		8
qlonglong	long long int		8
quint8		unsigned char		1
quint16		unsigned short		2
quint32		unsigned int		4
quint64		unsigned long long int		8
qulonglong  unsigned long long int		8
uchar		unsigned char		1
ushort		unsigned short		2
uint		unsigned int		4
ulong		unsigned long		8
qreal		double		8
qfloat16                2
其中qreal缺省是8字节double类型浮点数，如果Qt使用-qreal float选项进行配置，就是4字节float类型的浮点数。
qfloat16是Qt 5.9.0中新增的一个类，用于表示16位的浮点数，要使用qfloat16，需要包含头文件<QFloat16>。


3.2.2　函数
< QtGlobal >头文件包含一些常用函数的定义，这些函数多以模板类型作为参数，返回相应的模板类型，模板类型可以用任何其他类型替换。若是以double或float类型数作为参数的，一般有两个参数版本的同名函数，如qFuzzyIsNull(double d) 和qFuzzyIsNull(float f)。
表3-2是<QtGlobal>中常用的全局函数定义，列出了函数的输入和输出参数（若存在double和float两种参数版本，只列出double类型参数的版本）。
表3-2　< QtGlobal >中常用的全局函数定义
函数
功能
T qAbs(const T &value)
返回变量value的绝对值
const T &qBound(const T &min, const T &value, const T &max)
返回value限定在min至max范围之内的值
bool qFuzzyCompare(double p1, double p2)
若p1和p2近似相等，返回true
bool qFuzzyIsNull(double d)
如果参数d约等于0，返回true
double qInf()
返回无穷大的数
bool qIsFinite(double d)
若d是一个有限的数，返回true
bool qIsInf(double d)
若d是一个无限大的数，返回true
bool qIsNaN(double d)
若d不是一个数，返回true
const T &qMax(const T &value1, const T &value2)
返回value1和value2中较大的值
const T &qMin(const T &value1, const T &value2)
返回value1和value2中较小的值
qint64 qRound64(double value)
将value近似为最接近的qint64整数
int qRound(double value)
将value近似为最接近的int整数
int qrand()
标准C++中rand()函数的线程安全型版本，返回0至RAND_MAX之间的伪随机数
void qsrand(uint seed)
标准C++中srand()函数的线程安全型版本，使用种子seed对伪随机数序列初始化
还有一些基础的数学运算函数在<QtMath>头文件中定义，比如三角运算函数、弧度与角度之间的转换函数等。
3.2.3　宏定义
<QtGlobal>头文件中定义了很多宏，以下一些是比较常用的。
QT_VERSION
这个宏展开为数值形式0xMMNNPP (MM = major, NN = minor, PP = patch)表示Qt编译器版本，例如Qt编译器版本为Qt 5.9.1，则QT_VERSION为0x050901。这个宏常用于条件编译设



置，根据Qt版本不同，编译不同的代码段。#if QT_VERSION >= 0x040100
   QIcon icon = style()->standardIcon(QStyle::SP_TrashIcon);
#else
   QPixmap pixmap = style()->standardPixmap(QStyle::SP_TrashIcon);
   QIcon icon(pixmap);
#endif
QT_VERSION_CHECK
这个宏展开为Qt版本号的一个整数表示，例如：#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
#include <QtWidgets>
#else
#include <QtGui>
#endif
QT_VERSION_STR
这个宏展开为Qt版本号的字符串，如“5.9.0”。
Q_BYTE_ORDER、Q_BIG_ENDIAN和Q_LITTLE_ENDIAN
Q_BYTE_ORDER表示系统内存中数据的字节序，Q_BIG_ENDIAN表示大端字节序，Q_LITTLE_ENDIAN表示小端字节序。在需要判断系统字节序时会用到，例如：#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
...
#endif
Q_DECL_IMPORT和Q_DECL_EXPORT
在使用或设计共享库时，用于导入或导出库的内容，12.4节有其使用实例。
Q_DECL_OVERRIDE
在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数paintEvent()，可以定义如下：void  paintEvent(QPaintEvent*) Q_DECL_OVERRIDE;
使用Q_DECL_OVERRIDE宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错。
Q_DECL_FINAL
这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承，示例如下：class QRect Q_DECL_FINAL { // QRect不能再被继承
     // ...
  };
Q_UNUSED(name)
这个宏用于在函数中定义不在函数体里使用的参数，示例如下：void MainWindow::on_imageSaved(int id, const QString &fileName)
{
   Q_UNUSED(id);
   LabInfo->setText("图片保存为： "+fileName);
}






在这个函数里，id参数没有使用。如果不用Q_UNUSED(id)定义，编译器会出现参数未使用的警告。
foreach(variable, container)
foreach用于容器类的遍历，例如：foreach (const QString &codecName, recorder->supportedAudioCodecs())
   ui->comboCodec->addItem(codecName);
forever
forever用于构造一个无限循环，例如：forever {
     ...
  }
qDebug(const char *message, ...)
在debugger窗体显示信息，如果编译器设置了Qt_NO_DEBUG_OUTPUT，则不作任何输出，例如：qDebug("Items in list: %d", myList.size());
类似的宏还有qWarning、qCritical、qFatal、qInfo等，也是用于在debugger窗体显示信息。






3.3　容器类
3.3.1　容器类概述
Qt提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类QStringList就是从容器类 QList<QString>继承的，实现对字符串列表的添加、存储、删除等操作。
Qt的容器类比标准模板库（STL）中的容器类更轻巧、安全和易于使用。这些容器类是隐式共享和可重入的，而且它们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说它们作为只读容器时可被多个线程访问。
容器类是基于模板的类，如常用的容器类QList<T>，T是一个具体的类型，可以是int、float等简单类型，也可以是Qstring、QDate等类，但不能是QObject或任何其子类。T必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。
例如用QList<T>定义一个字符串列表的容器，其定义方法是：QList<QString>  aList;
这样定义了一个QList容器类的变量aList，它的数据项是QString，所以aList可以用于处理字符串列表，例如：aList.append("Monday");
aList.append("Tuesday");
aList.append("Wednesday");
QString  str=aList[0];
Qt的容器类分为顺序容器（sequential containers）和关联容器（associative containers）。





容器迭代类用于遍历容器里的数据项，有Java类型的迭代类和STL类型的迭代类。Java类型的迭代类易于使用，提供高级功能，而STL类型的迭代类效率更高一些。
Qt还提供了foreach宏用于遍历容器内的所有数据项。
3.3.2　顺序容器类
Qt的顺序容器类有QList、QLinkedList、QVector、QStack和QQueue。
1．QList
QList是最常用的容器类，虽然它是以数组列表（array-list）的形式实现的，但是在其前或后添加数据非常快，QList以下标索引的方式对数据项进行访问。
QList用于添加、插入、替换、移动、删除数据项的函数有：insert()、replace()、removeAt()、move()、swap()、append()、prepend()、removeFirst()和removeLast()等。
QList提供下标索引方式访问数据项，如同数组一样，也提供at()函数，例如：QList<QString> list;
list << "one" << "two" << "three";
QString str1=list[1];   //str1=="two"
QString str0=list.at(0);   //str0=="one"
QList的isEmpty()函数在数据项为空时返回true，size()函数返回数据项的个数。
QList是Qt中最常用的容器类，很多函数的参数传递都是采用QList容器类，例如QAudioDeviceInfo的静态函数availableDevices()的函数原型是：QList<QAudioDeviceInfo> QAudioDeviceInfo::availableDevices(QAudio::Mode mode)
其返回数据就是QAudioDeviceInfo类型的QList列表。
2．QLinkedList
QLinkedList<T>是链式列表（linked-list），数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。
除了不提供基于下标索引的数据项访问外，QLinkedList的其他接口函数与QList基本相同。
3．QVector
QVector<T>提供动态数组的功能，以下标索引访问数据。
QVector的函数接口与QList几乎完全相同，QVector<T>的性能比QList<T>更高，因为QVector<T>的数据项是连续存储的。
4．QStack
QStack<T>是提供类似于堆栈的后入先出（LIFO）操作的容器类，push()和pop()是主要的接口函数。例如：QStack<int> stack;
stack.push(10);
stack.push(20);
stack.push(30);
while (!stack.isEmpty())
   cout << stack.pop() << endl;
程序会依次输出30，20，10。
5．QQueue
QQueue<T>是提供类似于队列先入先出（FIFO）操作的容器类。enqueue()和dequeue()





是主要操作函数。例如：QQueue<int> queue;
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
while (!queue.isEmpty())
   cout << queue.dequeue() << endl;
程序会依次输出10，20，30。
3.3.3　关联容器类
Qt还提供关联容器类QMap、QMultiMap、QHash、QMultiHash和QSet。
QMultiMap和QMultiHash支持一个键关联多个值，QHash和QMultiHash类使用散列（Hash）函数进行查找，查找速度更快。
1．QSet
QSet是基于散列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。QSet<T> 内部就是用QHash实现的。
定义QSet<T>容器和输入数据的实例代码如下：QSet<QString> set;
set << "dog" << "cat" << "tiger";
测试一个值是否包含于这个集合，用contains()函数，示例如下：if (!set.contains("cat"))
     ...
2．QMap
QMap<Key, T>提供一个字典（关联数组），一个键映射到一个值。QMap存储数据是按照键的顺序，如果不在乎存储顺序，使用QHash会更快。
定义QMap<QString, int>类型变量和赋值的示例代码如下：QMap<QString, int> map;
map["one"] = 1;
map["two"] = 2;
map["three "] = 3;
也可以使用insert()函数赋值，或remove()移除一个键值对，示例如下：map.insert("four", 4);
map.remove("two");
要查找一个值，使用运算符“[ ]”或value()函数，示例如下：int num1 = map["one"];
int num2 = map.value("two");
如果在映射表中没有找到指定的键，会返回一个缺省构造值（default-constructed values），例如，如果值的类型是字符串，会返回一个空的字符串。
在使用value()函数查找键值时，还可以指定一个缺省的返回值，示例如下：timeout = map.value("TIMEOUT",30);





这表示如果在map里找到键“TIMEOUT”，就返回关联的值，否则返回值为30。
3．QMultiMap
QMultiMap是QMap的子类，是用于处理多值映射的便利类。
多值映射就是一个键可以对应多个值。QMap正常情况下不允许多值映射，除非使用QMap::insertMulti()添加键值对。
QMultiMap是QMap的子类，所以QMap的大多数函数在QMultiMap都是可用的，但是有几个特殊的，QMultiMap::insert()等效于QMap::insertMulti()，QMultiMap::replace()等效于QMap::insert()。
QMultiMap使用示例如下：QMultiMap<QString, int> map1, map2, map3;
map1.insert("plenty", 100);
map1.insert("plenty", 2000);   // map1.size() == 2
map2.insert("plenty", 5000);   // map2.size() == 1
map3 = map1 + map2;            // map3.size() == 3
QMultiMap不提供“[ ]”操作符，使用value()函数访问最新插入的键的单个值。如果要获取一个键对应的所有值，使用values()函数，返回值是QList<T>类型。QList<int> values = map.values("plenty");
for (int i = 0; i < values.size(); ++i)
   cout << values.at(i) << endl;
4．QHash
QHash是基于散列表来实现字典功能的模板类，QHash<Key, T>存储的键值对具有非常快的查找速度。
QHash与QMap的功能和用法相似，区别在于以下几点：
QHash比QMap的查找速度快；
在QMap上遍历时，数据项是按照键排序的，而QHash的数据项是任意顺序的；
QMap的键必须提供“<”运算符，QHash的键必须提供“==”运算符和一个名称为qHash()的全局散列函数。
5．QMultiHash
QMultiHash是QHash的子类，是用于处理多值映射的便利类，其用法与QMultiMap类似。
3.4　容器类的迭代
迭代器（iterator）为访问容器类里的数据项提供了统一的方法，Qt有两种迭代器类：Java类型的迭代器和STL类型的迭代器。
Java类型的迭代器更易于使用，且提供一些高级功能，而STL类型的迭代器效率更高。
Qt还提供一个关键字foreach（实际是< QtGlobal >里定义的一个宏）用于方便地访问容器里所有数据项。
3.4.1　Java类型迭代器
1．Java类型迭代器总表
对于每个容器类，有两个Java类型迭代器：一个用于只读操作，一个用于读写操作，各个Java类型的容器类见表3-3。





表3-3　Java类型的迭代器类
容器类                                  只读迭代器                 读写迭代器
QList<T>,   QQueue<T>                   QListIterator<T>            QMutableListIterator<T>		
QLinkedList<T>  		                QLinkedListIterator<T>		QMutableLinkedListIterator<T>
QVector<T>, QStack<T>		            QVectorIterator<T>		    QMutableVectorIterator<T>
QSet<T>		                            QSetIterator<T>		        QMutableSetIterator<T>
QMap<Key, T>, QMultiMap<Key, T>		    QMapIterator<Key, T>		QMutableMapIterator<Key, T>
QHash<Key, T>, QMultiHash<Key, T>		QHashIterator<Key, T>		QMutableHashIterator<Key, T>
QMap和QHash等关联容器类的迭代器用法相同，QList和QLinkedList、QSet等容器类的用法相同，所以下面只以QMap和QList为例介绍迭代器的用法。
2．顺序容器类的迭代器的使用
Java类型迭代器的指针不是指向一个数据项，而是在数据项之间，迭代器指针位置示意图如图3-2所示。
图3-2　Java类型迭代器位置示意图
下面是遍历访问一个QList<QString>容器的所有数据项的典型代码。QList<QString> list;
list << "A" << "B" << "C" << "D";
QListIterator<QString> i(list);
while (i.hasNext())
   qDebug() << i.next();
QList< QString>容器对象list作为参数传递给QListIterator< QString >迭代器i的构造函数，i用于对list作只读遍历。起始时刻，迭代器指针在容器第一个数据项的前面（图3-2中数据项“A”的前面），调用hasNext()判断在迭代器指针后面是否还有数据项，如果有，就调用next()跳过一个数据项，并且next()函数返回跳过去的那个数据项。
也可以反向遍历，示例代码如下：QListIterator<QString> i(list);
i.toBack();
while (i.hasPrevious())
   qDebug() << i.previous();
QListIterator用于移动指针和读取数据的函数见表3-4。
表3-4　QListIterator常用函数




函数名
功能
void　toFront()		迭代器移动到列表的最前面（第一个数据项之前）
void　toBack()		迭代器移动到列表的最后面（最后一个数据项之后）
bool　hasNext()		如果迭代器不是位于列表最后位置，返回true
const T & next()		返回下一个数据项，并且迭代器后移一个位置
const T & peekNext()		返回下一个数据项，但是不移动迭代器位置
bool　hasPrevious()		如果迭代器不是位于列表的最前面，返回true
const T & previous()		返回前一个数据项，并且迭代器前移一个位置
const T & peekPrevious()		返回前一个数据项，但是不移动迭代器指针
QListIterator是只读访问容器内数据项的迭代器，若要在遍历过程中对容器的数据进行修改，需要使用QMutableListIterator。例如下面的示例代码为删除容器中数据为奇数的项。QList<int> list;
list <<1 <<2<<3<<4<<5;
QMutableListIterator<int> i(list);
while (i.hasNext()) {
   if (i.next() % 2 != 0)
      i.remove();
}
remove()函数移除next()函数刚刚跳过的一个数据项，不会使迭代器失效。
setValue()函数可以修改刚刚跳过去的数据项的值。
3．关联容器类的迭代器的使用
对于关联容器类QMap<Key T>，使用QMapIterator和QMutableMapIterator迭代器类，它们具有表3-4所示的所有函数，主要是增加了key()和value()函数用于获取刚刚跳过的数据项的键和值。
例如，下面的代码将删除键（城市名称）里以“City”结尾的数据项。QMap<QString, QString> map;
map.insert("Paris", "France");
map.insert("New York", "USA");
map.insert("Mexico City", "USA");
map.insert("Moscow", "Russia");
...
QMutableMapIterator<QString, QString> i(map);
while (i.hasNext()) {
   if (i.next().key().endsWith("City"))
      i.remove();
}
如果是在多值容器里遍历，可以用findNext()或findPrevious()查找下一个或上一个值，如下面的代码将删除上一示例代码中map里值为“USA”的所有数据项。QMutableMapIterator<QString, QString> i(map);
while (i.findNext("USA"))
   i.remove();







3.4.2　STL类型迭代器
1．STL类型迭代器总表
STL迭代器与Qt和STL的原生算法兼容，并且进行了速度优化。具体类型见表3-5。
对于每一个容器类，都有两个STL类型迭代器：一个用于只读访问，一个用于读写访问。无需修改数据时一定使用只读迭代器，因为它们速度更快。
表3-5　STL类型的迭代器类
容器类		只读迭代器		读写迭代器
QList<T>, QQueue<T>		QList<T>::const_iterator		QList<T>::iterator
QLinkedList<T>		QLinkedList<T>::const_iterator		QLinkedList<T>::iterator
QVector<T>, QStack<T>		QVector<T>::const_iterator		QVector<T>::iterator
QSet<T>		QSet<T>::const_iterator		QSet<T>::iterator
QMap<Key, T>QMultiMap<Key, T>		QMap<Key, T>::const_iterator		QMap<Key, T>::iterator
QHash<Key, T>QMultiHash<Key, T>		QHash<Key, T>::const_iterator		QHash<Key, T>::iterator
注意　
在定义只读迭代器和读写迭代器时的区别，它们使用了不同的关键字，const_iterator定义只读迭代器，iterator定义读写迭代器。此外，还可以使用const_reverse_iterator和reverse_iterator定义相应的反向迭代器。
STL类型的迭代器是数组的指针，所以“++”运算符使迭代器指向下一个数据项，“*”运算符返回数据项内容。与Java类型的迭代器不同，STL迭代器直接指向数据项，STL迭代器指向位置示意图如图3-3所示。
图3-3　STL类型迭代器位置示意图
begin()函数使迭代器指向容器的第一个数据项，end()函数使迭代器指向一个虚拟的表示结尾的数据项，end()表示的数据项是无效的，一般用作循环结束条件。
下面仍然以QList和QMap为例说明STL迭代器的用法，其他容器类迭代器的用法类似。
2．顺序容器类的迭代器的用法
下面的示例代码将QList<QString> list里的数据项逐项输出。QList<QString> list;
list << "A" << "B" << "C" << "D";
QList<QString>::const_iterator i;
for (i = list.constBegin(); i != list.constEnd(); ++i)
   qDebug() << *i;






constBegin()和constEnd()是用于只读迭代器的，表示起始和结束位置。
若使用反向读写迭代器，并将上面示例代码中list的数据项都改为小写，代码如下：QList<QString>::reverse_iterator i;
for (i = list.rbegin(); i != list.rend(); ++i)
   *i = i->toLower();
}
3．关联容器类的迭代器的用法
对于关联容器类QMap和QHash，迭代器的“*”操作符返回数据项的值。如果想返回键，使用key()函数。对应的，用value()函数返回一个项的值。
例如，下面的代码将QMap<int, int> map中所有项的键和值输出。QMap<int, int> map;
...
QMap<int, int>::const_iterator i;
for (i = map.constBegin(); i != map.constEnd(); ++i)
   qDebug() << i.key() << ':' << i.value();
Qt API包含很多返回值为QList或QStringList的函数，要遍历这些返回的容器，必须先复制。由于Qt使用了隐式共享，这样的复制并无多大开销。例如下面的代码是正确的。const QList<int> sizes = splitter->sizes();
QList<int>::const_iterator i;
for (i = sizes.begin(); i != sizes.end(); ++i)
   ...提示　
隐式共享（Implicit Sharing）是对象的管理方法。一个对象被隐式共享，只是传递该对象的一个指针给使用者，而不实际复制对象数据，只有在使用者修改数据时，才实质复制共享对象给使用者。如在上面的代码中，splitter->sizes()返回的是一个QList<int>列表对象sizes，但是实际上代码并不将splitter->sizes()表示的列表内容完全复制给变量sizes，只是传递给它一个指针。只有当sizes发生数据修改时，才会将共享对象的数据复制给sizes，这样避免了不必要的复制，减少了资源占用。
而下面的代码是错误的。QList<int>::const_iterator i;
for (i = splitter->sizes().begin(); i != splitter->sizes().end(); ++i)
   ...
对于STL类型的迭代器，隐式共享还涉及另外一个问题，即当有一个迭代器在操作一个容器变量时，不要去复制这个容器变量。
3.4.3　foreach关键字
如果只是想遍历容器中所有的项，可以使用foreach关键字。foreach是<QtGlobal>头文件中定义的一个宏。使用foreach的句法是：foreach (variable, container) 
使用foreach的代码比使用迭代器更简洁。例如，使用foreach遍历一个QLinkedList<QString>的示例代码如下：







QLinkedList<QString> list;
...
QString str;
foreach (str, list)
   qDebug() << str;
用于迭代的变量也可以在foreach语句里定义，foreach语句也可以使用花括号，可以使用break退出迭代，示例代码如下：QLinkedList<QString> list;
...
foreach (const QString &str, list) {
   if (str.isEmpty())
      break;
   qDebug() << str;
}
对于QMap和QHash，foreach会自动访问“键——值”对里的值，所以无需调用values()。如果需要访问键则可以调用keys()，示例代码如下：QMap<QString, int> map;
...
foreach (const QString &str, map.keys())
   qDebug() << str << ':' << map.value(str);
对于多值映射，可以使用两重foreach语句，示例代码如下：QMultiMap<QString, int> map;
...
foreach (const QString &str, map.uniqueKeys()) {
   foreach (int i, map.values(str))
      qDebug() << str << ':' << i;
}注意　
foreach关键字遍历一个容器变量是创建了容器的一个副本，所以不能修改原来容器变量的数据项。
3.5　Qt类库的模块
Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类。
Qt基本模块（Qt Essentials）：提供了Qt在所有平台上的基本功能。
Qt附加模块（Qt Add-Ons）：实现一些特定功能的提供附加价值的模块。
增值模块（Value-Add Modules）：单独发布的提供额外价值的模块或工具。
技术预览模块（Technology Preview Modules）：一些处于开发阶段，但是可以作为技术预览使用的模块。
Qt工具（Qt Tools）：帮助应用程序开发的一些工具。
Qt官网的“All Modules”页面可以查看所有这些模块的信息。
3.5.1　Qt基本模块
Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt 5所有版本上是源代码和二进制兼容的。这些具体的基本模块见表3-6。
表3-6　Qt基本模块












3.5　Qt类库的模块
Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类。
Qt基本模块（Qt Essentials）：提供了Qt在所有平台上的基本功能。
Qt附加模块（Qt Add-Ons）：实现一些特定功能的提供附加价值的模块。
增值模块（Value-Add Modules）：单独发布的提供额外价值的模块或工具。
技术预览模块（Technology Preview Modules）：一些处于开发阶段，但是可以作为技术预览使用的模块。
Qt工具（Qt Tools）：帮助应用程序开发的一些工具。
Qt官网的“All Modules”页面可以查看所有这些模块的信息。
3.5.1　Qt基本模块
Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt 5所有版本上是源代码和二进制兼容的。这些具体的基本模块见表3-6。
表3-6　Qt基本模块




模块
描述
Qt Core
其他模块都用到的核心非图形类
Qt GUI
设计GUI界面的基础类，包括OpenGL
Qt Multimedia
音频、视频、摄像头和广播功能的类
Qt Multimedia Widgets
实现多媒体功能的界面组件类
Qt Network
使网络编程更简单和轻便的类
Qt QML
用于QML和JavaScript语言的类
Qt Quick
用于构建具有定制用户界面的动态应用程序的声明框架
Qt Quick Controls
创建桌面样式用户界面，基于Qt Quick的用户界面控件
Qt Quick Dialogs
用于Qt Quick的系统对话框类型
Qt Quick Layouts
用于Qt Quick 2界面元素的布局项
Qt SQL
使用SQL用于数据库操作的类
Qt Test
用于应用程序和库进行单元测试的类
Qt Widgets
用于构建GUI界面的C++图形组件类
Qt Core模块是Qt类库的核心，所有其他模块都依赖于此模块，如果使用qmake构建项目，则Qt Core模块是自动被加入项目的。
Qt GUI模块提供了用于开发GUI应用程序的必要的类，使用qmake构建应用程序时，Qt GUI模块是自动被加入项目的。如果项目中不使用GUI功能，则需要在项目配置文件中加入如下的一行：QT -= gui
其他的模块一般不会被自动加入到项目，如果需要在项目中使用某个模块，则可以在项目配置中添加此模块。例如，如果需要在项目中使用Qt Multimedia和Qt Multimedia Widgets模块，需要在项目配置文件中加入如下的语句：QT += multimedia multimediawidgets
需要在项目中使用Qt SQL模块，就在项目配置文件中加入如下的语句：QT += sql
3.5.2　Qt附加模块
Qt附加模块可以实现一些特定目的。这些模块可能只在某些开发平台上有，或只能用于某些操作系统，或只是为了向后兼容。用户安装时可以选择性地安装这些附加模块。
表3-7是附加模块列表（未列出一些过时的模块，以及专门用于QML或Qt Quick的模块）。
表3-7　Qt附加模块





模块
描述
Active Qt
用于开发使用ActiveX和COM的Windows应用程序
Qt 3D
支持2D和3D渲染，提供用于开发近实时仿真系统的功能
Qt Android Extras
提供Android平台相关的API
Qt Bluetooth
提供访问蓝牙硬件的功能
Qt Concurrent
提供一些类，无需使用底层的线程控制就可以编写多线程程序
Qt D-Bus
使进程间通过D-Bus协议通信的一些类
Qt Gamepad
使Qt应用程序支持游戏手柄硬件的使用
Qt Image Formats
支持附加图片格式的插件，包括TIFF、MNG、TGA、WBMP
Qt Mac Extras
提供macOS平台相关的API
Qt NFC
提供访问NFC（近场通信）硬件的功能
Qt Positioning
提供一些类，用于通过GPS卫星、WiFi等定位
Qt Print Support
提供一些用于打印控制的类
Qt Purchasing
提供一些类，在Qt应用程序内实现应用内购买的功能
Qt Sensors
提供访问传感器硬件的功能，以识别运动和手势
Qt Serial Bus
访问串行工业总线的功能，目前只支持CAN和Modbus协议
Qt SVG
提供显示SVG图片文件的类
Qt WebChannel
用于实现服务器端（QML或C++应用程序）与客户端（HTML/ JavaScript或QML应用程序）之间的P2P通信
Qt WebEngine
提供类和函数，实现在应用程序中嵌入网页内容
Qt WebSockets
提供兼容于RFC 6455的WebSocket通信，WebSocket是实现客户端程序与远端主机进行双向通信的基于Web的协议
Qt Windows Extras
提供Windows平台相关的API
Qt XML
该模块不再维护了，应使用Qt Core中的QXmlStreamReader 和 QXmlStreamWriter
Qt XML Patterns
提供对XPath、XQuery、XSLT 和 XML 等的支持
Qt Charts①
用于数据显示的二维图表组件
Qt Data Visualization①
用于3D数据可视化显示的界面组件
Qt Virtual Keyboard①
实现不同输入法的虚拟键盘框架
下面的附加模块只在商业许可，或GPLv3许可的版本里才有。
3.5.3　增值模块





除了随Qt5发布的上述这些模块，还有一些模块（见表3-8）是单独发布的，这些模块只在商业版许可的Qt里才有。
表3-8　Qt的增值模块
特性
描述
Qt for Device Creation
高效、易用、全集成的嵌入式设备应用程序开发工具，包括很多其他增值特性
Qt Quick Compiler
编译.qml源文件生成二进制应用程序的编译器，提高载入时间和代码的安全性
3.5.4　技术预览模块
技术预览模块就是一些还处于开发和测试阶段的模块，一般技术预览模块经过几个版本的发布后会变成正式的模块。表3-9是Qt 5.9中的技术预览模块。
表3-9　技术预览模块
模块
描述
Qt Network Authorization
基于OAuth协议，为应用程序提供网络账号验证的功能
Qt Speech
提供文字转语音（text-to-speech）功能支持
Qt Remote Objects
进程间或设备间通信，共享QObject的API
3.5.5　Qt工具
Qt工具（见表3-10）在所有支持的平台上都可以使用，用于帮助应用程序的开发和设计。
表3-10　Qt工具
工具
描述
Qt Designer
用于扩展Qt Designer的类
Qt Help
在应用程序中集成在线文档的类，实现类似于Qt Assistant的功能
Qt UI Tools
操作Qt Designer生成的窗体的类









第4章　常用界面设计组件
第2章已经介绍了设计GUI应用程序的基本原理和方法，在掌握了用Qt Creator设计应用程序的基本方法之后，要应用Qt编写各种应用程序，重要的就是熟练掌握Qt类库里各种用于界面设计或其他功能的类的使用。
Qt类库为应用程序设计提供了大量的类，本章主要介绍设计GUI应用程序常用的各种界面组件的使用，这些是设计GUI应用程序的基础。
4.1　字符串与输入输出
4.1.1字符串与数值之间的转换
界面设计时使用最多的组件恐怕就是QLabel和QLineEdit了，QLabel用于显示字符串，QLineEdit用于显示和输入字符串。这两个类都有如下的两个函数用于读取和设置显示文字。QString  text() const
void  setText(const QString &)
这两个函数都涉及到QString类。QString类是Qt程序里经常使用的类，用于处理字符串。QString类可以进行字符串与数字之间的转换，使用QLineEdit就可以实现数字量的输入与输出。
图4-1是实例samp4_1设计时的窗体，是基于QWidget创建的可视化窗体。界面设计使用了布局管理，窗体上组件的布局是：上方的几个组件是一个GridLayout，下方的9个组件也是一个GridLayout，两个GridLayout和中间一个VerticalSpacer又组成一个VerticalLayout。
在布局设计时，要巧妙运用VerticalSpacer和HorizontalSpacer，还要会设置组件的MaximumSize和MinimumSize属性，以取得期望的布局效果。例如，在图4-1中，两个GridLayout之间放了一个垂直方向的分隔，当窗体变大时，两个GridLayout的高度并不会发生变化；而如果不放置这个垂直分隔，两个GridLayout的高度都会发生变化，GridLayout内部组件的垂直距离会发生变化。
图4-1　编辑状态的界面
1．普通数值与字符串之间的转换
在UI设计器里，选中图4-1中的“计算”按钮，在右键快捷菜单里单击“Go to slot…”，并在出现的对话框里选择clicked()信号创建槽函数，在自动生成的函数体里编写如下的代码，实现从界面上分别读取数量和单价，相乘计算后将结果再显示到文本框里。void Widget::on_btnCal_clicked()
{  
   QString str=ui->editNum->text();//读取"数量"
   int num=str.toInt();  
   str=ui->editPrice->text();//读取"单价"
   float   price=str.toFloat();
   float   total=num*price;





str=str.sprintf("%.2f",total);  
   ui->editTotal->setText(str); 
}
QString类从字符串转换为整数的函数有：int     toInt(bool *ok = Q_NULLPTR, int base = 10)      const
long    toLong (bool *ok = Q_NULLPTR, int base = 10)    const
short   toShort (bool *ok = Q_NULLPTR, int base = 10)   const
uint    toUInt (bool *ok = Q_NULLPTR, int base = 10)    const
ulong   toULong (bool *ok = Q_NULLPTR, int base = 10)   const
这些函数如果不设置参数，缺省表示从十进制表示的字符串转换为整数；若指定整数基参数，还可以直接将二进制、十六进制字符串转换为整数。
QString将字符串转换为浮点数的函数有：double   toDouble(bool *ok = Q_NULLPTR)    const
float    toFloat (bool *ok = Q_NULLPTR)    const
在得到单价和数量后做相乘运算，得到计算结果变量total，再将此数值显示在编辑框editTotal中。由于计算结果是浮点数，希望显示两位小数，下面4行语句都可以实现这个功能。str=QString::number(total,'f',2); 
str=QString::asprintf("%.2f",total); 
str=str.setNum(total,'f',2); 
str=str.sprintf("%.2f",total);
可以使用QString的静态函数number()和asprintf()，也可以使用其公共函数setNum()和sprintf()。QString的sprintf()函数与C语言里的sprintf()函数的格式是一样的，而setNum()和number()函数使用另外一种格式定义，而且setNum和number有多个重载函数定义，可以处理各种类型的整数和浮点数，在处理整数时还可以指定进制，例如将一个整数直接转换为十六进制或二进制字符串。
2．进制转换
以下是读取十进制数转换为二进制和十六进制字符串的按钮的槽函数代码：void Widget::on_btnDec_clicked()
{ //读取十进制数，转换为其他进制
   QString  str=ui->editDec->text();
   int  val=str.toInt();//缺省为十进制
//   str=QString::number(val,16);// 转换为十六进制的字符串
   str=str.setNum(val,16);//十六进制
   str=str.toUpper(); 
   ui->editHex->setText(str);

   str=str.setNum(val,2);  //二进制
//   str=QString::number(val,2);
   ui->editBin->setText(str);
}
将一个整数转换为不同进制的字符串，可以使用QString的函数setNum()或静态函数number()，它们的函数原型是：Qstring   &setNum (int n, int base = 10)
QString   number (int n, int base = 10)
其中n是待转换的整数，base是使用的进制，缺省为十进制，也可以指定为十六进制和二进制。
下面是读取二进制字符串，然后转换为十进制和十六进制显示的按钮的槽函数代码。






void Widget::on_btnBin_clicked()
{ //读取二进制数，转换为其他进制的数
   QString  str=ui->editBin->text(); //读取二进制字符串
   bool ok;
   int val=str.toInt(&ok,2);//以二进制数读入
   str=QString::number(val,10);//数字显示为十进制字符串
   ui->editDec->setText(str);

   str=str.setNum(val,16);//显示为十六进制
   str=str.toUpper(); 
   ui->editHex->setText(str); 
}
4.1.2　QString的常用功能
QString是Qt编程中常用的类，除了用作数字量的输入输出之外，QString还有很多其他功能，熟悉这些常见的功能，有助于灵活地实现字符串处理功能。
QString存储字符串采用的是Unicode码，每一个字符是一个16位的QChar，而不是8位的char，所以QString处理中文字符没有问题，而且一个汉字算作是一个字符。
图4-2是对QString常用函数的测试实例samp4_2的运行界面。下面在说明函数功能时，对于同名不同参数的函数，只说明某种参数下的使用实例。QString还有很多功能函数没有在此介绍，在使用中如果遇到，可查询Qt的帮助文件。
图4-2　QString函数功能测试实例samp4_2
append()和prepend()
append()在字符串的后面添加字符串，prepend()在字符串的前面添加字符串，如：QString str1="卖", str2="拐";
QString str3=str1;
str1.append(str2);    //str1="卖拐"
str3.prepend(str2);   //str3="拐卖"
toUpper()和toLower()
toUpper()将字符串内的字母全部转换为大写形式，toLower()将字母全部转换为小写形式，如：QString str1="Hello, World", str2;
str2=str1.toUpper();   //str2="HELLO,WORLD"
str2=str1.toLower();   //str2="hello, world"







count()、size()和length()
count()、size()和length()都返回字符串的字符个数，这3个函数是相同的，但是要注意，字符串中如果有汉字，一个汉字算一个字符。QString str1="NI好"
N=str1.count()       //N=3
N=str1.size()        //N=3
N=str1.length()      //N=3
trimmed()和simplified()
trimmed()去掉字符串首尾的空格，simplified()不仅去掉首尾的空格，中间连续的空格也用一个空格替换。QString    str1="   Are    you   OK?   ", str2;
str2=str1.trimmed();       //str1="Are    you   OK? "
str2=str1.simplified();    //str1="Are you OK? "
indexOf ()和lastIndexOf ()
indexOf()函数的原型为：int indexOf (const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
其功能是在自身字符串内查找参数字符串str出现的位置，参数from是开始查找的位置，Qt::CaseSensitivity cs参数指定是否区分大小写。
lastIndexOf()函数则是查找某个字符串最后出现的位置。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1.indexOf("5.9");          // N=13
N=str1.lastIndexOf("\\");       //N=21
“\”是转义字符，如果要查找“\”，需要输入“\”。
isNull()和isEmpty()
两个函数都判读字符串是否为空，但是稍有差别。如果一个空字符串，只有“\0”，isNull()返回false，而isEmpty()返回true；只有未赋值的字符串，isNull()才返回true。QString str1, str2="";
N=str1.isNull();   // N=true    未赋值字符串变量
N=str2.isNull();   // N=false   只有"\0"的字符串，也不是Null
N=str1.isEmpty();  // N=true    
N=str2.isEmpty();  // N=true
QString只要赋值，就在字符串的末尾自动加上“\0”，所以，如果只是要判断字符串内容是否为空，常用isEmpty()。
contains()
判断字符串内是否包含某个字符串，可指定是否区分大小写。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1. contains (".cpp", Qt::CaseInsensitive);    // N=true，不区分大小写
N=str1. contains (".CPP", Qt::CaseSensitive);      // N=false，区分大小写
endsWith()和startsWith()
startsWith ()判断是否以某个字符串开头，endsWith()判断是否以某个字符串结束。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1. endsWith(".cpp", Qt::CaseInsensitive);     // N=true，不区分大小写







N=str1. endsWith(".CPP", Qt::CaseSensitive);       // N=false，区分大小写
N=str1. startsWith("g: ");                         // N=true，缺省为不区分大小写
left()和right()
left表示从字符串中取左边多少个字符，right表示从字符串中取右边多少个字符。注意，一个汉字被当作一个字符。QString str2, str1="学生姓名，男，1984-3-4，汉族，山东";
N=str1.indexOf ("，");                             // N=4，第一个"，"出现的位置
str2=str1.left(N);                                 //str2="学生姓名"
N=str1.lastIndexOf ("，");                         // N=18，最后一个逗号的位置
str2=str1.right(str1.size()-N-1); //str2="山东"，提取最后一个逗号之后的字符串
section()
section()函数的原型为：QString section (const QString &sep, int start, int end = -1, SectionFlags flags = SectionDefault) const
其功能是从字符串中提取以sep作为分隔符，从start端到end端的字符串。QString str2, str1="学生姓名，男，1984-3-4，汉族，山东";
str2=str1. section ("，",0,0);                    // str2="学生姓名"，   第1段的编号为0
str2=str1. section ("，",1,1);                    // str2="男"
str2=str1. section ("，",0,1);                    // str2="学生姓名，男"
str2=str1. section ("，",4,4);                    // str2="山东"
4.2　SpinBox的使用
QSpinBox用于整数的显示和输入，一般显示十进制数，也可以显示二进制、十六进制的数，而且可以在显示框中增加前缀或后缀。
QDoubleSpinBox用于浮点数的显示和输入，可以设置显示小数位数，也可以设置显示的前缀和后缀。
实例samp4_3演示QSpinBox和QDoubleSpinBox这两个组件的使用，图4-3是程序运行界面。程序功能与实例samp4_1类似，但是使用QSpinBox和QDoubleSpinBox作为数字输入输出组件。
图4-3　实例samp4_3运行时界面
QSpinBox和QDoubleSpinBox都是QAbstractSpinBox的子类，具有大多数相同的属性，只是参数类型不同。在UI设计器里进行界面设计时，就可以设置这些属性。QSpinBox和QDoubleSpinBox的主要属性见表4-1。
表4-1　QSpinBox和QDoubleSpinBox的主要属性






属性名称
描述
prefix
数字显示的前缀，例如“$”
suffix
数字显示的后缀，例如“kg”
minimum
数值范围的最小值，如0
maximum
数值范围的最大值，如255
singlestep
单击右侧上下调整按钮时的单步改变值，如设置为1，或0.1
value
当前显示的值
displayIntegerBase
QSpinBox特有属性，显示整数使用的进制，例如2就表示二进制
decimals
QDoubleSpinBox特有属性，显示数值的小数位数，例如2就显示两位小数提示　
一个属性在类的接口中一般有一个读取函数和一个设置函数，如QDoubleSpinBox的decimals属性，读取属性值的函数为int decimals()，设置属性值的函数为void setDecimals(int prec)。
图4-3中各个SpinBox的类型及属性设置一目了然，不再赘述。使用QSpinBox和Qdouble SpinBox进行数值量的输入输出很方便，下面是图4-3中“计算”按钮和“十进制”后面的按钮的槽函数代码。void Widget::on_btnCal_clicked()
{ //计算
   int num=ui->spinNum->value();  
   float price=ui->spinPrice->value();
   float total=num*price;
   ui->spinTotal->setValue(total); 
}
void Widget::on_btnBin_clicked()
{ //读取二进制数，以其他进制显示
   int val=ui->spinBin->value();
   ui->spinDec->setValue(val);
   ui->spinHex->setValue(val);
}
在使用QSpinBox和QDoubleSpinBox读取和设置数值时，无需做字符串与数值之间的转换，也无需做进制的转换，其显示效果（前缀、后缀、进制和小数位数）在设置好之后就自动按照效果进行显示，这对于数值的输入输出是非常方便的。
4.3　其他数值输入和显示组件
4.3.1　实例功能
除了LineEdit和SpinBox之外，还有其他一些用于数值输入和显示的组件。实例samp4_4演示如何使用这些组件，图4-4是实例samp4_4的设计界面。






图4-4　实例Samp4_4设计界面
在这个实例中，用到如下一些组件。
QSlider：滑动条，通过滑动来设置数值，可用于数值输入。实例中使用4个滑动条输入红、绿、蓝三色和Alpha值，然后合成颜色，作为一个QTextEdit组件的底色。
QScrollBar：卷滚条，与QSlider功能类似，还可以用于卷滚区域。
QProgressBar：进度条，一般用于显示任务进度，可用于数值的百分比显示。实例程序中滑动一个Slider，获取其值并更新ScrollBar和ProgressBar。
QDial：表盘式数值输入组件，通过转动表针获得输入值。
QLCDNumber：模仿LCD数字的显示组件，可以显示整数或浮点数，显示整数时可以不同进制显示。实例程序中转动表盘，获得的值显示在LCD组件中。单击“LCD显示进制”的RadioButton时，设置LCD的显示进制。
4.3.2　各组件的主要功能和属性
1．QSlider
QSlider、QScrollBar和Qdial 3个组件都从QAbstractSlider继承而来，有一些共有的属性。QSlider是滑动的标尺型组件，滑动标尺上的一个滑块可以改变值。
基类QAbstractSlider的主要属性包括以下几种。
minimum、maximum：设置输入范围的最小值和最大值，例如，用红、绿、蓝配色时，每种基色的大小范围是0~255，所以设置minimum为0，maximum为255。
singleStep：单步长，拖动标尺上的滑块，或按下左/右光标键时的最小变化数值。
pageStep：在Slider上输入焦点，按PgUp或PgDn键时变化的数值。
value：组件的当前值，拖动滑块时自动改变此值，并限定在minimum和maximum定义的范围之内。
sliderPosition：滑块的位置，若tracking属性设置为true，sliderPosition就等于value。
tracking：sliderPosition是否等同于value，如果tracking=true，改变value时也同时改变sliderPosition。
orientation：Slider的方向，可以设置为水平或垂直。方向参数是Qt的枚举类型enum Qt::Orientation，取值包括以下两种。 
Qt::Horizontal 水平方向
Qt::Vertical 垂直方向
invertedAppearance：显示方式是否反向，invertedAppearance=false时，水平的Slider由左向右数值增大，否则反过来。
invertedControls：反向按键控制，若invertedControls=true，则按下PgUp或PgDn按键时调整数值的方向相反。















































































第13章　多线程
一个应用程序一般只有一个线程，一个线程内的操作是顺序执行的，如果有某个比较消耗时间的计算或操作，比如网络通信中的文件传输，在一个线程内操作时，用户界面就可能会冻结而不能及时响应。这种情况下，可以创建一个单独的线程来执行比较消耗时间的操作，并与主线程之间处理好同步与数据交互，这就是多线程应用程序。
Qt为多线程操作提供了完整的支持。QThread是线程类，是实现多线程操作的核心类，一般从QThread继承定义自己的线程类。线程之间的同步是其交互的主要问题，Qt提供了QMutex、QMutexLocker、QReadWriteLock、QwaitCondition、QSemaphore等多种类用于实现线程之间的同步。Qt还有Qt Concurrent模块，提供一些高级的API实现多线程编程而无需使用QMutex、QwaitCondition和QSemaphore等基础操作。使用Qt Concurrent实现的多线程程序可以自动根据处理器内核个数调整线程个数。
本章主要介绍用QThread实现多线程编程的方法，以及用QMutex、QWaitCondition、QSemaphore等实现线程同步的方法。
13.1　QThread创建多线程程序
13.1.1　QThread类功能简介
QThread类提供不依赖于平台的管理线程的方法。一个QThread类的对象管理一个线程，一般从QThread继承一个自定义类，并重定义虚函数run()，在run()函数里实现线程需要完成的任务。
将应用程序的线程称为主线程，额外创建的线程称为工作线程。一般在主线程里创建工作线程，并调用start()开始执行工作线程的任务。start()会在内部调用run()函数，进入工作线程的事件循环，在run()函数里调用exit()或quit()可以结束线程的事件循环，或在主线程里调用terminate()强制结束线程。
QThread类的主要接口函数、信号和槽函数见表13-1。
表13-1　Qthread类的主要接口
类型		函数		功能
公共函数		bool isFinished()		线程是否结束    
                bool isRunning()		线程是否正在运行		
Priority　      priority()              返回线程的优先级
公共函数        void setPriority (Priority priority)       设置线程的优先级
                 void exit(int returnCode = 0)       退出线程的事件循环，退出码为returnCode，0表示成功退出；否则表示有错误
               bool wait(unsigned long time )    阻止线程执行，直到线程结束（从run()函数返回），或等待时间超过time毫秒

公共槽函数     void　quit()              退出线程的事件循环，并返回代码0，等效于exit(0)
               void start(Priority priority ) 内部调用run()开始执行线程，操作系统根据priority参数进行调度
               void terminate()               终止线程的运行，但不是立即结束线程，而是等待操作系统结束线程。使用terminate()之后应使用wait()
信号            void finished()               在线程就要结束时发射此信号
               void started()                 在线程开始执行、run()函数被调用之前发射此信号
静态公共成员   int idealThreadCount()         返回系统上能运行的线程的理想个数
               void msleep(unsigned long msecs)  强制当前线程休眠msecs毫秒
               void sleep(unsigned long secs)    强制当前线程休眠secs秒
               void usleep(unsigned long usecs)   强制当前线程休眠usecs微秒
保护函数       virtual void run()                 start()调用run()函数开始线程任务的执行，所以在run()函数里实现线程的任务功能
               int exec()                        由run()函数调用，进入线程的事件循环，等待exit()退出
QThread是QObject的子类，所以可以使用信号与槽机制。QThread自身定义了started()和finished()两个信号，started()信号在线程开始执行之前发射，也就是在run()函数被调用之前，finished()信号在线程就要结束时发射。
13.1.2　掷骰子的线程QDiceThread
作为实例，定义一个掷骰子的线程类QDiceThread，类的声明部分如下：#include   <Qthread>
class QDiceThread : public Qthread
{
   Q_OBJECT
private:
   int    m_seq=0;          //掷骰子次数序号
   int    m_diceValue;      //骰子点数
   bool   m_Paused=true;    //暂停
   bool   m_stop=false;     //停止
protected:
   void   run() Q_DECL_OVERRIDE;  //线程任务
public:
   QDiceThread();
   void   diceBegin();      //掷一次骰子
   void   dicePause();      //暂停
   void   stopThread();     //结束线程
signals:
   void   newValue(int seq,int diceValue); //产生新点数的信号
};
重载虚函数run()，在此函数里完成线程的主要任务。
自定义diceBegin()、dicePause()、stopThread() 3个公共函数用于线程控制，这3个函数由







主线程调用。
定义了一个信号newValue(int seq,int diceValue) 用于在掷一次骰子得到新的点数之后发射此信号，由主线程的槽函数响应以获取值。
QDiceThread类的实现代码如下：#include   " qdicethread.h"
#include   <QTime>
QDiceThread::QDiceThread()
{//构造函数
}
void QDiceThread::diceBegin()
{ //开始掷骰子
   m_Paused=false;
}
void QDiceThread::dicePause()
{//暂停掷骰子
   m_Paused=true;
}
void QDiceThread::stopThread()
{//停止线程
   m_stop=true;
}
void QDiceThread::run()
{//线程任务
   m_stop=false;//启动线程时令m_stop=false
   m_seq=0; //掷骰子次数
   qsrand(QTime::currentTime().msec());//随机数初始化，qsrand是线程安全的
   while(!m_stop)//循环主体
   {
      if (!m_Paused)
      {
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
         emit newValue(m_seq,m_diceValue);  //发射信号
      }
      msleep(500); //线程休眠500ms
   }
   quit();//相当于exit(0),退出线程的事件循环
}
其中，run()是线程任务的实现部分，线程开始就执行run()函数。run()函数一般是事件循环过程，根据各种条件或事件处理各种任务。当run()函数退出时，线程的事件循环就结束了。
在run()函数里，初始化变量m_stop和m_seq，用qsrand()函数对随机数种子初始化。run()函数的主循环体是一个while循环，在主线程调用stopThread()函数使m_stop为true，才会退出while循环，调用quit()之后结束线程。
在while循环体内，又根据m_Paused判断当前是否需要掷骰子，如果需要掷骰子，则用随机函数生成一次骰子的点数m_diceValue，然后发射信号newValue()，将m_seq和m_diceValue作为信号参数传递出去。主线程可以设计槽函数与此信号关联，获取这两个值并进行显示。
13.1.3　掷骰子的多线程应用程序
使用QDiceThread类，设计一个应用程序samp13_1，程序运行界面如图13-1所示。






图13-1　掷骰子多线程应用程序samp13_1运行界面
窗体上方的几个按钮用于控制线程的启动与停止，控制开始与暂停掷骰子。中间的文本框显示次数和点数，右边根据点数显示资源文件里面的一个图片，图片存储在项目的资源文件里。下方的一个标签根据QDiceThread的started()和finished()两个信号显示线程的状态。
窗口类是从QDialog继承的类Dialog，其类定义如下（省略了按钮槽函数的定义）：class Dialog : public QDialog
{
   Q_OBJECT
private:
   QDiceThread   threadA;
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit Dialog(QWidget *parent = 0);
   ~Dialog();
private slots:
//自定义槽函数
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onthreadA_newValue(int seq, int diceValue);
private:
   Ui::Dialog *ui;
};
这里定义了一个QDiceThread类型的变量threadA，重定义了closeEvent()事件，自定义了3个槽函数。
Dialog类的构造函数代码如下：Dialog::Dialog(QWidget *parent) : QDialog(parent),  ui(new Ui::Dialog)
{//构造函数
   ui->setupUi(this);
   connect(&threadA,SIGNAL(started()),this,SLOT(onthreadA_started()));
   connect(&threadA,SIGNAL(finished()),this,SLOT(onthreadA_finished()));
   connect(&threadA,SIGNAL(newValue(int,int)),
             this,SLOT(onthreadA_newValue(int,int)));
}
构造函数主要是将threadA的3个信号与Dialog自定义的3个槽函数相关联，这3个槽函数的代码如下：void Dialog::onthreadA_started()
{//线程的started()信号的响应槽函数
   ui->LabA->setText("Thread状态：thread started");
}
void Dialog::onthreadA_finished()
{//线程的 finished()信号的响应槽函数
   ui->LabA->setText("Thread状态：thread finished");
}






void Dialog::onthreadA_newValue(int seq,int diceValue)
{//QDiceThread的newValue()信号的响应槽函数，显示骰子次数和点数
   QString  str=QString::asprintf("第 %d 次掷骰子，点数为：%d",seq,diceValue);
   ui->plainTextEdit->appendPlainText(str);
   QPixmap pic; //图片显示
   QString filename=QString::asprintf(":/dice/images/d%d.jpg",diceValue);
   pic.load(filename);
   ui->LabPic->setPixmap(pic);
}
started()信号发射时，表示线程开始执行，在标签里显示状态文字。
finished()信号发射时，表示线程结束执行，在标签里显示状态文字。
newValue()是QDiceThread定义的信号，在掷一次骰子获得新的点数后发射，将掷骰子的次数和点数传递过来。槽函数onthreadA_newValue()获取这两个值并显示在文本框里，再根据点数从资源文件里获取相应的图片并显示。
窗口上5个按钮的代码如下：void Dialog::on_btnStartThread_clicked()
{//启动线程 按钮
   threadA.start();
   ui->btnStartThread->setEnabled(false);
   ui->btnStopThread->setEnabled(true);
   ui->btnDiceBegin->setEnabled(true);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnStopThread_clicked()
{//结束线程 按钮
   threadA.stopThread();//结束线程的run()函数执行
   threadA.wait();
   ui->btnStartThread->setEnabled(true);
   ui->btnStopThread->setEnabled(false);
   ui->btnDiceBegin->setEnabled(false);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnDiceBegin_clicked()
{//开始 掷骰子按钮
   threadA.diceBegin();
   ui->btnDiceBegin->setEnabled(false);
   ui->btnDiceEnd->setEnabled(true);
}
void Dialog::on_btnDiceEnd_clicked()
{//暂停 掷骰子按钮
   threadA.dicePause();
   ui->btnDiceBegin->setEnabled(true);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnClear_clicked()
{ //清空文本 按钮
   ui->plainTextEdit->clear();
}
“启动线程”按钮调用线程的start()函数，start()函数会内部调用run()函数开始线程任务的执行。run()函数将内部变量m_Paused初始化为true，所以，启动线程后并不会立即开始掷骰子。
“开始”按钮调用diceBegin()函数，使threadA线程内部变量m_Paused变为false，那么run()函数里就开始每隔500毫秒产生一次骰子点数，并发射信号newValue()。
“暂停”按钮调用dicePause()函数，使threadA线程内部变量m_Paused变为true，run()函数里不再掷骰子，但是run()函数并没有结束，也就是线程并没有结束。




“结束线程”按钮调用stopThread()函数，使threadA线程内部的m_stop变为true，run()函数体的while循环结束，执行quit()后线程结束。所以，线程结束就是run()函数执行退出。
重载closeEvent()事件，在窗口关闭时确保线程被停止，代码如下：void Dialog::closeEvent(QCloseEvent *event)
{ //窗口关闭事件，必须结束线程
   if (threadA.isRunning())
   {
      threadA.stopThread();
      threadA.wait();
   }
   event->accept();
}
13.2　线程同步
13.2.1　线程同步的概念
在多线程应用程序中，由于多个线程的存在，线程之间可能需要访问同一个变量，或一个线程需要等待另外一个线程完成某个操作后才产生相应的动作。例如，在上一节的实例samp13_1中，工作线程产生随机的骰子点数，主线程读取骰子点数并显示，主线程需要等待工作线程产生一个新的骰子点数后再读取数据。实例samp13_1中使用了信号与槽的机制，在产生新的骰子数之后通过信号通知主线程读取新的数据。
如果不使用信号与槽机制，QDiceThread的run()函数变为如下的代码：void QDiceThread::run()
{
   m_stop=false;//启动线程时令m_stop=false
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化，qsrand是线程安全的
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
      }
      msleep(500); //线程休眠
   }
}
那么，QDiceThread需要定义公共函数，返回m_diceValue的值，如：int QDiceThread::diceValue () { return = m_diceValue;}
以便在主线程中调用此函数读取骰子的点数。
由于没有信号与槽的关联（信号与槽的关系类似于硬件的中断与中断处理函数），主线程只能采用不断查询的方式主动查询是否有新数据，并读取它。但是在主线程调用diceValue()读取骰子点数时，工作线程可能正在执行run()函数里修改m_diceValue值的语句，即：m_diceValue=qrand(); //获取随机数
m_diceValue=(m_diceValue % 6)+1;
m_seq++;
而且这几条语句计算量大，需要执行较长时间。执行这两条语句时不希望被主线程调用的diceValue()函数中断，如果中断，则主线程得到的可能是错误的值。







这种情况下，这样的代码段是希望被保护起来的，在执行过程中不能被其他线程打断，以保证计算结果的完整性，这就是线程同步的概念。
在Qt中，有多个类可以实现线程同步的功能，包括QMutex、QMutexLocker、QReadWriteLock、QReadLocker、QWriteLocker、QWaitCondition和QSemaphore。下面将分别介绍这些类的用法。
13.2.2　基于互斥量的线程同步
QMutex和QMutexLocker是基于互斥量的线程同步类，QMutex定义的实例是一个互斥量，QMutex主要提供3个函数。
lock()：锁定互斥量，如果另外一个线程锁定了这个互斥量，它将阻塞执行直到其他线程解锁这个互斥量。
unlock()：解锁一个互斥量，需要与lock()配对使用。
tryLock()：试图锁定一个互斥量，如果成功锁定就返回true；如果其他线程已经锁定了这个互斥量，就返回false，但不阻塞程序执行。
使用互斥量，对QDiceThread类重新定义，不采用信号与槽机制，而是提供一个函数用于主线程读取数据。更改后的QDiceThread类定义如下：class QDiceThread : public Qthread
{
   Q_OBJECT
private:
   QMutex  mutex; //互斥量
   int    m_seq=0;//序号
   int    m_diceValue;
   bool   m_paused=true;
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QDiceThread();
   void   diceBegin();//掷一次骰子
   void   diceEnd();
   void   stopThread();
   bool   readValue(int *seq, int *diceValue); //用于主线程读取数据的函数
};
QDiceThread类里用QMutex类定义了一个互斥量变量mutex。
定义了函数readValue()，用于外部线程读取掷骰子的次数和点数，传递参数采用指针变量，以便一次读取两个数据。
下面是QDiceThread类中关键的run()和readValue()函数的实现代码。void QDiceThread::run()
{
   m_stop=false;
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         mutex.lock();
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
         mutex.unlock();







    }
      msleep(500); //线程休眠
   }
}
bool QDiceThread::readValue(int *seq, int *diceValue)
{
   if (mutex.tryLock())
   {
      *seq=m_seq;
      *diceValue=m_diceValue;
      mutex.unlock();
      return true;
   }
   else
      return false;
}
在run()函数中，对重新计算骰子点数和掷骰子次数的3行代码用互斥量mutex的lock()和unlock()进行了保护，这部分代码的执行就不会被其他线程中断。注意，lock()与unlock()必须配对使用。
在readValue()函数中，用互斥量mutex的tryLock()和unlock()进行了保护。如果tryLock()成功锁定互斥量，读取数值的两行代码执行时不会被中断，执行完后解锁；如果tryLock()锁定失败，函数就立即返回，而不会等待。
原理上，对于两个或多个线程可能会同时读或写的变量应该使用互斥量进行保护，例如QDiceThread中的变量m_stop和m_paused，在run()函数中读取这两个变量，要在diceBegin()、diceEnd()和stopThread()函数里修改这些值，但是这3个函数都只有一条赋值语句，可以认为是原子操作，所以，可以不用锁定保护。
定义的互斥量mutex相当于一个标牌，可以这样来理解互斥量：列车上的卫生间一次只能进一个人，当一个人尝试进入卫生间就是lock()，如果有人占用，他就只能等待；等里面的人出来，腾出了卫生间是unlock()，这个等待的人才可以进入并且锁住卫生间的门，就是lock()，使用完卫生间之后他再出来时就是unlock()。
QMutex需要配对使用lock()和unlock()来实现代码段的保护，在一些逻辑复杂的代码段或可能发生异常的代码中，配对就可能出错。
QMutexLocker是另外一个简化了互斥量处理的类。QMutexLocker的构造函数接受一个互斥量作为参数并将其锁定，QMutexLocker的析构函数则将此互斥量解锁，所以在QMutexLocker实例变量的生存期内的代码段得到保护，自动进行互斥量的锁定和解锁。例如，QDiceThread的run()函数的代码可以改写如下：void QDiceThread::run()
{
   m_stop=false;
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         QMutexLocker  Locker(&mutex);
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
      }
      msleep(500); //线程休眠
   }
}







这样定义的QDiceThread类，在主程序中只能调用其readValue()函数来不断读取数值。实例samp13_2采用QMutex进行线程同步，实例samp13_3采用QMutex和QMutexLocker进行线程同步，其界面与samp13_1完全相同，只是增加了定时器，用于定时主动去读取掷骰子线程的数值。
实例程序samp13_2的Dialog类的主要定义如下（省略了一些系统生成的声明）：class Dialog : public QDialog
{
private:
   int  mSeq, mDiceValue;
   QDiceThread   threadA;
   QTimer  mTimer;//定时器
public:
   explicit Dialog(QWidget *parent = 0);
private slots:
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onTimeOut(); //定期器处理槽函数
};
主要是增加了一个定时器mTimer和其时间溢出响应槽函数onTimeOut()，在Dialog的构造函数中将mTimer的timeout信号与此槽函数关联。connect(&mTimer,SIGNAL(timeout()),this,SLOT(onTimeOut()));
onTimeOut()函数的主要功能是调用threadA的readValue()函数读取数值。定时器的定时周期设置为100ms，小于threadA产生一次新数据的周期（500ms），所以可能读出旧的数据，通过存储的掷骰子的次数与读取的掷骰子次数是否不同，判断是否为新数据。onTimeOut()函数的代码如下：void Dialog::onTimeOut()
{ //定时器溢出处理槽函数
  int  tmpSeq=0,tmpValue=0;
  bool  valid=threadA.readValue(&tmpSeq,&tmpValue); //读取数值
  if (valid && (tmpSeq!=mSeq)) //有效，并且是新数据
  {
    mSeq=tmpSeq;
    mDiceValue=tmpValue;
    QString  str=QString::asprintf("第 %d 次掷骰子，点数为：%d", mSeq,mDiceValue);
   ui->plainTextEdit->appendPlainText(str);
   QPixmap pic;
   QString filename=QString::asprintf(":/dice/images/d%d.jpg",mDiceValue);
   pic.load(filename);
   ui->LabPic->setPixmap(pic);
  }
}
窗口上几个按钮的代码如下（省略了按钮使能控制的代码）：void Dialog::on_btnStartThread_clicked()
{//启动线程
   mSeq=0;
   threadA.start();
}
void Dialog::on_btnStopThread_clicked()
{//结束线程
   threadA.stopThread();//结束线程的run()函数执行
   threadA.wait();
}
void Dialog::on_btnDiceBegin_clicked()
{//开始掷骰子
   threadA.diceBegin();
   mTimer.start(100); //定时器100ms读取一次数据





}

void Dialog::on_btnDiceEnd_clicked()
{//暂停掷骰子
   threadA.diceEnd(); 
   mTimer.stop();//定时器暂停
}
实例samp13_2和samp13_3实现的效果与实例samp13_1相同，只是实现的方式不同。
13.2.3　基于QReadWriteLock的线程同步
使用互斥量时存在一个问题：每次只能有一个线程获得互斥量的权限。如果在一个程序中有多个线程读取某个变量，使用互斥量时也必须排队。而实际上若只是读取一个变量，是可以让多个线程同时访问的，这样互斥量就会降低程序的性能。
例如，假设有一个数据采集程序，一个线程负责采集数据到缓冲区，一个线程负责读取缓冲区的数据并显示，另一个线程负责读取缓冲区的数据并保存到文件，示意代码如下：int   buffer[100];
QMutex  mutex;
void   threadDAQ::run()
{   ...
   mutex.lock();
   get_data_and_write_in_buffer();   //数据写入buffer
   mutex.unlock();
   ...   
}
void   threadShow::run()
{   ...
   mutex.lock();
   show _buffer();   //读取 buffer里的数据并显示
   mutex.unlock();
   ...   
}
void   threadSaveFile::run()
{   ...
   mutex.lock();
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   mutex.unlock();
   ...  
}
数据缓冲区buffer和互斥量mutex都是全局变量，线程threadDAQ将数据写到buffer，线程threadShow和threadSaveFile只是读取buffer，但是因为使用互斥量，这3个线程任何时候都只能有一个线程可以访问buffer。而实际上，threadShow和threadSaveFile都只是读取buffer的数据，它们同时访问buffer是不会发生冲突的。
Qt提供了QReadWriteLock类，它是基于读或写的模式进行代码段锁定的，在多个线程读写一个共享数据时，可以解决上面所说的互斥量存在的问题。
QReadWriteLock以读或写锁定的同步方法允许以读或写的方式保护一段代码，它可以允许多个线程以只读方式同步访问资源，但是只要有一个线程在以写方式访问资源时，其他线程就必须等待直到写操作结束。
QReadWriteLock提供以下几个主要的函数：
lockForRead()，以只读方式锁定资源，如果有其他线程以写入方式锁定，这个函数会阻塞；
lockForWrite()，以写入方式锁定资源，如果本线程或其他线程以读或写模式锁定资源，这个函数就阻塞；







unlock()，解锁；
tryLockForRead()，是lockForRead()的非阻塞版本；
tryLockForWrite()，是lockForWrite()的非阻塞版本。
使用QReadWriteLock，上面的三线程代码可以改写为如下的形式：int   buffer[100];
QReadWriteLock   Lock;
void   threadDAQ::run()
{   ...
   Lock.lockForWrite();
   get_data_and_write_in_buffer();   //数据写入buffer
   Lock.unlock();
   ...   
}
void   threadShow::run()
{   ...
   Lock.lockForRead();
   show_buffer();   //读取 buffer里的数据并显示
   Lock.unlock();
   ...   
}
void   threadSaveFile::run()
{   ...
   Lock.lockForRead();
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   Lock.unlock();
   ...  
}
这样，如果threadDAQ没有以lockForWrite()锁定Lock，threadShow和threadSaveFile可以同时访问buffer，否则threadShow和threadSaveFile都被阻塞；如果threadShow和threadSaveFile都没有锁定，那么threadDAQ能以写入方式锁定，否则threadDAQ就被阻塞。
QReadLocker和QWriteLocker是QReadWriteLock的简便形式，如同QMutexLocker是QMutex的简便版本一样，无需与unlock()配对使用。使用QReadLocker 和QWriteLocker，则上面的代码改写为：int   buffer[100];
QReadWriteLock   Lock;
void   threadDAQ::run()
{   ...
   QWriteLocker  Locker(&Lock);
   get_data_and_write_in_buffer();   //数据写入buffer
   ...   
}
void   threadShow::run()
{   ...
QReadLocker Locker(&Lock);
   show _buffer();   //读取 buffer里的数据并显示
   ...   
}
void   threadSaveFile::run()
{   ...
QReadLocker Locker(&Lock);
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   ...  
}
13.2.4　基于QWaitCondition的线程同步






在多线程的程序中，多个线程之间的同步实际上就是它们之间的协调问题。例如上一小节讲到的3个线程的例子中，假设threadDAQ写满一个缓冲区之后，threadShow和threadSaveFile才能对缓冲区进行读操作。前面采用的互斥量和基于QReadWriteLock的方法都是对资源的锁定和解锁，避免同时访问资源时发生冲突。在一个线程解锁资源后，不能及时通知其他线程。
QWaitCondition提供了另外一种改进的线程同步方法，QWaitCondition与QMutex结合，可以使一个线程在满足一定条件时通知其他多个线程，使它们及时作出响应，这样比只使用互斥量效率要高一些。例如，threadDAQ在写满一个缓冲区之后，及时通知threadShow和threadSaveFile，使它们可以及时读取缓冲区数据。
QWaitCondition提供如下一些函数：
wait(QMutex *lockedMutex)，解锁互斥量lockedMutex，并阻塞等待唤醒条件，被唤醒后锁定lockedMutex并退出函数；
wakeAll()，唤醒所有处于等待状态的线程，线程唤醒的顺序不确定，由操作系统的调度策略决定；
wakeOne()，唤醒一个处于等待状态的线程，唤醒哪个线程不确定，由操作系统的调度策略决定。
QWaitCondition一般用于“生产者/消费者”（producer/consumer）模型中。“生产备”产生数据，“消费者”使用数据，前述的数据采集、显示与存储的三线程例子就适用这种模型。
创建实例程序samp13_4，将掷骰子的程序修改为producer/consumer模型，一个线程类QThreadProducer专门负责掷骰子产生点数；一个线程类QThreadConsumer专门及时读取数据，并送给主线程进行显示。这两个类定义在一个文件qmythread.h里，定义代码如下：class QThreadProducer : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadProducer();
   void   stopThread();
};

class QThreadConsumer : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadConsumer();
   void   stopThread();
signals:
   void   newValue(int seq,int diceValue);
};
QThreadProducer用于掷骰子，但是去掉了开始和暂停的功能，线程一启动就连续地掷骰子。QThreadConsumer用于读取掷骰子的次数和点数，并用发射信号方式把数据传递出去。这两个类的实现代码在一个文件qmythread.cpp里，下面是这两个类的实现代码的主要部分：QMutex  mutex;
QWaitCondition  newdataAvailable;
int    seq=0;//序号
int    diceValue;
void QthreadProducer::run()
{





  m_stop=false;
   seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      mutex.lock();
      diceValue=qrand(); //获取随机数
      diceValue=(diceValue % 6)+1;
      seq++;
      mutex.unlock();
      newdataAvailable.wakeAll(); //唤醒所有线程，有新数据了
      msleep(500); //线程休眠
   }
}

void QthreadConsumer::run()
{
   m_stop=false;
   while(!m_stop)//循环主体
   {
      mutex.lock();
      newdataAvailable.wait(&mutex);//先解锁mutex，使其他线程可以使用mutex
      emit  newValue(seq,diceValue);
      mutex.unlock();
   }
}
掷骰子的次数和点数的变量定义为共享变量，这样两个线程都可以访问。定义了互斥量mutex，定义了QWaitCondition实例newdataAvailable，表示有新数据可用了。
QThreadProducer::run()函数负责每隔500毫秒掷骰子产生一次数据，新数据产生后通过等待条件唤醒所有等待的线程，即：newdataAvailable.wakeAll();
QThreadConsumer::run()函数中的while循环，首先需要将互斥量锁定，再执行下面的一条语句：newdataAvailable.wait(&mutex);
这条语句以mutex作为输入参数，内部会首先解锁mutex，使其他线程可以使用mutex，newdataAvailable进入等待状态。当QThreadProducer产生新数据使用newdataAvailable.wakeAll()唤醒所有线程后，newdataAvailable.wait(&mutex)会再次锁定mutex，然后退出阻塞状态，以执行后面的语句。
所以，使用QWaitCondition可以使QThreadConsumer线程的执行过程进入等待状态。在QThreadProducer线程满足条件后，唤醒QThreadConsumer线程及时退出等待状态，继续执行后面的程序。
使用QThreadProducer和QThreadConsumer实现掷骰子的实例程序samp13_4运行时界面如图13-2所示，与实例samp13_1的运行界面类似，只是取消了开始和暂停掷骰子的按钮，下方的状态标签显示了两个线程的状态







图13-2　使用QWaitCondition的线程同步实例程序samp13_4运行界面
窗口的Dialog类的定义如下（省略了按钮槽函数等一些不重要的部分）：class Dialog : public QDialog
{   Q_OBJECT
private:
   QthreadProducer   threadProducer;
   QthreadConsumer   threadConsumer;
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit Dialog(QWidget *parent = 0);
private slots:
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onthreadB_started();
   void   onthreadB_finished();
   void   onthreadB_newValue(int seq, int diceValue);
};
这里主要是定义了两个线程的实例，并定义了几个自定义槽函数。采用信号与槽的方式与threadConsumer建立通信并获取数据。Dialog的构造函数主要完成信号与槽函数的关联，5个自定义槽函数的代码与实例samp13_1的相同或相似，这几个函数的代码不再详细列出。
“启动线程”按钮的代码如下：void Dialog::on_btnStartThread_clicked()
{//启动线程
   threadConsumer.start();
   threadProducer.start();
   ui->btnStartThread->setEnabled(false);
   ui->btnStopThread->setEnabled(true);
}
两个线程启动的先后顺序不应调换，应先启动threadConsumer，使其先进入wait状态，后启动threadProducer，这样在threadProducer里wakeAll()时threadConsumer就可以及时响应，否则会丢失第一次掷骰子的数据。
“结束线程”按钮的代码如下：void Dialog::on_btnStopThread_clicked()
{//结束线程
   threadProducer.stopThread();//结束线程的run()函数执行
   threadProducer.wait();
   threadConsumer.terminate(); //可能处于等待状态，用terminate强制结束
   threadConsumer.wait();
   ui->btnStartThread->setEnabled(true);
   ui->btnStopThread->setEnabled(false);
}
结束线程时，若按照上面的顺序先结束threadProducer线程，则必须使用terminate()来强









制结束threadConsumer线程，因为threadConsumer可能还处于条件等待的阻塞状态中，将无法正常结束线程。
13.2.5　基于信号量的线程同步
1．信号量的原理
信号量（Semaphore）是另一种限制对共享资源进行访问的线程同步机制，它与互斥量（Mutex）相似，但是有区别。一个互斥量只能被锁定一次，而信号量可以多次使用。信号量通常用来保护一定数量的相同的资源，如数据采集时的双缓冲区。
QSemaphore是实现信号量功能的类，它提供以下几个基本的函数：
acquire(int n)尝试获得n个资源。如果没有这么多资源，线程将阻塞直到有n个资源可用；
release(int n)释放n个资源，如果信号量的资源已全部可用之后再release()，就可以创建更多的资源，增加可用资源的个数；
int available()返回当前信号量可用的资源个数，这个数永远不可能为负数，如果为0，就说明当前没有资源可用；
bool tryAcquire(int n = 1)，尝试获取n个资源，不成功时不阻塞线程。
定义QSemaphore的实例时，可以传递一个数值作为初始可用的资源个数。
下面的一段示意代码，说明QSemaphore的几个函数的作用。QSemaphore  WC(5);  // WC.available() == 5，初始资源个数为5个
WC.acquire(4);      // WC.available() == 1，用了4个资源，还剩余1个可用
WC.release(2);      // WC.available() == 3，释放了2个资源，剩余3个可用
WC.acquire(3);      // WC.available() == 0，又用了3个资源，剩余0个可用
WC.tryAcquire(1);   //因为WC.available() == 0, 返回 false，
WC.acquire();      //因为WC.available() == 0, 没有资源可用，阻塞
为了理解信号量及上面这段代码的意义，可以假想变量WC是一个公共卫生间，初始化时定义WC有5个位置可用。
WC.acquire(4)，成功进去4个人，占用了4个位置，还剩余1个位置；
WC.release (2)，出来了2个人，剩余3个位置可用；
WC.acquire(3)，又进去3个人，剩余0个位置可用；
WC.tryAcquire(1)，有一个人尝试进去，但是因为没有位置了，他不等待，走了，tryAcquire()函数返回false；
WC.acquire()，有一个人必须进去，但是因为没有位置了，他就一直在外面等着，直到有其他人出来，空余出位置来。
互斥量相当于列车上的卫生间，一次只允许一个人进出，信号量则是多人公共卫生间，允许多人进出。n个资源就是信号量需要保护的共享资源，至于资源如何分配，就是内部处理的问题了。
2．双缓冲区数据采集和读取线程类设计
信号量通常用来保护一定数量的相同的资源，如数据采集时的双缓冲区，适用于Producer/Consumer模型。
在实例samp13_5中，创建类似于Producer/Consumer模型的两个线程类QThreadDAQ和QThreadShow。qmythread.h文件中这两个类的定义如下：class QThreadDAQ : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadDAQ();






void   stopThread();
};

class QThreadShow : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadShow();
   void   stopThread();
signals:
   void   newValue(int *data,int count, int seq);
};
QThreadDAQ是数据采集线程，例如在使用数据采集卡进行连续数据采集时，需要一个单独的线程将采集卡采集的数据读取到缓冲区内。
QThreadShow是数据读取线程，用于读取已存满数据的缓冲区中的数据并传递给主线程显示，采用信号与槽机制与主线程交互。
QThreadDAQ/QThreadShow类的定义与使用QWaitCondition的实例samp13_4中的QThreadProducer/QThreadConsumer类的定义类似，只是QThreadShow的信号newValue()采用了指针作为传递参数，用于一次传递出一个缓冲区的数据。
qmythread.cpp文件中QThreadDAQ和QThreadShow的主要功能代码如下：#include   "qmythread.h"
#include   <QSemaphore>
const int BufferSize = 8;
int buffer1[BufferSize];
int buffer2[BufferSize];
　
int curBuf=1; //当前正在写入的Buffer
int bufNo=0; //采集的缓冲区序号
quint8   counter=0;//数据生成器
　
QSemaphore emptyBufs(2);//信号量，空的缓冲区个数，初始资源个数为2
QSemaphore fullBufs; //满的缓冲区个数，初始资源为0
　
void QThreadDAQ::run()
{
   m_stop=false;//启动线程时令m_stop=false
   bufNo=0;//缓冲区序号
   curBuf=1; //当前写入使用的缓冲区
   counter=0;//数据生成器
   int n=emptyBufs.available();
   if (n<2)  //保证线程启动时emptyBufs.available==2
     emptyBufs.release(2-n);
   while(!m_stop)//循环主体
   {
      emptyBufs.acquire();//获取一个空的缓冲区
      for(int i=0;i<BufferSize;i++) //产生一个缓冲区的数据
      {
         if (curBuf==1)
            buffer1[i]=counter; //向缓冲区写入数据
         else
            buffer2[i]=counter;
         counter++; //模拟数据采集卡产生数据
         msleep(50); //每50ms产生一个数
      }
      bufNo++;//缓冲区序号
      if (curBuf==1) // 切换当前写入缓冲区





curBuf=2;
      else
        curBuf=1;
      fullBufs.release(); //有了一个满的缓冲区,available==1
   }
}
　
void QThreadShow::run()
{
   m_stop=false;
   int n=fullBufs.available();
   if (n>0)
     fullBufs.acquire(n); //将fullBufs可用资源个数初始化为0
   while(!m_stop)//循环主体
   {
      fullBufs.acquire(); //等待有缓冲区满,当fullBufs.available==0阻塞
      int bufferData[BufferSize];
      int seq=bufNo;
　
      if(curBuf==1) //当前在写入的缓冲区是1，那么满的缓冲区是2
         for (int i=0;i<BufferSize;i++)
            bufferData[i]=buffer2[i]; //快速拷贝缓冲区数据
      else
         for (int i=0;i<BufferSize;i++)
            bufferData[i]=buffer1[i];
　
      emptyBufs.release();//释放一个空缓冲区
      emit   newValue(bufferData,BufferSize,seq);//给主线程传递数据
   }
}
在共享变量区定义了两个缓冲区buffer1和buffer2，都是长度为BufferSize的数组。
变量curBuf记录当前写入操作的缓冲区编号，其值只能是1或2，表示buffer1或buffer2，bufNo是累积的缓冲区个数编号，counter是模拟采集数据的变量。
信号量emptyBufs初始资源个数为2，表示有2个空的缓冲区可用。
信号量fullBufs初始化资源个数为0，表示写满数据的缓冲区个数为零。
QThreadDAQ::run()采用双缓冲方式进行模拟数据采集，线程启动时初始化共享变量，特别的是使emptyBufs的可用资源个数初始化为2。
在while循环体里，第一行语句emptyBufs.acquire()使信号量emptyBufs获取一个资源，即获取一个空的缓冲区。用于数据缓存的有两个缓冲区，只要有一个空的缓冲区，就可以向这个缓冲区写入数据。
while循环体里的for循环每隔50毫秒使counter值加1，然后写入当前正在写入的缓冲区，当前写入哪个缓冲区由curBuf决定。counter是模拟采集的数据，连续增加可以判断采集的数据是否连续。
完成for循环后正好写满一个缓冲区，这时改变curBuf的值，切换用于写入的缓冲区。
写满一个缓冲区之后，使用fullBufs.release()为信号量fullBufs释放一个资源，这时fullBufs. available==1，表示有一个缓冲区被写满了。这样，QThreadShow线程里使用fullBufs.acquire()就可以获得一个资源，可以读取已写满的缓冲区里的数据。
QThreadShow::run()用于监测是否有已经写满数据的缓冲区，只要有缓冲区写满了数据，就立刻读取出数据，然后释放这个缓冲区给QThreadDAQ线程用于写入。
QThreadShow::run()函数的初始化部分使fullBufs. available==0，即线程刚启动时是没有资








源的。
在while循环体里第一行语句就是通过fullBufs.acquire()以阻塞方式获取一个资源，只有当QThreadDAQ线程里写满一个缓冲区，执行一次fullBufs.release()后，fullBufs.acquire()才获得资源并执行后面的代码。后面的代码就立即用临时变量将缓冲区里的数据读取出来，再调用emptyBufs.release()给信号量emptyBufs释放一个资源，然后发射信号newValue，由主线程读取数据并显示。
所以，这里使用了双缓冲区、两个信号量实现采集和读取两个线程的协调操作。采集线程里使用emptyBufs.acquire()获取可以写入的缓冲区。
实际使用数据采集卡进行连续数据采集时，采集线程是不能停顿下来的，也就是说万一读取线程执行较慢，采集线程是不会等待的。所以实际情况下，读取线程的操作应该比采集线程快。
3．QThreadDAQ和QThreadShow的使用
设计窗口基于QDialog应用程序samp13_5，对话框的类定义如下（省略了一些不重要的或与前面实例重复的部分内容）：class Dialog : public QDialog
{
   Q_OBJECT
private:
   QThreadDAQ   threadProducer;
   QThreadShow   threadConsumer;
private slots:
   void   onthreadB_newValue(int *data, int count, int bufNo);
};
Dialog类定义了两个线程的实例，threadProducer和threadConsumer。
自定义了一个槽函数onthreadB_newValue()，用于与threadConsumer的信号关联，在Dialog的构造函数里进行了关联。connect(&threadConsumer,SIGNAL(newValue(int*,int,int)),
      this,SLOT(onthreadB_newValue(int*,int,int)));
槽函数onthreadB_newValue()的功能就是读取一个缓冲区里的数据并显示，其实现代码如下：void Dialog::onthreadB_newValue(int *data, int count, int bufNo)
{ //读取threadConsumer 传递的缓冲区的数据
   QString  str=QString::asprintf("第 %d 个缓冲区：",bufNo);
   for (int i=0;i<count;i++)
   {
      str=str+QString::asprintf("%d, ",*data);
      data++;
   }
   str=str+'\n';
   ui->plainTextEdit->appendPlainText(str);
}
传递的指针型参数int *data 是一个数组指针，count是缓冲区长度。
“启动线程”和“结束线程”两个按钮的代码如下（省略了按键使能控制的代码）：void Dialog::on_btnStartThread_clicked()
{//启动线程
   threadConsumer.start();
   threadProducer.start();
}
void Dialog::on_btnStopThread_clicked()
{//结束线程









threadConsumer.terminate(); 
   threadConsumer.wait();
   threadProducer.terminate();
   threadProducer.wait();
}
启动线程时，先启动threadConsumer，再启动threadProducer，否则可能丢失第1个缓冲区的数据。
结束线程时，都采用terminate()函数强制结束线程，因为两个线程之间有互锁的关系，若不使用terminate()强制结束会出现线程无法结束的问题。
程序运行时的界面如图13-3所示。
图13-3　实例samp13_5运行界面
从图13-3可以看出，没有出现丢失缓冲区或数据点的情况，两个线程之间协调的很好，将QThreadDAQ::run()函数中模拟采样率的延时时间调整为2毫秒也没问题（正常设置为50毫秒）。
在实际的数据采集中，要保证不丢失缓冲区或数据点，数据读取线程的速度必须快过数据写入缓冲区的线程的速度。














第14章　网络编程
Qt网络模块提供了用于编写TCP/IP客户端和服务器端程序的各种类，如用于TCP通信的QTcpSocket和QTcpServer，用于UDP通信的QUdpSocket，还有用于实现HTTP、FTP等普通网络协议的高级类如QNetworkRequest，QNetworkReply和QNetworkAccessManager。Qt网络模块还提供用于网络代理、网络承载管理的类，提供基于安全套接字层（Secure Sockets Layer，SSL）协议的安全网络通信的类。
本章主要介绍基本的TCP和UDP网络通信类的使用，基于HTTP的网络下载管理的实现。要在程序中使用Qt网络模块，需要在项目配置文件中增加一条配置语句：Qt  += network
14.1　主机信息查询
14.1.1　QHostInfo和QNetworkInterface类
查询一个主机的MAC地址或IP地址是网络应用程序中经常用到的功能，Qt提供了QHostInfo和QNetworkInterface类可以用于此类信息的查询。
QHostInfo的静态函数localHostName()可获取本机的主机名，静态函数fromName()可以通过主机名获取IP地址，静态函数ookupHost()可以通过一个主机名，以异步方式查找这个主机的IP地址。表14-1是QHostInfo类主要的功能函数（省略了函数中的const关键字）。
表14-1　QHostInfo类的主要函数
类别
函数原型
作用
公共函数
QList<QHostAddress>　addresses()
返回与hostName()主机关联的IP地址列表
HostInfoError　error()
如果主机查找失败，返回失败类型
QString　errorString()
如果主机查找失败，返回错误描述字符串
QString　hostName()
返回通过IP查找的主机的名称
int　lookupId()
返回本次查找的ID
静态函数
void　abortHostLookup(int id)
中断主机查找
QHostInfo　fromName(QString &name)
返回指定的主机名的IP地址
QString　localDomainName()
返回本机DNS域名
QString　localHostName()
返回本机主机名
int　lookupHost(QString &name, QObject receiver, char member)
以异步方式根据主机名查找主机的IP地址，并返回一个表示本次查找的ID，可用于abortHostLookup()



































