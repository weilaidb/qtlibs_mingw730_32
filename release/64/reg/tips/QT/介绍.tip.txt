MOC Meta-Object Compiler,MOC 
Qt的元对象编译器，是一个预处理器，在源程序被编译前先将这些Qt特性的程序转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。这就是为什么在使用信号与槽机制的类里，必须添加 Q_OBJECT 宏的原因，只有添加了这个宏，moc才能对类里的信号与槽的代码进行预处理。

class MainWindow : public QMainWindow
{
    Q_OBJECT


元对象系统由以下三个基础组成。
QObject类是所有使用元对象系统的类的基类。
Q_OBJECT
Q_OBJECT
Q_OBJECT
在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。
MOC（元对象编译器）为每个QObject的子类提供必要的代码来实现元对象系统的特性。
构建项目时，MOC工具读取C++源文件，当它发现类的定义里有Q_OBJECT宏时，它就会为这个类生成另外一个包含有元对象支持代码的C++源文件，这个生成的源文件连同类的实现文件一起被编译和连接。
除了信号与槽机制外，元对象还提供如下一些功能。

QObject::metaObject()函数返回类关联的元对象，元对象类QMetaObject包含了访问元对象的一些接口函数，例如QMetaObject::className()函数可在运行时返回类的名称字符串。

QObject *obj = new QPushButton;
obj->metaObject()->className();    // 返回 "QPushButton"
QMetaObject::newInstance()函数创建类的一个新的实例。
QObject::inherits(const char *className)函数判断一个对象实例是否是名称为className的类或QObject的子类的实例。例如：QTimer *timer = new QTimer;        // QTimer 是QObject的子类
timer->inherits("QTimer");         // 返回 true
timer->inherits("QObject");        // 返回 true
timer->inherits("QAbstractButton");//返回 false，不是QAbstractButton的子类


qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
对于QObject及其子类，还可以使用qobject_cast()函数进行动态投射（dynamic cast）。例如，假设QMyWidget是QWidget的子类并且在类定义中声明了Q_OBJECT宏。创建实例使用下面的语句：QObject *obj = new QMyWidget;
变量obj定义为QObject指针，但它实际指向QMyWidget类，所以可以正确投射为QWidget，即：QWidget *widget = qobject_cast<QWidget *>(obj);
从QObject到QWidget的投射是成功的，因为obj实际是QMyWidget类，是QWidget的子



connect()
connect()
connect()
．connect()函数的不同参数形式
QObject::connect()函数有多重参数形式，一种参数形式的函数原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
使用这种参数形式的connect()进行信号与槽函数的连接时，一般句法如下：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
这里使用了宏SIGNAL()和SLOT()指定信号和槽函数，而且如果信号和槽函数带有参数，还需注明参数类型，如：connect(spinNum, SIGNAL(valueChanged (int)), this, SLOT(updateStatus(int));
另外一种参数形式的connect()函数的原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method, Qt::ConnectionType type = Qt::AutoConnection)
对于具有默认参数的信号与槽（即信号名称是唯一的，没有参数不同而同名的两个信号），可以使用这种函数指针形式进行关联，如：connect(lineEdit, &QLineEdit::textChanged, this, &widget::on_textChanged);
QLineEdit只有一个信号textChanged(QString), 在自定义窗体类widget里定义一个槽函数on_textChanged(QString)，就可以用上面的语句将此信号与槽关联起来，无需出现函数参数。这在信号的参数比较多时更简便一些。
而对于具有不同参数的同名信号就不能采用函数指针的方式进行信号与槽的关联，例如QSpinBox有两个valueChanged()信号，分别是：void QSpinBox::valueChanged(int i)
void QSpinBox::valueChanged(const QString &text)
即使在自定义窗体widget里定义了一个槽函数，如：void onValueChanged(int i);
在使用下面的语句进行关联时，编译会出错。connect(spinNum, &QSpinBox::valueChanged , this, &widget::onValueChanged);
不管是哪种参数形式的connect()函数，最后都有一个参数Qt::ConnectionType type，缺省值为Qt::AutoConnection。枚举类型Qt::ConnectionType表示了信号与槽之间的关联方式，有以下几种取值。
Qt::AutoConnection（缺省值）：如果信号的接收者与发射者在同一个线程，就使用Qt::Direct Connection方式；否则使用Qt::QueuedConnection方式，在信号发射时自动确定关联方式。
Qt::DirectConnection：信号被发射时槽函数立即执行，槽函数与信号在同一个线程。
Qt::QueuedConnection：在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程。
Qt::BlockingQueuedConnection：与Qt::QueuedConnection相似，只是信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一个线程时绝对不能使用这种方式，否则会造成死锁。

















