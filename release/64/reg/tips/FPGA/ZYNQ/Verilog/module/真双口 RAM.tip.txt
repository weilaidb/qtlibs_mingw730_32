4.6.8 真双口 RAM
真双口 RAM 有两套控制线，数据线，允许两个系统对其进行读写操作，代码如下：
module top 
(
 input [7:0] data_a, data_b,
 input [5:0] addr_a, addr_b,
 input wr_a, wr_b,
 input rd_a, rd_b,
 input clk,
`timescale 1 ns/1 ns 
module top_tb() ;
reg [7:0] data_a, data_b ;
reg [5:0] addr_a, addr_b ;
reg wr_a, wr_b ;
reg rd_a, rd_b ; 
reg clk ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 87 / 285
 output reg [7:0] q_a, q_b 
);
reg [7:0] ram[63:0]; //declare ram 
//Port A 
always @ (posedge clk)
begin
 if (wr_a) //write 
 begin
 ram[addr_a] <= data_a;
 q_a <= data_a ;
 end
 if (rd_a) 
//read 
 q_a <= ram[addr_a];
end
//Port B 
always @ (posedge clk)
begin
 if (wr_b) //write 
 begin
 ram[addr_b] <= data_b;
 q_b <= data_b ;
 end
 if (rd_b) 
//read 
 q_b <= ram[addr_b];
end
endmodule
wire [7:0] q_a, q_b ;
initial
begin
 data_a = 0 ;
 data_b = 0 ;
 addr_a = 0 ;
 addr_b = 0 ;
 wr_a = 0 ;
 wr_b = 0 ;
 rd_a = 0 ;
 rd_b = 0 ;
 clk = 0 ;
 #100 wr_a = 1 ;
 #100 rd_b = 1 ;
end
always #10 clk = ~clk ;
always @(posedge clk)
begin
 if (wr_a)
 begin
 data_a <= data_a + 1'b1 ;
 addr_a <= addr_a + 1'b1 ;
 end
 else 
begin
 data_a <= 0 ;
 addr_a <= 0 ;
 end
end
always @(posedge clk)
begin
 if (rd_b)
 begin
 addr_b <= addr_b + 1'b1 ; 
 end
 else addr_b <= 0 ;
end
top 
t0(.data_a(data_a), .data_b(data_b),
 .addr_a(addr_a), .addr_b(addr
_b
),
 .wr_a(wr_a), .wr_b(wr_b),
 .rd_a(rd_a), .rd_b(rd_b),
 .clk(clk), 
 .q_a(q_a), .q_b(q_b)) ;
endmodule
仿真结果如下