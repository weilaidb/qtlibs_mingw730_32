#ifndef QMYTHREAD_H$NL#define QMYTHREAD_H$NL$NL//#include    <QObject>$NL#include    <QThread>$NL$NLclass QThreadProducer : public QThread$NL{$NL    Q_OBJECT$NLprivate:$NL    bool    m_stop=false; //停止线程$NLprotected:$NL    void    run() Q_DECL_OVERRIDE;$NLpublic:$NL    QThreadProducer();$NL    void    stopThread();$NL};$NL$NL$NLclass QThreadConsumer : public QThread$NL{$NL    Q_OBJECT$NLprivate:$NL    bool    m_stop=false; //停止线程$NLprotected:$NL    void    run() Q_DECL_OVERRIDE;$NLpublic:$NL    QThreadConsumer();$NL    void    stopThread();$NLsignals:$NL    void    newValue(int seq,int diceValue);$NL};$NL#endif // QMYTHREAD_H$NL$NL$NL$NL$NL$NL$NL$NL$NL#include    "qmythread.h"$NL#include    <QWaitCondition>$NL#include    <QTime>$NL#include    <QMutex>$NL$NL$NLQMutex  mutex;$NLQWaitCondition  \1;$NL$NLint     seq=0;//序号$NLint     diceValue;$NL$NLQThreadProducer::QThreadProducer()$NL{$NL$NL}$NL$NLvoid QThreadProducer::stopThread()$NL{$NL    QMutexLocker  locker(&mutex);$NL    m_stop=true;$NL}$NL$NLvoid QThreadProducer::run()$NL{$NL    m_stop=false;//启动线程时令m_stop=false$NL    seq=0;$NL    qsrand(QTime::currentTime().msec());//随机数初始化，qsrand是线程安全的$NL$NL    while(!m_stop)//循环主体$NL    {$NL        mutex.lock();$NL        diceValue=qrand(); //获取随机数$NL        diceValue=(diceValue % 6)+1;$NL        seq++;$NL        mutex.unlock();$NL$NL        \1.wakeAll();//唤醒所有线程，有新数据了$NL        msleep(500); //线程休眠100ms$NL    }$NL}$NL$NL$NLvoid QThreadConsumer::run()$NL{$NL    m_stop=false;//启动线程时令m_stop=false$NL    while(!m_stop)//循环主体$NL    {$NL        mutex.lock();$NL        \1.wait(&mutex);//会先解锁mutex，使其他线程可以使用mutex$NL        emit    newValue(seq,diceValue);$NL        mutex.unlock();$NL//        msleep(100); //线程休眠100ms$NL    }$NL$NL}$NL$NLQThreadConsumer::QThreadConsumer()$NL{$NL$NL}$NL$NLvoid QThreadConsumer::stopThread()$NL{$NL    QMutexLocker  locker(&mutex);$NL    m_stop=true;$NL}$NL