#include    <QSemaphore>$NL$NLQSemaphore  \1(5);  // \1.available() == 5，初始资源个数为5个$NL\1.acquire(4);      // \1.available() == 1，用了4个资源，还剩余1个可用$NL\1.release(2);      // \1.available() == 3，释放了2个资源，剩余3个可用$NL\1.acquire(3);      // \1.available() == 0，又用了3个资源，剩余0个可用$NL\1.tryAcquire(1);   //因为WC.available() == 0, 返回 false，$NL\1.acquire();      //因为WC.available() == 0, 没有资源可用，阻塞$NL$NL$NL$NL$NL$NL$NL#ifndef QMYTHREAD_H$NL#define QMYTHREAD_H$NL$NL//#include    <QObject>$NL#include    <QThread>$NL$NLclass QThreadDAQ : public QThread$NL{$NL    Q_OBJECT$NL$NLprivate:$NL    bool    m_stop=false; //停止线程$NLprotected:$NL    void    run() Q_DECL_OVERRIDE;$NLpublic:$NL    QThreadDAQ();$NL    void    stopThread();$NL};$NL$NLclass QThreadShow : public QThread$NL{$NL    Q_OBJECT$NLprivate:$NL    bool    m_stop=false; //停止线程$NLprotected:$NL    void    run() Q_DECL_OVERRIDE;$NLpublic:$NL    QThreadShow();$NL    void    stopThread();$NLsignals:$NL    void    newValue(int *data,int count, int seq);$NL};$NL#endif // QMYTHREAD_H$NL$NL$NL$NL$NL$NL#include    "qmythread.h"$NL#include    <QSemaphore>$NL$NLconst int BufferSize = 8;$NLint buffer1[BufferSize];$NLint buffer2[BufferSize];$NLint curBuf=1; //当前正在写入的Buffer$NL$NLint bufNo=0; //采集的缓冲区序号$NL$NLquint8   counter=0;//数据生成器$NL$NLQSemaphore emptyBufs(2);//信号量：空的缓冲区个数，初始资源个数为2$NLQSemaphore fullBufs; //满的缓冲区个数，初始资源为0$NL$NLQThreadDAQ::QThreadDAQ()$NL{$NL$NL}$NL$NLvoid QThreadDAQ::stopThread()$NL{$NL    m_stop=true;$NL}$NL$NLvoid QThreadDAQ::run()$NL{$NL    m_stop=false;//启动线程时令m_stop=false$NL    bufNo=0;//缓冲区序号$NL    curBuf=1; //当前写入使用的缓冲区$NL    counter=0;//数据生成器$NL$NL    int n=emptyBufs.available();$NL    if (n<2)  //保证 线程启动时emptyBufs.available==2$NL      emptyBufs.release(2-n);$NL$NL    while(!m_stop)//循环主体$NL    {$NL        emptyBufs.acquire();//获取一个空的缓冲区$NL        for(int i=0;i<BufferSize;i++) //产生一个缓冲区的数据$NL        {$NL            if (curBuf==1)$NL                buffer1[i]=counter; //向缓冲区写入数据$NL            else$NL                buffer2[i]=counter;$NL            counter++; //模拟数据采集卡产生数据$NL$NL            msleep(50); //每50ms产生一个数$NL        }$NL$NL        bufNo++;//缓冲区序号$NL        if (curBuf==1) // 切换当前写入缓冲区$NL          curBuf=2;$NL        else$NL          curBuf=1;$NL$NL        fullBufs.release(); //有了一个满的缓冲区,available==1$NL    }$NL    quit();$NL}$NL$NLvoid QThreadShow::run()$NL{$NL    m_stop=false;//启动线程时令m_stop=false$NL$NL    int n=fullBufs.available();$NL    if (n>0)$NL       fullBufs.acquire(n); //将fullBufs可用资源个数初始化为0$NL$NL    while(!m_stop)//循环主体$NL    {$NL        fullBufs.acquire(); //等待有缓冲区满,当fullBufs.available==0阻塞$NL$NL        int bufferData[BufferSize];$NL        int seq=bufNo;$NL$NL        if(curBuf==1) //当前在写入的缓冲区是1，那么满的缓冲区是2$NL            for (int i=0;i<BufferSize;i++)$NL               bufferData[i]=buffer2[i]; //快速拷贝缓冲区数据$NL        else$NL            for (int i=0;i<BufferSize;i++)$NL               bufferData[i]=buffer1[i];$NL$NL        emptyBufs.release();//释放一个空缓冲区$NL        emit    newValue(bufferData,BufferSize,seq);//给主线程传递数据$NL    }$NL    quit();$NL}$NL$NLQThreadShow::QThreadShow()$NL{$NL$NL}$NL$NLvoid QThreadShow::stopThread()$NL{$NL    m_stop=true;$NL}$NL$NL$NL