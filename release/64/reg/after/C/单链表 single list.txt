#include <stdio.h>$NL#include <stdlib.h>$NL$NL$NL$NLtypedef struct \1{$NL    int  elem;$NL    struct \1 *next;$NL}\1;$NL$NL$NL\1 * init\1();$NL//链表插入的函数，p是链表，elem是插入的结点的数据域，add是插入的位置$NL\1 * insertElem(\1 * p,int elem,int add);$NL//删除结点的函数，p代表操作链表，add代表删除节点的位置$NL\1 * delElem(\1 * p,int add);$NL//查找结点的函数，elem为目标结点的数据域的值$NLint selectElem(\1 * p,int elem);$NL//更新结点的函数，newElem为新的数据域的值$NL\1 *amendElem(\1 * p,int add,int newElem);$NLvoid display(\1 *p);$NLint countElem(\1 * p);$NL$NLint main()$NL{$NL    //初始化链表（1，2，3，4）$NL    printf("init list:\n");$NL    \1 *p=init\1();$NL    display(p);$NL$NL    printf(" at 4 's pos insert ele 5:\n");$NL    p=insertElem(p, 5, 4);$NL    display(p);$NL$NL    printf("del ele 3:\n");$NL    p=delElem(p, 3);$NL    display(p);$NL$NL    printf("find ele 2 's pos:\n");$NL    int address=selectElem(p, 2);$NL    if (address==-1) {$NL        printf("no found ele");$NL    }else{$NL        printf("ele 2 's pos:%d\n",address);$NL    }$NL    printf("change @ 3 's pos to 7:\n");$NL    p=amendElem(p, 3, 7);$NL    display(p);$NL    printf("count ele:%d\n", countElem(p));$NL$NL$NL    return 0;$NL}$NL$NL\1 * init\1()$NL{$NL    \1 * p=(\1*)malloc(sizeof(\1));//创建一个头结点$NL    \1 * temp=p;//声明一个指针指向头结点，用于遍历链表$NL$NL    //生成链表$NL    for (int i=1; i<5; i++) {$NL        \1 *a=(\1*)malloc(sizeof(\1));$NL        a->elem=i;$NL        a->next=NULL;$NL        temp->next=a;$NL        temp=temp->next;$NL    }$NL    return p;$NL}$NL$NL\1 * insertElem(\1 * p,int elem,int add)$NL{$NL    \1 * temp=p;//创建临时结点temp$NL$NL    //首先找到要插入位置的上一个结点$NL    for (int i=1; i<add; i++) {$NL        if (temp==NULL) {$NL            printf("插入位置无效\n");$NL            return p;$NL        }$NL        temp=temp->next;$NL    }$NL    //创建插入结点c$NL    \1 * c=(\1*)malloc(sizeof(\1));$NL    c->elem=elem;$NL    //向链表中插入结点$NL    c->next=temp->next;$NL    temp->next=c;$NL    return  p;$NL}$NL$NL\1 * delElem(\1 * p,int add)$NL{$NL    \1 * temp=p;$NL$NL    //遍历到被删除结点的上一个结点$NL    for (int i=1; i<add; i++) {$NL        temp=temp->next;$NL    }$NL    \1 * del=temp->next;//单独设置一个指针指向被删除结点，以防丢失$NL    temp->next=temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域$NL    free(del);//手动释放该结点，防止内存泄漏$NL    return p;$NL}$NL$NLint selectElem(\1 * p,int elem)$NL{$NL    \1 * t=p;$NL    int i=1;$NL$NL    while (t->next) {$NL        t=t->next;$NL        if (t->elem==elem) {$NL            return i;$NL        }$NL        i++;$NL    }$NL    return -1;$NL}$NL$NLint countElem(\1 * p)$NL{$NL    \1 * t=p;$NL    int i = 0;$NL$NL    while (t->next) {$NL        t=t->next;$NL        i++;$NL    }$NL    return i;$NL}$NL$NL\1 *amendElem(\1 * p,int add,int newElem)$NL{$NL    \1 * temp=p;$NL    temp=temp->next;//tamp指向首元结点$NL$NL    //temp指向被删除结点$NL    for (int i=1; i<add; i++) {$NL        temp=temp->next;$NL    }$NL    temp->elem=newElem;$NL    return p;$NL}$NL$NLvoid display(\1 *p)$NL{$NL    \1* temp=p;//将temp指针重新指向头结点$NL$NL    //只要temp指针指向的结点的next不是Null，就执行输出语句。$NL    while (temp->next) {$NL        temp=temp->next;$NL        printf("%d",temp->elem);$NL    }$NL    printf("\n");$NL}$NL