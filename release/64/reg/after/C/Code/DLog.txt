/***************************************************************************$NL** 版权所有:  WeiLai Copyright (c) 2020-2030  ******************************$NL** 文件名称:  dlog.h$NL** 当前版本:  v1.0$NL** 作    者:$NL** 完成日期: $DATEX$NL** 修改记录:$NL** 修改记录:$NL** 修改日期:$NL** 版本号  :$NL** 修改人  :$NL** 修改内容:$NL***************************************************************************/$NL#ifndef DLOG_H$NL#define DLOG_H$NL$NL/*****************************头文件****************************************/$NL#include <stdio.h>$NL#include <stdlib.h>$NL#include <unistd.h>$NL#include <string.h>$NL#include <stdarg.h>$NL#include <pthread.h>$NL$NLusing namespace std;$NL$NL/* 存储内容最大值 */$NL#define DLOG_MODNAME_MAX       (64)  /* MOD字符最大数量 */$NL#define DLOG_KEY_MAX           (64)  /* KEY字符最大数量 */$NL#define DLOG_CHAR_CONTENT_MAX  (256) /* 保存字符最大数量 */$NL#define DLOG_UCHAR_CONTENT_MAX (256) /* 保存BYTE流最大数量 */$NL#define DLOG_SETS_MAX          (512) /* 至多比较条数 */$NL$NL$NL/**$NL  模块名称及索引$NL*/$NLenum{$NL    DLOG_MOD_TEST1,$NL    DLOG_MOD_TEST2,$NL    DLOG_MOD_MSGID,$NL$NL    DLOG_MOD_MAX, /* MOD模块最大数量 */$NL};$NL$NL#define DLOGMODNAME(A) #A$NL$NL#ifndef DLOGPRINTF$NL#define DLOGPRINTF(fmt,...) \$NLdo{ \$NL    if(1)\$NL    {\$NL        printf("[%-40s:%-3d]" fmt , __FUNCTION__ , __LINE__  ,##__VA_ARGS__);\$NL    }\$NL}while(0)$NL#endif$NL$NL$NL$NL/*****************************宏定义****************************************/$NL#ifndef ARRAYSIZE$NL#define ARRAYSIZE(A) ((unsigned int)(sizeof(A)/sizeof(A[0])))$NL#endif$NL$NL#ifndef MAX$NL#define MAX(a,b) ((a)>(b)?(a):(b))$NL#endif$NL$NL#ifndef MIN$NL#define MIN(a,b) ((a)<(b)?(a):(b))$NL#endif$NL$NL/*****************************结构体或类型定义*******************************/$NLtypedef struct T_DLogNode {$NL    char m_Key[DLOG_KEY_MAX];//key$NL    char m_Buf[DLOG_CHAR_CONTENT_MAX];//content$NL    unsigned char m_uacStream[DLOG_UCHAR_CONTENT_MAX];//stream data$NL    unsigned char m_SW;//switch 1:forced log, 0:auto judge$NL    unsigned char m_Used;//is used, 1:used,0:no use$NL    unsigned char m_Pad;//$NL    unsigned short m_SameCnt;//same cnt record$NL    unsigned short m_wLen;//buffer length$NL}T_DLogNode, *P_DLogNode;$NL$NL$NLtypedef struct T_DLogMod{$NL    unsigned char m_ucIndex;  /* 模块索引 */$NL    unsigned char m_ucUsed;   /* 是否被使用 */$NL    T_DLogNode m_Sets[DLOG_SETS_MAX]; /* 支持数量 */$NL    char m_ModName[DLOG_MODNAME_MAX]; /* 模块名 */$NL    pthread_mutex_t m_Mutex; /* 锁 */$NL}T_DLogMod, *P_DLogMod ;$NL$NL$NL/*****************************全局变量****************************************/$NL$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NL$NL$NL/*****************************函数或类实现****************************************/$NL$NL$NL$NL$NL$NL$NL$NL$NL/*****************************by extern "C"****************************************/$NL/*****************************头文件****************************************/$NL$NL$NL/*****************************宏定义****************************************/$NL$NL$NL#ifdef __cplusplus$NLextern "C" {$NL#endif$NL$NL/*****************************结构体或类型定义*******************************/$NL$NL$NL/*****************************全局变量****************************************/$NL$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NLvoid dLogInit();$NLP_DLogMod dLogInitByMod(const char *pModeName,unsigned char ucIndex);$NLP_DLogMod findDLogModByIndex(unsigned char ucIndex);$NLint dLog(unsigned char ucModIndex, const char *pTips, const unsigned char *pMsg, unsigned short wLen, const char *fmt, ...);$NLint dLogFormatKey(char *acBuf, unsigned char uacLen, const char *fmt, ...);$NLunsigned char isSameBuf(const char *pBufOrg, char *pBufNew, unsigned short wCmpLen$NL                        , P_DLogNode pNode, const unsigned char *pMsg, unsigned short wLen);$NLP_DLogNode findNodeByKey(unsigned char ucModIndex, const char *pKey, unsigned short wLen);$NLint diagDLogSetSw(unsigned char ucModIndex, const char *pKey, unsigned char ucSw);$NLint diagDLogShow(unsigned char ucModIndex, unsigned char ucFlag);$NL/*****************************函数或类实现****************************************/$NL$NL$NL#ifdef __cplusplus$NL}$NL#endif$NL$NL$NL$NL$NL$NL#endif /* DLOG_H */$NL$NL$NL/***************************************************************************$NL** 版权所有:  WeiLai Copyright (c) 2020-2030  ******************************$NL** 文件名称:  dlog.cpp$NL** 当前版本:  v1.0$NL** 作    者:$NL** 完成日期: 2021-06-24_232105$NL** 修改记录:$NL** 修改记录:$NL** 修改日期:$NL** 版本号  :$NL** 修改人  :$NL** 修改内容:$NL***************************************************************************/$NL$NL$NL/*****************************头文件****************************************/$NL#include "dlog.h"$NL#include "pubsw.h"$NL$NL/*****************************宏定义****************************************/$NL$NL/*****************************结构体或类型定义*******************************/$NL$NL$NL/*****************************全局变量****************************************/$NL$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NL$NL$NL/*****************************函数或类实现****************************************/$NL$NL$NL$NL$NL$NL$NL$NL$NL/*****************************by extern "C"****************************************/$NL/*****************************头文件****************************************/$NL$NL$NL/*****************************宏定义****************************************/$NL$NL$NL#ifdef __cplusplus$NLextern "C" {$NL#endif$NL$NL/*****************************结构体或类型定义*******************************/$NL$NL$NL/*****************************全局变量****************************************/$NLT_DLogMod g_tDLogMod[DLOG_MOD_MAX] = {0};$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NL$NL$NL/*****************************函数或类实现****************************************/$NLvoid dLogInit()$NL{$NL    memset(&g_tDLogMod, 0, sizeof(g_tDLogMod));$NL    dLogInitByMod(DLOGMODNAME(DLOG_MOD_TEST1), DLOG_MOD_TEST1);$NL    dLogInitByMod(DLOGMODNAME(DLOG_MOD_TEST2), DLOG_MOD_TEST2);$NL    dLogInitByMod(DLOGMODNAME(DLOG_MOD_MSGID), DLOG_MOD_MSGID);$NL}$NL$NL//初始化模块$NLP_DLogMod dLogInitByMod(const char *pModeName,unsigned char ucIndex)$NL{$NL    if(NULL == pModeName)$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return NULL;$NL    }$NL$NL    P_DLogMod pMod = NULL;$NL    unsigned int dwLp = 0;$NL    for(dwLp = 0;dwLp < DLOG_MOD_MAX;dwLp++)$NL    {$NL        pMod = &g_tDLogMod[dwLp];$NL        if(0 == pMod->m_ucUsed)$NL        {$NL            break;$NL        }$NL$NL        if(isSameBuf(pModeName, pMod->m_ModName, DLOG_MODNAME_MAX, NULL, NULL, 0) > 0)$NL        {$NL            return pMod;$NL        }$NL    }$NL$NL    if(dwLp >= DLOG_MOD_MAX)$NL    {$NL        DLOGPRINTF("module out of range\n");$NL        return NULL;$NL    }$NL$NL    memset(pMod, 0, sizeof(*pMod));$NL    memcpy(pMod->m_ModName, pModeName, MIN(strlen(pModeName), DLOG_MODNAME_MAX));$NL//    pMod->m_Mutex = PTHREAD_MUTEX_INITIALIZER;$NL    pMod->m_ucUsed = 1;$NL    pMod->m_ucIndex = ucIndex;$NL$NL    return pMod;$NL}$NL$NL$NL//根据索引查找模块$NLP_DLogMod findDLogModByIndex(unsigned char ucIndex)$NL{$NL    P_DLogMod pMod = NULL;$NL    if(ucIndex >= DLOG_MOD_MAX)$NL    {$NL        DLOGPRINTF("module num out of range! index:%u(max:%d)\n", ucIndex, DLOG_MOD_MAX);$NL        return NULL;$NL    }$NL$NL    unsigned int dwLp = 0;$NL    for(dwLp = 0;dwLp < DLOG_MOD_MAX;dwLp++)$NL    {$NL        pMod = &g_tDLogMod[dwLp];$NL        if(ucIndex == pMod->m_ucIndex)$NL        {$NL            return pMod;$NL        }$NL    }$NL$NL    DLOGPRINTF("module cannot find, please check or init!! index:%u(max:%d)\n", ucIndex, DLOG_MOD_MAX);$NL    return NULL;$NL}$NL$NLint dLog(unsigned char ucModIndex, const char *pTips, const unsigned char *pMsg, unsigned short wLen, const char *fmt, ...)$NL{$NL    unsigned int dwVal = 0;$NL    P_DLogNode pNode = findNodeByKey(ucModIndex, pTips, DLOG_KEY_MAX);$NL    if(NULL == pNode)$NL    {$NL        DLOGPRINTF("dLog Key out of range!! modIndex:%u\n", ucModIndex);$NL        if(ucModIndex < 30)$NL        {$NL            dwVal = pubGetDrvSw(INDEX_DRVSW_DLOG_OVER_RANGE);$NL            dwVal |= (1U << ucModIndex);$NL            pubSetDrvSw(INDEX_DRVSW_DLOG_OVER_RANGE, dwVal);$NL        }$NL        return 0;$NL    }$NL$NL    char buffer[DLOG_CHAR_CONTENT_MAX] = {0};$NL    va_list argptr;$NL    int cnt;$NL$NL    va_start(argptr, fmt);$NL    cnt = vsnprintf(buffer, sizeof(buffer), fmt, argptr);$NL    va_end(argptr);$NL    if(cnt < 0)$NL    {$NL        return 0;$NL    }$NL$NL    if(pNode->m_SW > 0)$NL    {$NL        DLOGPRINTF("[%s]m_SW:%u, forced logged\n", pNode->m_Key, pNode->m_SW);$NL        return 0;$NL    }$NL$NL    if(true == isSameBuf(pNode->m_Buf, buffer, DLOG_CHAR_CONTENT_MAX, pNode, pMsg, wLen))$NL    {$NL        pNode->m_SameCnt++;$NL        pNode->m_wLen = wLen;$NL        DLOGPRINTF("[%s]buffer same cnt:%u\n", pNode->m_Key, pNode->m_SameCnt);$NL        return 0x01;$NL    }$NL$NL    DLOGPRINTF("[%s]buffer differ old:%s,new:%s\n", pNode->m_Key, pNode->m_Buf, buffer);$NL    memcpy(pNode->m_Buf, buffer, DLOG_CHAR_CONTENT_MAX);$NL    if((NULL != pMsg) && (0 != wLen))$NL    {$NL        memcpy(pNode->m_uacStream, pMsg, MIN(DLOG_UCHAR_CONTENT_MAX, wLen));$NL        pNode->m_wLen = wLen;$NL    }$NL$NL    return 0x0;$NL}$NL$NLint dLogFormatKey(char *acBuf, unsigned char uacLen, const char *fmt, ...)$NL{$NL    if(NULL == acBuf)$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return -1;$NL    }$NL$NL    memset(acBuf,0,uacLen);$NL    va_list argptr;$NL    int cnt;$NL$NL    va_start(argptr, fmt);$NL    cnt = vsnprintf(acBuf, uacLen, fmt, argptr);$NL    va_end(argptr);$NL    if(cnt < 0)$NL    {$NL        return -1;$NL    }$NL$NL    return 0x0;$NL}$NL$NLunsigned char isSameBuf(const char *pBufOrg, char *pBufNew, unsigned short wCmpLen$NL                        , P_DLogNode pNode, const unsigned char *pMsg, unsigned short wLen)$NL{$NL    unsigned char bRet = false;$NL    if((NULL == pBufOrg) || (NULL == pBufNew) || (NULL == pNode))$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return false;$NL    }$NL$NL    if((NULL != pMsg) && (0 != wLen))$NL    {$NL        bRet = (0 == memcmp(pBufOrg, pBufNew, wCmpLen))$NL                && (0 == memcmp(pNode->m_uacStream, pMsg, MIN(DLOG_UCHAR_CONTENT_MAX, wLen)))$NL                && (pNode->m_wLen == wLen);$NL        return bRet;$NL    }$NL    else$NL    {$NL        bRet = (0 == memcmp(pBufOrg, pBufNew, wCmpLen));$NL    }$NL$NL    return bRet;$NL}$NL$NLP_DLogNode findNodeByKey(unsigned char ucModIndex, const char *pKey, unsigned short wLen)$NL{$NL    P_DLogMod pMod = NULL;$NL    pMod = findDLogModByIndex(ucModIndex);$NL    if(NULL == pMod)$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return 0;$NL    }$NL$NL    unsigned int dwLp = 0;$NL    for(dwLp = 0;dwLp < DLOG_SETS_MAX;dwLp++)$NL    {$NL        P_DLogNode pNode = &pMod->m_Sets[dwLp];$NL        if(0 == pNode->m_Used)$NL        {$NL            memcpy(pNode->m_Key, pKey, wLen);$NL            pNode->m_Used = 1;$NL            return pNode;$NL        }$NL$NL        if(0 == memcmp(pKey, pNode->m_Key, ARRAYSIZE(pNode->m_Key)))$NL        {$NL            return pNode;$NL        }$NL    }$NL$NL    return NULL;$NL}$NL$NLint diagDLogSetSw(unsigned char ucModIndex, const char *pKey, unsigned char ucSw)$NL{$NL    P_DLogMod pMod = NULL;$NL    pMod = findDLogModByIndex(ucModIndex);$NL    if(NULL == pMod)$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return 0;$NL    }$NL$NL    unsigned int dwLp = 0;$NL    char buf[DLOG_KEY_MAX] = {0};$NL    memcpy(buf, pKey, MIN(strlen(pKey), DLOG_KEY_MAX));$NL$NL    for(dwLp = 0;dwLp < DLOG_SETS_MAX;dwLp++)$NL    {$NL        P_DLogNode pNode = &pMod->m_Sets[dwLp];$NL        if(0 == pNode->m_Used)$NL        {$NL            break;$NL        }$NL$NL        if(0 == memcmp(buf, pNode->m_Key, DLOG_KEY_MAX))$NL        {$NL            pNode->m_SW = ucSw;$NL            break;$NL        }$NL    }$NL$NL    return 0;$NL}$NL$NL$NLint diagDLogShow(unsigned char ucModIndex, unsigned char ucFlag)$NL{$NL    P_DLogMod pMod = NULL;$NL    pMod = findDLogModByIndex(ucModIndex);$NL    if(NULL == pMod)$NL    {$NL        DLOGPRINTF("null pointer\n");$NL        return -1;$NL    }$NL$NL    unsigned int dwLp = 0;$NL    unsigned int dwLp2 = 0;$NL$NL    printf("Module:%s[Idx:%u], out of range Flag:%u[1>>Idx is 1, out of range]\n", pMod->m_ModName, pMod->m_ucIndex, pubGetDrvSw(INDEX_DRVSW_DLOG_OVER_RANGE));$NL    printf("%-4s%-61s%-8s%-3s\n", "No", "Key", "SameCnt", "Sw");$NL    for(dwLp = 0;dwLp < DLOG_SETS_MAX;dwLp++)$NL    {$NL        P_DLogNode pNode = &pMod->m_Sets[dwLp];$NL        if(0 == pNode->m_Used)$NL        {$NL            break;$NL        }$NL$NL        printf("%-4u%-61s%-8u%-3u\n", dwLp+1, pNode->m_Key, pNode->m_SameCnt, pNode->m_SW);$NL        //print buf$NL        if(ucFlag & 0x1)$NL        {$NL            printf("  buf|-- %s\n",pNode->m_Buf);$NL        }$NL$NL        if(ucFlag & 0x2)$NL        {$NL            if(pNode->m_wLen >= DLOG_UCHAR_CONTENT_MAX)$NL            {$NL                printf("  buf[%u out of range:%d]\n",pNode->m_wLen, DLOG_UCHAR_CONTENT_MAX);$NL            }$NL            else$NL            {$NL                printf("  buf[%u]\n", pNode->m_wLen);$NL            }$NL        }$NL        //print unsigned buf$NL        if((ucFlag & 0x4) && (pNode->m_wLen > 0))$NL        {$NL            if(pNode->m_wLen >= DLOG_UCHAR_CONTENT_MAX)$NL            {$NL                printf("  ubuf[%u out of range:%d]\n",pNode->m_wLen, DLOG_UCHAR_CONTENT_MAX);$NL            }$NL            else$NL            {$NL                printf("  ubuf[%u]\n", pNode->m_wLen);$NL            }$NL$NL            for(dwLp2 = 0;dwLp2 < pNode->m_wLen; dwLp2++)$NL            {$NL                printf("%02x\n", pNode->m_uacStream[dwLp2]);$NL            }$NL            printf("\n");$NL            printf("\n");$NL        }$NL    }$NL$NL    return 0;$NL}$NL$NL#ifdef __cplusplus$NL}$NL#endif$NL$NL$NL$NL$NL$NL$NL$NL$NL$NL$NL#ifndef PUBSW_H$NL#define PUBSW_H$NL$NLenum{$NL    INDEX_DRVSW_DLOG_OVER_RANGE,$NL    INDEX_MAX,$NL};$NL$NL$NL//$NLtypedef struct T_DrvSw$NL{$NL    unsigned int m_Data[INDEX_MAX];$NL}T_DrvSw, *P_DrvSw;$NL$NL$NL#ifdef __cplusplus$NLextern "C" {$NL#endif$NL$NLunsigned int pubGetDrvSw (unsigned int dwIndex);$NLunsigned int pubSetDrvSw (unsigned int dwIndex, unsigned int _val);$NLint pubShowDrvSw();$NL$NL#ifdef __cplusplus$NL}$NL#endif$NL$NL$NL$NL$NL#endif // PUBSW_H$NL$NL$NL$NL#include <stdio.h>$NL#include <stdlib.h>$NL#include <unistd.h>$NL#include <string.h>$NL#include "pubsw.h"$NL$NL$NL$NL//declare variables$NLT_DrvSw g_DrvSw = {0};$NL$NL$NL$NL#ifdef __cplusplus$NLextern "C" {$NL#endif$NL$NLunsigned int pubGetDrvSw (unsigned int dwIndex)$NL{$NL    if(dwIndex > INDEX_MAX - 1)$NL    {$NL        return 0;$NL    }$NL$NL    return g_DrvSw.m_Data[dwIndex] ;$NL}$NL$NLunsigned int pubSetDrvSw (unsigned int dwIndex, unsigned int _val)$NL{$NL    if(dwIndex > INDEX_MAX - 1)$NL    {$NL        return 0;$NL    }$NL$NL    g_DrvSw.m_Data[dwIndex]  = _val;$NL    return g_DrvSw.m_Data[dwIndex] ;$NL}$NL$NLint pubShowDrvSw()$NL{$NL#ifndef ARRAYSIZE$NL#define ARRAYSIZE(A) ((unsigned int)(sizeof(A)/sizeof(A[0])))$NL#endif$NL$NL$NL    unsigned int  dwLp =  0;$NL    for(dwLp = 0;dwLp < ARRAYSIZE(g_DrvSw.m_Data);dwLp++)$NL    {$NL        printf("No:%-3u -- %-3u\n", dwLp+1, g_DrvSw.m_Data[dwLp]);$NL$NL    }$NL$NL    return 0;$NL}$NL$NL$NL#ifdef __cplusplus$NL}$NL#endif$NL