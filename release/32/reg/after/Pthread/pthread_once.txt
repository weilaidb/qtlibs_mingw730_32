基本原理$NLLinux Threads 使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control则表征是否执行过。如果 once_control的初值不是PTHREAD_ONCE_INIT（Linux Threads定义为0），pthread_once()的行为就会不正常。在Linux Threads中，实际”一次性函数”的执行状态有三种：NEVER（0）、IN_PROGRESS（1）、DONE（2），如果 once初值设为1，则由于所有pthread_once()都必须等待其中一个激发”已执行一次”信号，因此所有pthread_once()都会陷入永久的等待中；如果设为2，则表示该函数已执行过一次，从而所有pthread_once()都会立即返回0。$NL$NL#include <semaphore.h>$NL#include <sys/types.h>$NL#include <dirent.h>$NL#include <pthread.h>$NL#include <errno.h>$NL#include <signal.h>$NL#include <time.h>$NL$NLpthread_once_t \1 = PTHREAD_ONCE_INIT;$NL$NLvoid once_run(void)$NL{$NL    printf("once_run in thread %u\n", pthread_self());$NL}$NL$NLvoid* task1(void* arg)$NL{$NL    int tid = pthread_self();$NL    printf("thread1 enter %u\n", tid);$NL    pthread_once(&\1, once_run);$NL    printf("thread1 returns %u\n", tid);$NL$NL    return NULL;$NL}$NL$NLvoid* task2(void* arg)$NL{$NL    int tid = pthread_self();$NL    printf("thread2 enter %u\n", tid);$NL    pthread_once(&\1, once_run);$NL    printf("thread2 returns %u\n", tid);$NL$NL    return NULL;$NL}$NL$NLint main(int argc, char *argv[])$NL{$NL    pthread_t thrd1, thrd2;$NL$NL    pthread_create(&thrd1, NULL, (void*)task1, NULL);$NL    pthread_create(&thrd2, NULL, (void*)task2, NULL);$NL$NL    sleep(5);$NL    printf("Main thread exit...\n");$NL$NL    return 0;$NL}