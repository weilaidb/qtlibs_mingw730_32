/***************************************************************************$NL** 版权所有:  WeiLai Copyright (c) 2020-2030  ******************************$NL** 文件名称:  test.c$NL** 当前版本:  v1.0$NL** 作    者:$NL** 完成日期: 2021-03-08_232343$NL** 修改记录:$NL** 修改记录:$NL** 修改日期:$NL** 版本号  :$NL** 修改人  :$NL** 修改内容:$NL***************************************************************************/$NL$NL$NL/*****************************头文件****************************************/$NL#include<stdio.h>$NL#include<stdlib.h>$NL#include<string.h>$NL$NL$NL/*****************************宏定义****************************************/$NL$NL/*****************************结构体或类型定义*******************************/$NLstruct \1Node$NL{$NL    int a;				//数据域$NL    struct \1Node* next;	//指针域(指向节点的指针）$NL};$NL$NL/*****************************全局变量****************************************/$NLstruct \1Node* g_\1Head= NULL;$NLstruct \1Node* g_\1End = NULL;$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NL$NL$NL/*****************************函数或类实现****************************************/$NL$NLvoid \1AddListTill(int a )$NL{$NL    //创建一个节点$NL    struct \1Node* temp=(struct \1Node*)malloc(sizeof(struct \1Node));		//此处注意强制类型转换$NL$NL    //节点数据进行赋值$NL    temp->a=a;$NL    temp->next=NULL;$NL$NL    //连接分两种情况1.一个节点都没有2.已经有节点了，添加到尾巴上$NL    if(NULL==g_\1Head)$NL    {$NL$NL        g_\1Head=temp;$NL    }$NL    else$NL    {$NL        g_\1End->next=temp;$NL    }$NL    g_\1End=temp;			//尾结点应该始终指向最后一个$NL}$NL$NL$NLvoid \1PrintNode(struct \1Node *temp)$NL{$NL    (void)temp;$NL//    printf("temp:%d\n",temp->a);$NL}$NL$NLvoid \1ScanList()$NL{$NL    struct \1Node *temp =g_\1Head;		//定义一个临时变量来指向头$NL    while (temp !=NULL)$NL    {$NL        \1PrintNode(temp);$NL        temp = temp->next;		//temp指向下一个的地址 即实现++操作$NL    }$NL$NL}$NL$NLstruct \1Node* \1FindNode(int a )$NL{$NL    struct \1Node *temp =g_\1Head;$NL    while(temp !=NULL)$NL    {$NL        if(a == temp->a)$NL        {$NL            return temp;$NL        }$NL        temp = temp->next;$NL    }$NL    //没找到$NL    return NULL;$NL}$NL$NLvoid \1FreeList()$NL{$NL    //一个一个NULL$NL    struct \1Node *temp =g_\1Head;		//定义一个临时变量来指向头$NL    while (temp !=NULL)$NL    {$NL        \1PrintNode(temp);$NL        struct \1Node* pt =temp;$NL        temp = temp->next;		//temp指向下一个的地址 即实现++操作$NL        free(pt);					//释放当前$NL    }$NL    //头尾清空	不然下次的头就接着0x10$NL    g_\1Head = NULL;$NL    g_\1End  = NULL;$NL}$NL$NLvoid \1AddListRand(int index,int a)$NL{$NL    if (NULL==g_\1Head)$NL    {$NL        //printf("链表没有节点\n");$NL        printf("list empty!!!\n");$NL        return;$NL    }$NL    $NL    struct \1Node* pt =\1FindNode(index);$NL    if(NULL==pt)    //没有此节点$NL    {$NL        //printf("没有指定节点\n");$NL        printf("please input node!!!\n");$NL        return;$NL    }$NL    //有此节点$NL    //创建临时节点，申请内存$NL    struct \1Node* temp =(struct \1Node *)malloc(sizeof(struct \1Node));$NL    //节点成员进行赋值$NL    temp->a=a;$NL    temp->next=NULL;$NL    //连接到链表上 1.找到的节点在尾部 2.找到的节点在中间$NL    if (pt == g_\1End)$NL    {$NL        //尾巴的下一个指向新插入的节点$NL        g_\1End->next=temp;$NL        //新的尾巴$NL        g_\1End=temp;$NL    }else$NL    {$NL        // 先连后面 （先将要插入的节点指针指向原来找到节点的下一个）$NL        temp->next=pt->next;$NL        //后连前面$NL        pt->next=temp;$NL    }$NL$NL}$NL$NLvoid \1DeleteListTail()$NL{$NL    if (NULL == g_\1End)$NL    {$NL        //printf("链表为空，无需删除\n");$NL        printf("list empty!!!\n");$NL        return;$NL    }$NL    //链表不为空$NL    //链表有一个节点$NL    if (g_\1Head==g_\1End)$NL    {$NL        free(g_\1Head);$NL        g_\1Head=NULL;$NL        g_\1End=NULL;$NL    }$NL    else$NL    {$NL        //找到尾巴前一个节点$NL        struct \1Node* temp =g_\1Head;$NL        while (temp->next!=g_\1End)$NL        {$NL            temp = temp->next;$NL        }$NL        //找到了，删尾巴$NL        //释放尾巴$NL        free(g_\1End);$NL        //尾巴迁移$NL        g_\1End=temp;$NL        //尾巴指针为NULL$NL        g_\1End->next=NULL;$NL    }$NL$NL}$NL$NLvoid \1DeleteListg_\1Head()$NL{	//记住旧头$NL    struct \1Node* temp=g_\1Head;$NL    //链表检测$NL    if (NULL==g_\1Head)$NL    {$NL        //printf("链表为空\n");$NL        printf("list empty!!!\n");$NL        return;$NL    }$NL$NL    g_\1Head=g_\1Head->next;//头的第二个节点变成新的头$NL    free(temp);$NL$NL}$NL$NLvoid \1DeleteListRand(int a)$NL{$NL$NL    //链表判断 是不是没有东西$NL    if(NULL==g_\1Head)$NL    {$NL        //printf("链表没东西\n");$NL        printf("list empty!!!\n");$NL        return;$NL    }$NL    //链表有东西，找这个节点$NL    struct \1Node* temp =\1FindNode(a);$NL    if(NULL==temp)$NL    {$NL        //printf("查无此点\n");$NL        printf("no found node!!!\n");$NL        return;$NL    }$NL    //找到了,且只有一个节点$NL    if(g_\1Head==g_\1End)$NL    {$NL        free(g_\1Head);$NL        g_\1Head=NULL;$NL        g_\1End=NULL;$NL    }$NL    else if(g_\1Head->next==g_\1End) //有两个节点$NL    {$NL        //看是删除头还是删除尾$NL        if(g_\1End==temp)$NL        {	\1DeleteListTail(); }$NL        else if(temp==g_\1Head)$NL        {	\1DeleteListg_\1Head(); }$NL    }$NL    else//多个节点$NL    {$NL        //看是删除头还是删除尾$NL        if(g_\1End==temp)$NL            \1DeleteListTail();$NL        else if(temp==g_\1Head)$NL            \1DeleteListg_\1Head();$NL        else	//删除中间某个节点$NL        {	//找要删除temp前一个，遍历$NL            struct \1Node*pt =g_\1Head;$NL            while(pt->next!=temp)$NL            {$NL                pt=pt->next;$NL            }$NL            //找到了$NL            //让前一个直接连接后一个 跳过指定的即可$NL            pt->next=temp->next;$NL            free(temp);$NL$NL        }$NL    }$NL$NL$NL}$NL$NLint main ()$NL{$NL    int i;$NL    //struct \1Node *pFind ;$NL    //创建5个节点$NL    for(i=0;i<6;i++)$NL        \1AddListTill(i);$NL$NL    //	\1AddListRand(4,14);		//在指定位置4增加节点14$NL    //	\1DeleteListTail();		//删除一个尾结点$NL    \1DeleteListRand(4);		//删除4节点$NL    \1ScanList();				//便利输出链表$NL    \1FreeList();				//删除链表$NL    /*	pFind = \1Find\1Node(5);	//查找5节点$NL$NL    if (pFind !=  NULL)$NL    {$NL        printf("找到%d\n",pFind->a);	//找到节点并且输出该节点数据$NL    }$NL    else$NL    {$NL        printf("No Find!\n");$NL    }$NL$NL*/$NL    return 0;$NL}$NL$NL/*****************************by extern "C"****************************************/$NL/*****************************头文件****************************************/$NL$NL$NL/*****************************宏定义****************************************/$NL$NL$NL#ifdef __cplusplus$NLextern "C" {$NL#endif$NL$NL/*****************************结构体或类型定义*******************************/$NL$NL$NL/*****************************全局变量****************************************/$NL$NL$NL/*****************************本地变量****************************************/$NL$NL$NL/*****************************函数或类声明****************************************/$NL$NL$NL/*****************************函数或类实现****************************************/$NL$NL$NL#ifdef __cplusplus$NL}$NL#endif$NL$NL$NL$NL$NL$NL$NL$NL