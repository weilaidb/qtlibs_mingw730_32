ZYNQ 开发平台 FPGA 教程
AX7010
 2021.1.7 09:08:57
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 2 / 285
版权声明
Copyright © 2012-2020 芯驿电子科技（上海）有限公司
公司网址:
Http://www.alinx.com.cn
技术论坛：
http://www.heijin.org
官方旗舰店：
http://alinx.jd.com
邮箱:
avic@alinx.com.cn
电话: 
021-67676997
传真：
021-37737073
ALINX 微信公众号：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 3 / 285
文档修订记录:
版本 时间 描述
1.01 2020/2/17 初始版本，基于 FPGA 教程 2017 版 v1.02
1.02 2020/3/4 Vivado 仿真添加说明
1.03 2020/3/17 添加 AD9238 一章
1.04 2021/1/7 修改 7 寸屏说明
我们承诺本教程并非一劳永逸，固守不变的文档。我们会根据论坛上大家的反馈意见，以
及实际的开发实践经验积累不断的修正和优化教程。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 4 / 285
序
首先感谢大家购买芯驿电子科技（上海）有限公司出品的 ZYNQ 的开发板 AX7010、
AX7020！ 您对我们和我们产品的支持和信任,给我们增添了永往直前的信心和勇气。
有人要问零基础能不能学习 ZYNQ？那要看这个零在哪里，如果连原理图都看不懂，C 语
言里数组是什么都不知道，对指针完全没有概念，这是负基础，学习 ZYNQ 要有基本的硬件
知识，熟练的 C 语言功底。
本教程为 FPGA 部分教程，通过不断练习，掌握 FPGA 开发的基本流程，虽然没有讲解很
多大道理，但是熟能生巧，多多练习，逐渐掌握其中的奥秘。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 5 / 285
目录
版权声明.........................................................................................................................................2 序.....................................................................................................................................................4
目录.................................................................................................................................................5
第一章 ZYNQ 简介.......................................................................................................................11
PS 和 PL 互联技术...........................................................................................................11
ZYNQ 芯片开发流程的简介 ...........................................................................................17
学习 ZYNQ 要具备哪些技能.........................................................................................18
1.3.1 软件开发人员.....................................................................................................18
1.3.2 逻辑开发人员.....................................................................................................19
第二章 Vivado 开发环境.............................................................................................................21
Vivado 软件介绍 .............................................................................................................21
Vivado 软件版本 .............................................................................................................21
Vivado 软件 Windows 下安装........................................................................................22
重新安装驱动................................................................................................................28
第三章 开发板硬件介绍 .............................................................................................................29
简介................................................................................................................................29
结构尺寸........................................................................................................................31
电源................................................................................................................................32
ZYNQ7000........................................................................................................................34
3.4.1 JTAG 接口..............................................................................................................36
3.4.2 FPGA 供电系统.....................................................................................................37
3.4.3 ZYNQ 启动配置....................................................................................................38
时钟配置........................................................................................................................38
3.5.1 5.1 PS 系统时钟源 ...............................................................................................38
3.5.2 5.2 PL 系统时钟源................................................................................................39
PS 端的外设 ....................................................................................................................40
3.6.1 6.1 QSPI Flash .......................................................................................................40
3.6.2 6.2 DDR3 DRAM....................................................................................................41
3.6.3 6.3 千兆以太网接口 ...........................................................................................45
3.6.4 6.4 USB2.0.............................................................................................................46
3.6.5 6.5 USB 转串口.....................................................................................................48
3.6.6 6.6 SD 卡槽...........................................................................................................49
3.6.7 6.7 PS PMOD 连接器............................................................................................51
3.6.8 6.8 用户 LED.........................................................................................................52
3.6.9 6.9 用户按键.......................................................................................................52
PL 端的外设.....................................................................................................................53
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 6 / 285
3.7.1 7.1 HDMI 接口.....................................................................................................53
3.7.2 7.2 EEPROM 24LC04 .............................................................................................55
3.7.3 7.3 实时时钟 DS1302.........................................................................................56
3.7.4 7.4 扩展口 J10.....................................................................................................57
3.7.5 7.5 扩展口 J11.....................................................................................................59
3.7.6 7.6 用户 LED........................................................................................................61
3.7.7 7.7 用户按键.......................................................................................................62
第四章 Verilog 基础模块介绍.....................................................................................................64
简介................................................................................................................................64
数据类型........................................................................................................................64
4.2.1 常量.....................................................................................................................64
变量................................................................................................................................65
1.1.1 Wire 型..................................................................................................................65
1.1.2 Reg 型 ..................................................................................................................65
1.1.3 Memory 型 ...........................................................................................................66
运算符............................................................................................................................66
4.4.1 算术运算符.........................................................................................................66
4.4.2 赋值运算符.........................................................................................................66
4.4.3 关系运算符.........................................................................................................68
4.4.4 逻辑运算符.........................................................................................................68
4.4.5 条件运算符.........................................................................................................68
4.4.6 位运算符.............................................................................................................68
4.4.7 移位运算符.........................................................................................................68
4.4.8 拼接运算符.........................................................................................................68
4.4.9 优先级别.............................................................................................................68
组合逻辑........................................................................................................................69
4.5.1 与门.....................................................................................................................69
4.5.2 或门.....................................................................................................................70
4.5.3 非门.....................................................................................................................71
4.5.4 异或.....................................................................................................................71
4.5.5 比较器.................................................................................................................72
4.5.6 半加器.................................................................................................................73
4.5.7 全加器.................................................................................................................74
4.5.8 乘法器.................................................................................................................75
4.5.9 数据选择器.........................................................................................................75
4.5.10 3-8 译码器..........................................................................................................77
4.5.11 三态门...............................................................................................................78
时序逻辑........................................................................................................................79
4.6.1 D 触发器...............................................................................................................80
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 7 / 285
4.6.2 两级 D 触发器.....................................................................................................80
4.6.3 带异步复位的 D 触发器.....................................................................................81
4.6.4 带异步复位同步清零的 D 触发器.....................................................................83
4.6.5 移位寄存器.........................................................................................................84
4.6.6 单口 RAM ............................................................................................................85
4.6.7 伪双口 RAM ........................................................................................................85
4.6.8 真双口 RAM ........................................................................................................86
4.6.9 单口 ROM............................................................................................................88
4.6.10 有限状态机.......................................................................................................89
总结................................................................................................................................93
第五章 PL 的"Hello World"LED 实验 ..........................................................................................94
LED 硬件介绍..................................................................................................................94
创建 Vivado 工程...........................................................................................................95
创建 Verilog HDL 文件点亮 LED ..................................................................................100
添加管脚约束..............................................................................................................105
添加时序约束..............................................................................................................108
生成 BIT 文件...............................................................................................................111
Vivado 仿真...................................................................................................................112
下载..............................................................................................................................118
在线调试......................................................................................................................119
5.9.1 添加 ILA IP 核....................................................................................................119
5.9.2 MARK DEBUG......................................................................................................123
实验总结....................................................................................................................126
第六章 Vivado 下 PLL 实验........................................................................................................127
实验原理......................................................................................................................127
创建 Vivado 工程.........................................................................................................128
仿真..............................................................................................................................134
板上验证......................................................................................................................134
第七章 FPGA 片内 RAM 读写测试实验....................................................................................136
实验原理......................................................................................................................136
创建 Vivado 工程.........................................................................................................136
RAM 的端口定义和时序 ..............................................................................................139
测试程序编写..............................................................................................................140
仿真..............................................................................................................................142
板上验证......................................................................................................................143
第八章 FPGA 片内 ROM 读写测试实验 ...................................................................................144
实验原理......................................................................................................................144
程序设计......................................................................................................................144
8.2.1 创建 ROM 初始化文件.....................................................................................144
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 8 / 285
8.2.2 添加 ROM IP 核.................................................................................................145
ROM 测试程序编写......................................................................................................148
仿真..............................................................................................................................149
板上验证......................................................................................................................149
第九章 FPGA 片内 FIFO 读写测试实验 ....................................................................................150
实验原理......................................................................................................................150
创建 Vivado 工程.........................................................................................................151
9.2.1 添加 FIFO IP 核..................................................................................................151
9.2.2 FIFO 的端口定义与时序....................................................................................153
FIFO 测试程序编写.......................................................................................................155
仿真..............................................................................................................................160
板上验证......................................................................................................................161
第十章 Vivado 下按键实验.......................................................................................................163
按键硬件电路............................................................................................................163
程序设计....................................................................................................................163
创建 Vivado 工程.......................................................................................................164
板上验证....................................................................................................................166
第十一章 按键消抖实验 ...........................................................................................................167
实验原理....................................................................................................................167
程序设计....................................................................................................................167
仿真............................................................................................................................170
实验现象....................................................................................................................171
第十二章 PWM 呼吸灯实验 .....................................................................................................172
实验原理....................................................................................................................172
实验设计....................................................................................................................172
下载验证....................................................................................................................176
第十三章 I2C 接口 EEPROM 实验.............................................................................................177
实验原理....................................................................................................................177
I2C 总线协议和时序...................................................................................................177
程序设计....................................................................................................................179
实验现象....................................................................................................................184
第十四章 RS232 实验................................................................................................................185
模块介绍....................................................................................................................185
14.1.1 模块参数说明.................................................................................................186
14.1.2 模块功能说明.................................................................................................186
程序设计....................................................................................................................187
14.2.1 异步串口通信协议 .........................................................................................187
14.2.2 波特率.............................................................................................................187
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 9 / 285
14.2.3 接收模块设计.................................................................................................188
14.2.4 发送模块设计.................................................................................................189
14.2.5 波特率的产生.................................................................................................190
14.2.6 测试程序.........................................................................................................190
仿真............................................................................................................................192
实验测试....................................................................................................................193
第十五章 RS422 实验................................................................................................................196
程序设计....................................................................................................................196
实验测试....................................................................................................................197
第十六章 RS485 实验................................................................................................................200
实验原理....................................................................................................................200
程序设计....................................................................................................................201
实验测试....................................................................................................................202
第十七章 HDMI 输出实验.........................................................................................................205
硬件介绍....................................................................................................................205
17.1.1 TMDS 原理........................................................................................................205
17.1.2 视频时序标准.................................................................................................207
Vivado 工程建立.........................................................................................................209
17.2.1 添加 HDMI 编码器 IP 核................................................................................210
17.2.2 添加像素时钟 PLL 模块..................................................................................215
17.2.3 添加彩条发生模块 .........................................................................................216
17.2.4 添加顶层模块.................................................................................................217
添加 XDC 约束文件....................................................................................................217
下载调试....................................................................................................................218
实验总结....................................................................................................................219
第十八章 HDMI 字符显示实验.................................................................................................220
实验原理....................................................................................................................220
程序设计....................................................................................................................220
实验现象....................................................................................................................226
第十九章 HDMI 时钟显示实验.................................................................................................228
实验原理....................................................................................................................228
硬件介绍....................................................................................................................228
DS1302 的时序和控制................................................................................................228
19.3.1 写数据时序.....................................................................................................228
19.3.2 读数据时序.....................................................................................................229
19.3.3 命令格式和寄存器 .........................................................................................229
程序设计....................................................................................................................230
19.4.1 DS1302 读写设计.............................................................................................230
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 10 / 285
19.4.2 字符叠加设计.................................................................................................234
实验现象....................................................................................................................237
第二十章 7 寸液晶屏显示实验 ................................................................................................239
硬件介绍....................................................................................................................239
程序设计....................................................................................................................241
实验现象....................................................................................................................242
第二十一章 AD7606 多通道波形显示实验..............................................................................244
实验原理....................................................................................................................245
21.1.1 AD7606 时序 ....................................................................................................245
21.1.2 AD7606 配置 ....................................................................................................246
21.1.3 AD7606 AD 转换...............................................................................................247
程序设计....................................................................................................................247
实验现象....................................................................................................................253
第二十二章 AD9238 双通道波形显示实验..............................................................................254
硬件介绍....................................................................................................................254
22.1.1 两通道 AD 模块说明 ......................................................................................254
22.1.2 模块功能说明.................................................................................................255
程序设计....................................................................................................................257
实验现象....................................................................................................................261
第二十三章 ADDA 测试实验.....................................................................................................263
硬件介绍....................................................................................................................263
23.1.1 数模转换（DA）电路 ....................................................................................264
23.1.2 模数转换（AD）电路....................................................................................265
程序设计....................................................................................................................266
实验现象....................................................................................................................271
第二十四章 AD9767 双通道正弦波产生实验..........................................................................274
硬件介绍....................................................................................................................274
24.1.1 AN9767 模块的参数说明 ................................................................................275
24.1.2 AN9767 模块的原理框图 ................................................................................275
24.1.3 AD9767 芯片简介 ............................................................................................276
24.1.4 电流电压转换及放大 .....................................................................................277
24.1.5 电流电压转换及放大 .....................................................................................278
程序设计....................................................................................................................278
24.2.1 生成 ROM 初始化文件...................................................................................279
24.2.2 双通道正弦波发生程序 .................................................................................281
实验现象....................................................................................................................282
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 11 / 285
第一章 ZYNQ 简介
Zynq 系列的亮点在于 FPGA 里包含了完整的 ARM 处理子系统（PS），每一颗 Zynq 系列的
处理器都包含了 Cortex-A9 处理器，整个处理器的搭建都以处理器为中心， 而且处理器子系统
中集成了内存控制器和大量的外设， 使 Cortex-A9 的核在 Zynq-7000 中完全独立于可编程逻辑
单元，也就是说如果暂时没有用到可编程逻辑单元部分（PL）， ARM 处理器的子系统也可以独
立工作，这与以前的 FPGA 有本质区别，其是以处理器为中心的。
Zynq 就是两大功能块，PS 部分和 PL 部分， 说白了，就是 ARM 的 SOC 部分，和 FPGA
部分。其中，PS 集成了两个 ARM Cortex™-A9 处理器，AMBA®互连，内部存储器，外部存储器
接口和外设。这些外设主要包括 USB 总线接口，以太网接口，SD/SDIO 接口，I2C 总线接口，
CAN 总线接口，UART 接口，GPIO 等。
ZYNQ 芯片的总体框图
PS: 处理系统 （Processing System) , 就是与 FPGA 无关的 ARM 的 SOC 的部分。
PL: 可编程逻辑 (Progarmmable Logic), 就是 FPGA 部分。
PL 部分是与 7 系列一样的，在 DS190 文档中可以看到对应的 7 系列产品。
PS 和 PL 互联技术
ZYNQ 作为首款将高性能 ARM Cortex-A9 系列处理器与高性能 FPGA 在单芯片内紧密结合的
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 12 / 285
产品，为了实现 ARM 处理器和 FPGA 之间的高速通信和数据交互，发挥 ARM 处理器和 FPGA
的性能优势，需要设计高效的片内高性能处理器与 FPGA 之间的互联通路。因此，如何设计高
效的 PL 和 PS 数据交互通路是 ZYNQ 芯片设计的重中之重，也是产品设计的成败关键之一。本
节，我们就将主要介绍 PS 和 PL 的连接，让用户了解 PS 和 PL 之间连接的技术。
其实，在具体设计中我们往往不需要在连接这个地方做太多工作，我们加入 IP 核以后，
系统会自动使用 AXI 接口将我们的 IP 核与处理器连接起来，我们只需要再做一点补充就可以
了。
AXI 全称 Advanced eXtensible Interface，是 Xilinx 从 6 系列的 FPGA 开始引入的一个接口协
议，主要描述了主设备和从设备之间的数据传输方式。在 ZYNQ 中继续使用，版本是 AXI4，所
以我们经常会看到 AXI4.0，ZYNQ 内部设备都有 AXI 接口。其实 AXI 就是 ARM 公司提出的
AMBA（Advanced Microcontroller Bus Architecture）的一个部分，是一种高性能、高带宽、低延
迟的片内总线，也用来替代以前的 AHB 和 APB 总线。第一个版本的 AXI（AXI3）包含在 2003
年发布的 AMBA3.0 中，AXI 的第二个版本 AXI（AXI4）包含在 2010 年发布的 AMBA 4.0 之中。
AXI 协议主要描述了主设备和从设备之间的数据传输方式，主设备和从设备之间通过握手
信号建立连接。当从设备准备好接收数据时，会发出 READY 信号。当主设备的数据准备好
时，会发出和维持 VALID 信号，表示数据有效。数据只有在 VALID 和 READY 信号都有效的时候
才开始传输。当这两个信号持续保持有效，主设备会继续传输下一个数据。主设备可以撤销
VALID 信号，或者从设备撤销 READY 信号终止传输。AXI 的协议如图，T2 时，从设备的 READY
信号有效，T3 时主设备的 VILID 信号有效，数据传输开始。
AXI 握手时序图
在 ZYNQ 中，支持 AXI-Lite，AXI4 和 AXI-Stream 三种总线，通过表 5-1,我们可以看到这三中
AXI 接口的特性。
接口协议 特性 应用场合
AXI4-Lite 地址/单数据传输 低速外设或控制
AXI4 地址/突发数据传输 地址的批量传输
AXI4-Stream 仅传输数据，突发
传输
数据流和媒体流传输
AXI4-Lite：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 13 / 285
具有轻量级，结构简单的特点，适合小批量数据、简单控制场合。不支持批量传输，读写
时一次只能读写一个字（32bit）。主要用于访问一些低速外设和外设的控制。
AXI4：
接口和 AXI-Lite 差不多，只是增加了一项功能就是批量传输，可以连续对一片地址进行一
次性读写。也就是说具有数据读写的 burst 功能。
上面两种均采用内存映射控制方式，即 ARM 将用户自定义 IP 编入某一地址进行访问，读
写时就像在读写自己的片内 RAM，编程也很方便，开发难度较低。代价就是资源占用过多，
需要额外的读地址线、写地址线、读数据线、写数据线、写应答线这些信号线。
AXI4-Stream：
这是一种连续流接口，不需要地址线（很像 FIFO，一直读或一直写就行）。对于这类 IP，
ARM 不能通过上面的内存映射方式控制（FIFO 根本没有地址的概念），必须有一个转换装置，
例如 AXI-DMA 模块来实现内存映射到流式接口的转换。AXI-Stream 适用的场合有很多：视频流
处理；通信协议转换；数字信号处理；无线通信等。其本质都是针对数值流构建的数据通路，
从信源（例如 ARM 内存、DMA、无线接收前端等）到信宿（例如 HDMI 显示器、高速 AD 音频
输出，等）构建起连续的数据流。这种接口适合做实时信号处理。
AXI4 和 AXI4-Lite 接口包含 5 个不同的通道：
 Read Address Channel
 Write Address Channel
 Read Data Channel
 Write Data Channel
 Write Response Channel
其中每个通道都是一个独立的 AXI 握手协议。下面两个图分别显示了读和写的模型：
AXI 读数据通道
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 14 / 285
AXI 写数据通道
在 ZYNQ 芯片内部用硬件实现了 AXI 总线协议，包括 9 个物理接口，分别为 AXI-GP0~AXI￾GP3，AXI-HP0~AXI-HP3，AXI-ACP 接口。
AXI_ACP 接口，是 ARM 多核架构下定义的一种接口，中文翻译为加速器一致性端口，用
来管理 DMA 之类的不带缓存的 AXI 外设，PS 端是 Slave 接口。
AXI_HP 接口，是高性能/带宽的 AXI3.0 标准的接口，总共有四个，PL 模块作为主设备连
接。主要用于 PL 访问 PS 上的存储器（DDR 和 On-Chip RAM）
AXI_GP 接口，是通用的 AXI 接口，总共有四个，包括两个 32 位主设备接口和两个 32 位
从设备接口。
可以看到，只有两个 AXI-GP 是 Master Port，即主机接口，其余 7 个口都是 Slave Port（从
机接口）。主机接口具有发起读写的权限，ARM 可以利用两个 AXI-GP 主机接口主动访问 PL 逻
辑，其实就是把 PL 映射到某个地址，读写 PL 寄存器如同在读写自己的存储器。其余从机接口
就属于被动接口，接受来自 PL 的读写，逆来顺受。
另外这 9 个 AXI 接口性能也是不同的。GP 接口是 32 位的低性能接口，理论带宽
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 15 / 285
600MB/s，而 HP 和 ACP 接口为 64 位高性能接口，理论带宽 1200MB/s。有人会问，为什么高
性能接口不做成主机接口呢？这样可以由 ARM 发起高速数据传输。答案是高性能接口根本不
需要 ARM CPU 来负责数据搬移，真正的搬运工是位于 PL 中的 DMA 控制器。
位于 PS 端的 ARM 直接有硬件支持 AXI 接口，而 PL 则需要使用逻辑实现相应的 AXI 协议。
Xilinx 在 Vivado 开发环境里提供现成 IP 如 AXI-DMA，AXI-GPIO，AXI-Dataover, AXI-Stream 都实现
了相应的接口，使用时直接从 Vivado 的 IP 列表中添加即可实现相应的功能。下图为 Vivado 下
的各种 DMA IP：
下面为几个常用的 AXI 接口 IP 的功能介绍：
AXI-DMA：实现从 PS 内存到 PL 高速传输高速通道 AXI-HP<---->AXI-Stream 的转换
AXI-FIFO-MM2S：实现从 PS 内存到 PL 通用传输通道 AXI-GP<----->AXI-Stream 的转换
AXI-Datamover：实现从 PS 内存到 PL 高速传输高速通道 AXI-HP<---->AXI-Stream 的转换，只
不过这次是完全由 PL 控制的，PS 是完全被动的。
AXI-VDMA：实现从 PS 内存到 PL 高速传输高速通道 AXI-HP<---->AXI-Stream 的转换，只不
过是专门针对视频、图像等二维数据的。
AXI-CDMA：这个是由 PL 完成的将数据从内存的一个位置搬移到另一个位置，无需 CPU 来
插手。
关于如何使用这些 IP，我们会在后面的章节中举例讲到。有时，用户需要开发自己定义的
IP 同 PS 进行通信，这时可以利用向导生成对应的 IP。用户自定义 IP 核可以拥有 AXI4-Lite，
AXI4，AXI-Stream，PLB 和 FSL 这些接口。后两种由于 ARM 这一端不支持，所以不用。
有了上面的这些官方 IP 和向导生成的自定义 IP，用户其实不需要对 AXI 时序了解太多（除
非确实遇到问题），因为 Xilinx 已经将和 AXI 时序有关的细节都封装起来，用户只需要关注自己
的逻辑实现即可。
AXI 协议严格的讲是一个点对点的主从接口协议，当多个外设需要互相交互数据时，我们
需要加入一个 AXI Interconnect 模块，也就是 AXI 互联矩阵，作用是提供将一个或多个 AXI 主设
备连接到一个或多个 AXI 从设备的一种交换机制（有点类似于交换机里面的交换矩阵）。
这个 AXI Interconnect IP 核最多可以支持 16 个主设备、16 个从设备，如果需要更多的接
口，可以多加入几个 IP 核。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 16 / 285
AXI Interconnect 基本连接模式有以下几种：
 N-to-1 Interconnect 
 to-N Interconnect 
 N-to-M Interconnect (Crossbar Mode) 
 N-to-M Interconnect (Shared Access Mode)
多对一的情况
一对多的情况
多对多读写地址通道
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 17 / 285
多对多读写数据通道
ZYNQ 内部的 AXI 接口设备就是通过互联矩阵的的方式互联起来的，既保证了传输数据的
高效性，又保证了连接的灵活性。Xilinx 在 Vivado 里我们提供了实现这种互联矩阵的 IP 核
axi_interconnect，我们只要调用就可以。
AXI Interconnect IP
ZYNQ 芯片开发流程的简介
由于 ZYNQ 将 CPU 与 FPGA 集成在了一起，开发人员既需要设计 ARM 的操作系统应用程序
和设备的驱动程序，又需要设计 FPGA 部分的硬件逻辑设计。开发中既要了解 Linux 操作系
统，系统的构架，也需要搭建一个 FPGA 和 ARM 系统之间的硬件设计平台。所以 ZYNQ 的开发
是需要软件人员和硬件硬件人员协同设计并开发的。这既是 ZYNQ 开发中所谓的"软硬件协同设
计”。
ZYNQ 系统的硬件系统和软件系统的设计和开发需要用到一下的开发环境和调试工具：
Xilinx Vivado。
Vivado 设计套件实现 FPGA 部分的设计和开发，管脚和时序的约束，编译和仿真，实现
RTL 到比特流的设计流程。Vivado 并不是 ISE 设计套件的简单升级，而是一个全新的设计套
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 18 / 285
件。它替代了 ISE 设计套件的所有重要工具，比如 Project Navigator、Xilinx Synthesis 
Technology、Implementation、CORE Generator、Constraint、Simulator、Chipscope Analyzer、
FPGA Editor 等设计工具。
Xilinx SDK（Software Development Kit）， SDK 是 Xilinx 软件开发套件(SDK),在 Vivado 硬件系
统的基础上，系统会自动配置一些重要参数，其中包括工具和库路径、编译器选项、JTAG 和
闪存设置，调试器连接已经裸机板支持包(BSP)。SDK 也为所有支持的 Xilinx IP 硬核提供了驱动
程序。SDK 支持 IP 硬核（FPGA 上）和处理器软件协同调试，我们可以使用高级 C 或 C++语言
来开发和调试 ARM 和 FPGA 系统，测试硬件系统是否工作正常。SDK 软件也是 Vivado 软件自
带的，无需单独安装。
ZYNQ 的开发也是先硬件后软件的方法。具体流程如下：
1) 在 Vivado 上新建工程，增加一个嵌入式的源文件。
2) 在 Vivado 里添加和配置 PS 和 PL 部分基本的外设，或需要添加自定义的外设。
3) 在 Vivado 里生成顶层 HDL 文件，并添加约束文件。再编译生成比特流文件（*.bit）。
4) 导出硬件信息到 SDK 软件开发环境，在 SDK 环境里可以编写一些调试软件验证硬件
和软件，结合比特流文件单独调试 ZYNQ 系统。
5) 在 SDK 里生成 FSBL 文件。
6) 在 VMware 虚拟机里生成 u-boot.elf、 bootloader 镜像。
7) 在 SDK 里通过 FSBL 文件, 比特流文件 system.bit 和 u-boot.elf 文件生成一个 BOOT.bin
文件。
8) 在 VMware 里生成 Ubuntu 的内核镜像文件 Zimage 和 Ubuntu 的根文件系统。另外还
需要要对 FPGA 自定义的 IP 编写驱动。
9) 把 BOOT、内核、设备树、根文件系统文件放入到 SD 卡中，启动开发板电源，Linux
操作系统会从 SD 卡里启动。
以上是典型的 ZYNQ 开发流程，但是 ZYNQ 也可以单独做为 ARM 来使用，这样就不需要关
系 PL 端资源，和传统的 ARM 开发没有太大区别。ZYNQ 也可以只使用 PL 部分，但是 PL 的配
置还是要 PS 来完成的，就是无法通过传统的固化 Flash 方式把只要 PL 的固件固化起来。
学习 ZYNQ 要具备哪些技能
学习 ZYNQ 比学习 FPGA、MCU、ARM 等传统工具开发要求更高，想学好 ZYNQ 也不是一
蹴而就的事情。
1.3.1 软件开发人员
 计算机组成原理
 C、C++语言
 计算机操作系统
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 19 / 285
 tcl 脚本
 良好的英语阅读基础
1.3.2 逻辑开发人员
 计算机组成原理
 C 语言
 数字电路基础
 Verilog、VHDL 语言
 良好的英语阅读基础
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 20 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 21 / 285
第二章 Vivado 开发环境
Vivado 软件介绍
一提起 Xilinx 的开发环境，人们总是先会想起 ISE，而对 Vivado 不甚了解。其实，Vivado
是 Xilinx 公司于 2012 推出的新一代集成设计 环境。虽然目前其流行度并不高，但可以说
Vivado 代表了未来 Xilinx FPGA 开发环境的变化趋势。所以，作为一个 Xilinx FPGA 的开发使用
者，学习掌握 Vivado 是趋势，也是必然。作为开发者，首先肯定有以下疑惑：既然已经有 ISE
存在了，为何 Xilinx 公司又花大力气去搞什么 Vivado 呢？在 Vivado Design Suite User Guide : 
Getting Started(UG910)中提到，推出 Vivado 是为了提高设计者的效率，它能显著增加 Xilinx 的
28nm 工艺的可编程逻辑器件的设计、综合与 实现效率。可以推测，随着 FPGA 进入 28nm 时
代，ISE 工具似乎就有些“不合时宜”了，硬件提升了，软件不提升的话，设计效率必然受影
响。正是出于这 一考虑，Xilinx 公司于 2008 年开始便筹划推出新一代的软件开发环境，经历
10 年时间打造出了 Vivado 工具这一巅峰之作。
Vivado 软件版本
Vivado 的软件版本在不断的升级中，到目前为止最新的软件版本已经是 2019.2 了。因为
ZYNQ 开发板的所有例程和教程我们都在 Vivado 2019.2 的开发环境中完成。为了避免软件版本
版本的原因而导致一些无法解释的问题，还是希望大家学习过程中与我们保持同步。用户使用
之前需要安装 Vivado 2019.2 的软件。因为 Vivado 软件比较大，我们没有提供光盘安装文件，
只提供下载链接，另外用户也可以到 Xilinx 的官网下载，官网下载需要注册相关账号。
Vivado 软件的 Xilinx 官方下载地址：http://china.xilinx.com/support/download.html
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 22 / 285
Vivado 提供了 Linux 版和 Windows 版，还提供二合一版本，我们这里使用二合一版本，既
能满足 Windows 开发又能满足 Linux 开发，Vivado 要求操作系统必须是 64 位。
Vivado 软件 Windows 下安装
1) 下载解压 Vivado 软件压缩包，直接点击 xsetup.exe，进入安装，不过为了更好的安装，请
关闭杀毒软件，各种电脑管家，电脑用户名不要有中文，和空格
2) 如果提示版本更新，我们忽略更新，点击“Continue”
3) 点击“next”进行安装，可以看到 Vivado 对系统要求
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 23 / 285
4) 点击“I Agree”接受各个条款
5) 这里选择安装的器件库，由于我们不需要 UltraScale 和 UltraScale+芯片，可以取消勾选，
节省安装空间，其他保持默认，点击“next”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 24 / 285
6) 安装路径这里没有修改，安装路径不能有中文、空格等特殊字符，同时电脑的用户名不要
是中文、带空格的名称。可以看到 Vivado 对硬盘大小的要求，至少要有 80G。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 25 / 285
7) 点击“Install”安装
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 26 / 285
8) 等待安装，时间较长，如果没有关闭杀毒软件和电脑管家，安装过程可能会被拦截，导致
安装软件后不能使用
9) 提示安装成功
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 27 / 285
10) 安装 License 文件，点击“Copy License”，选择“xilinx_ise_vivado.lic”文件。
11) 可以看到安装成功
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 28 / 285
重新安装驱动
一般安装 vivado 时，都会安装下载器驱动。如果需要再次安装下载器驱动，进入 vivado
安装路径“X:\XXX\Vivado\2019.2\data\xicom\cable_drivers\nt64\digilent”下，双击
“install_digilent.exe”文件安装，安装前先关闭 vivado 软件，如果 vivado 识别不到下载器，请
尝试关闭防火墙，杀毒软件，也不能同时打开多个版本的 vivado、ise。
安装完成后，连接下载器，打开设备管理器，在通用串行总线控制器里找到 USB Serial 
Converter，说明安装成功
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 29 / 285
第三章 开发板硬件介绍
黑金基于 XILINX ZYNQ7000 开发平台的开发板 2016 款正式发布了，型号为：AX7010 。此
款开发平台是 XILINX 的 Zynq7000 SOC 芯片的解决方案。它采用 ARM+FPGA SOC 技术将双核
ARM Cortex-A9 和 FPGA 可编程逻辑集成在一颗芯片上。它采用的是 Xilinx 的 Zynq7000 系列
XC7Z010-1CLG400C 作为核心处理器，在 ARM 和 FPGA 上分别具有丰富的硬件资源和外围接
口。设计上坚持“精致、实用、简洁”的设计理念，它不但适合于软件工作人员的前期的软件
验证，也适合于硬件开发人员的硬件设计即软硬件的系统协作，加快项目的开发进程。
图 1-1 ZYNQ 开发板全貌
简介
在这里，对这款 ZYNQ7000 开发平台 AX7010 进行简单的功能介绍。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 30 / 285
此款开发板使用的是 Xilinx 公司的 Zynq7000 系列的芯片，型号为 XC7Z010-1CLG400C，400
个引脚的 FBGA 封装。ZYNQ7000 芯片可分成处理器系统部分 Processor System（PS）和可编程
逻辑部分 Programmable Logic（PL）。在 AX7010 开发板上，ZYNQ7000 的 PS 部分和 PL 部分都搭
载了丰富的外部接口和设备，方便用户的使用和功能验证。另外开发板上集成了 Xilinx USB 
Cable 下载器电路，用户只要用一个 USB 线就可以对开发板进行下载和调试。图 1-2 为整个
AX7010 整个系统的结构示意图：
图 1-2 AX7010 结构示意图
通过这个示意图，我们可以看到，我们这个开发平台所能含有的接口和功能。
 +5V 电源输入,最大 2A 电流保护；
 Xilinx ARM+FPGA 芯片 Zynq-7000 XC7Z010-1CLG400C
 两片大容量的 2Gbit（共 4Gbit）高速 DDR3 SDRAM,可作为 ZYNQ 芯片数据的缓存，也
可以作为操作系统运行的内存;  一片 256Mbit 的 QSPI FLASH, 可用作 ZYNQ 芯片的系统文件和用户数据的存储;  一路 10/100M/1000M 以太网 RJ-45 接口, 可用于和电脑或其它网络设备进行以太网数
据交换;  一路 HDMI 图像视频输入输出接口, 能实现 1080P 的视频图像传输；
 一路高速 USB2.0 HOST 接口, 可用于开发板连接鼠标、键盘和 U 盘等 USB 外设;  一路高速 USB2.0 OTG 接口, 用于和 PC 或 USB 设备的 OTG 通信;  一路 USB Uart 接口, 用于和 PC 或外部设备的串口通信;  一片的 RTC 实时时钟，配有电池座，电池的型号为 CR1220。  一片 IIC 接口的 EEPROM 24LC04;
40针扩展口（34个IO口，1路5V，2路3.3V，3路GND 40针扩展口（ 3路GND 34个IO口，1路5V，2路3.3V， Micro SD卡座 ZYNQ7000 XC7Z010- 1CLG400C 256MByte DDR3 50M晶振 EEPROM 24LC04 实时时钟 电平转换 千兆以太网 芯片 USB2.0 芯片 USB转 串口 千兆网口 USB 接口 串口接口 +5V 电源接口 电源开关 PMOD接口 3.3V电源 1.0V电源 1.5V电源 DDR电源 2个PS LED灯，4个PL LED灯 电源 指示灯 1.8V 电源 256MByte DDR3 USB OTG QSPI FLASH Micro SD 卡槽 USB 调试口 HDMI 输出 1个复位键，2个PS按键，4个PL按键 JTAG调试 芯片 33.33M 晶振
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 31 / 285
 6 个用户发光二极管 LED, 2 个 PS 控制，4 个 PL 控制;  7 个按键，1 个 CPU 复位按键，2 个 PS 控制按键，4 个 PL 控制按键；
 板载一个 33.333Mhz 的有源晶振，给 PS 系统提供稳定的时钟源，一个 50MHz 的有源
晶振，为 PL 逻辑提供额外的时钟；
 2 路 40 针的扩展口（2.54mm 间距），用于扩展 ZYNQ 的 PL 部分的 IO。可以接 7 寸 TFT
模块、摄像头模块和 AD/DA 模块等扩展模块；
 一个 12 针的扩展口（2.54mm 间距），用于扩展 ZYNQ 的 PS 系统的 MIO；  一路 USB JTAG 口，通过 USB 线及板载的 JTAG 电路对 ZYNQ 系统进行调试和下载。
1 路 Micro SD 卡座(开发板背面），用于存储操作系统镜像和文件系统。
结构尺寸
开发板的尺寸为精简的 130mm x 90mm, PCB 采用 8 层板设计。板子四周有 4 个螺丝定位
孔，用于固定开发板，定位孔的孔径为 3.5mm(直径），资料中提供 dxf 结构图。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 32 / 285
电源
电源输入：开发板供电电压为 DC5V，请使用开发板自带的电源,不要用其他规格的电源，
以免损坏开发板。开发板上的电源设计示意图如下:
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 33 / 285
图 3-1 原理图中电源接口部分
开发板通过+5V 供电, 通过四路 DC/DC 电源芯片 TLV62130RGT 转化成+3.3V，+1.5V，
+1.8V，+1.0V 四路电源， 每路输出电流可高达 3A。通过一路 LDO SPX3819M5-3-3 产生 VCCIO
电源，VCCIO 最要是针对 ZYNQ 的 BANK35 进行供电，通过更换其它的 LDO 芯片，使得 BANK35
的 IO 适应不同的电压标准。1.5V 通过 TI 的 TPS51200 生成 DDR3 需要的 VTT 和 VREF 电压。各
个电源分配的功能如下表所示：
电源 功能
+3.3V
ZYNQ VCCIO, 以太网，串口，HDMI, RTC，FLASH, EEPROM
以及 SD card
+1.8V
ZYNQ 辅助电压, ZYNQ PLL, ZYNQ Bank501 VCCIO, 以太网，
USB2.0
+1.0V ZYNQ,的核心电压
+1.5V DDR3, ZYNQ Bank502
VREF, VTT DDR3
VCCIO ZYNQ Bank35
因为 ZYNQ 的 PS 和 PL 部分的电源有上电顺序的要求，在电路设计中，我们已经按照
ZYQN 的电源要求设计，上电依次为 1.0V -> 1.8V -> 1.5 V -> 3.3V -> VCCIO，图 3-2 为电源的电路
设计：
5V 电源 输入 保险丝 TLV62130R GT TLV62130R GT TPS51200 3.3V/3A 1.5V/3A VTT VREF TLV62130R GT 电源开关 1.8V/3A CN1 F1 SW1 U26 U25 U24 U32 1.0V/3A TLV62130R GT U23 SPX3819M5 -3-3 VCCIO/0.5A
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 34 / 285
图3-2 开发板的电源设计
我们在设计 PCB 的时候，采用 8 层 PCB，预留了独立的电源层和 GND 层，使得整个开发
板的电源，具有非常好的稳定性。在 PCB 板上我们预留了各个电源的测试点，以便用户确认板
上的电压。
图 3-3 实物图中的电源测试点
ZYNQ7000
开发板使用的是 Xilinx 公司的 Zynq7000 系列的芯片，型号为 XC7Z010-1CLG400C。芯片的
PS 系统集成了两个 ARM Cortex™-A9 处理器，AMBA®互连，内部存储器，外部存储器接口和外
设。这些外设主要包括 USB 总线接口，以太网接口，SD/SDIO 接口，I2C 总线接口，CAN 总线
接口，UART 接口，GPIO 等。PS 可以独立运行并在上电或复位下启动。ZYNQ7000 芯片的总体
框图如图 4-1 所示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 35 / 285
图4-1 ZYNQ7000芯片的总体框图
其中 PS 系统部分的主要参数如下：
- 基于 ARM 双核 CortexA9 的应用处理器
- 每个 CPU 32KB 1 级指令和数据缓存，512KB 2 级缓存 2 个 CPU 共享
- 片上 boot ROM 和 256KB 片内 RAM
- 外部存储接口，支持 16/32 bit DDR2、DDR3 接口
- 两个千兆网卡支持：发散-聚集 DMA ，GMII，RGMII，SGMII 接口
- 两个 USB2.0 OTG 接口，每个最多支持 12 节点
- 两个 CAN2.0B 总线接口
- 两个 SD 卡、SDIO、MMC 兼容控制器
- 2 个 SPI，2 个 UARTs，2 个 I2C 接口
- 4 组 32bit GPIO，54（32+22）作为 PS 系统 IO，64 连接到 PL
- PS 内和 PS 到 PL 的高带宽连接
其中 PL 逻辑部分的主要参数如下：
- 逻辑单元 Logic Cells：28K； - 查找表 LUTs:17600
- 触发器(flip-flops):35200
- 乘法器 18x25MACCs：80;
- Block RAM：240KB； - 两个 AD 转换器,可以测量片上电压、温度感应和高达 17 外部差分输入通道，1MBPS
XC7Z010-1CLG400C 芯片为 BGA 封装，400 个引脚，引脚间距为 0.8mm。再次说明一下
BGA 管脚，当我们使用 BGA 封装的芯片以后，引脚名称变为由字母+数字的形式，比如 E3，G3
等等，因此我们在看原理图的时候，看到的字母+数字这种形式的，就是代表了 BGA 的引脚。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 36 / 285
图 3.1 为开发板所用的 XC7Z010 芯片实物图。
图4-2 XC7Z010芯片实物
3.4.1 JTAG 接口
首先我们来说 AX7010 开发板的 JTAG 调试接口, 在电路板上已经集成了 JTAG 的下载调试
电路，所以用户无需购买额外的 Xilinx 下载器。只要一根 USB 线就能进行 ZYNQ 的开发和调试
了。在 AX7010 开发板上通过一个 FTDI 的 USB 桥接芯片 FT232HL 实现 PC 的 USB 和 ZYNQ 的
JTAG 调试信号 TCK,TDO,TMS,TDI 进行数据通信。图 4-3 为开发板上 JTAG 口的原理图部分：
图4-3 原理图中JTAG接口部分
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 37 / 285
在 AX7010 开发板上，JTAG 接口的形式是 USB 接口方式的，用户可以通过我们提供的 USB
线连接 PC 和 JTAG 接口进行 ZYNQ 的系统调试。
图4-4 JTAG接口实物图
3.4.2 FPGA 供电系统
接下来，我们说一下 AX7010 的电源设计部分。ZYNQ 芯片的电源分 PS 系统部分和 PL 逻辑
部分，两部分的电源分别是独立工作。PS 系统部分的电源和 PL 逻辑部分的电源都有上电顺
序，不正常的上电顺序可能会导致 ARM 系统和 FPGA 系统无法正常工作。
PS 部分的电源有 VCCPINT、VCCPAUX、VCCPLL 和 PS VCCO。VCCPINT 为 PS 内核供电引脚，
接 1.0V；VCCPAUX 为 PS 系统辅助供电引脚，接 1.8V；VCCPLL 为 PS 的内部时钟 PLL 的电源供
电引脚，也接 1.8V；PS VCCO 为 BANK 的电压，包含 VCCO_MIO0，VCCO_MIO1 和 VCCO_DDR，
根据连接的外设不同，连接的电源电源也会不同，在 AX7010 开发板上，VCC_MIO0 连接
3.3V， VCCO_MIO1 连接 1.8V，VCCO_DDR 连接 1.5V。PS 系统要求上电顺序分别为先 VCCPINT
供电，然后 VCCPAUX 和 VCCPLL，最后为 PS VCCO。断电的顺序则相反。
PL 部分的电源有 VCCINT, VCCBRAM, VCCAUX 和 VCCO。VCCPINT 为 FPGA 内核供电引脚，
接 1.0V；VCCBRAM 为 FPGA Block RAM 的供电引脚；接 1.0V；VCCAUX 为 FPGA 辅助供电引脚, 
接 1.8V；VCCO 为 PL 的各个 BANK 的电压，包含 BANK13，BANK34，BANK35，在 AX7010 开发
板上，BANK 的电压连接 3.3V。PL 系统要求上电顺序分别为先 VCCINT 供电，再是 VCCBRAM, 
然后是 VCCAUX，最后为 VCCO。如果 VCCINT 和 VCCBRAM 的电压一样，可以同时上电。断电
的顺序则相反。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 38 / 285
3.4.3 ZYNQ 启动配置
AX7010 开发平台支持三种启动模式。这三种启动模式分别是 JTAG 调试模式,QSPI FLASH 和
SD 卡启动模式。ZYNQ702 芯片上电后会检测响应 MIO 口的电平来决定那种启动模式。用户可
以通过核心板上的 J13 的跳线来选择不同的启动模式。J13 启动模式配置如下表 4-1 所示。
J13 跳帽位置 启动模式
连接左边两个引脚 SD Card
连接中间两个引脚 QSPI FLASH
连接右边边两个引脚 JTAG
表4-1 J13启动模式配置
时钟配置
AX7010 开发板上分别为 PS 系统和 PL 逻辑部分提供了有源时钟，是 PS 系统和 PL 逻辑可
以单独工作。
3.5.1 5.1 PS 系统时钟源
ZYNQ 芯片通过开发板上的 X1 晶振为 PS 部分提供 33.333MHz 的时钟输入。时钟的输入连
接到 ZYNQ 芯片的 BANK500 的 PS_CLK_500 的管脚上。其原理图如图 5-1 所示： 图5-1 PS部分的有源晶振
图 5-2 为有源晶振实物图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 39 / 285
图5-2 33.333Mhz有源晶振实物图
时钟引脚分配：
信号名称 ZYNQ 引脚
PS_CLK_500 E7
3.5.2 5.2 PL 系统时钟源
AX7010 开发板上提供了单端 50MHz 的 PL 系统时钟源，3.3V 供电。晶振输出连接到 FPGA
的全局时钟(MRCC)，这个 GCLK 可以用来驱动 FPGA 内的用户逻辑电路。该时钟源的原理图如
图 5-3 所示
图 5-3 PL系统时钟源 图 5-4 为有源晶振 50MHz 的实物图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 40 / 285
图5-4 50Mhz有源晶振实物图
PL 时钟引脚分配：
信号名称 ZYNQ 引脚
PL_GCLK U18
PS 端的外设
因为 ZYNQ 是由 ARM 系统 PS 部分和 FPGA 逻辑 PL 部分组成，开发板上有些外设是连接到
PS 的 IO 上，有些外设是连接到开发板的 PL 的 IO 上。首先我们先对 PS 部分连接的外设做介
绍。
3.6.1 6.1 QSPI Flash
开发板配有一片 256MBit 大小的 Quad-SPI FLASH 芯片，型号为 W25Q256，它使用 3.3V 
CMOS 电压标准。由于 QSPI FLASH 的非易失特性，在使用中， 它可以作为系统的启动设备来
存储系统的启动镜像。这些镜像主要包括 FPGA 的 bit 文件、ARM 的应用程序代码以及其它的
用户数据文件。QSPI FLASH 的具体型号和相关参数见表 6-1。
位号 芯片类型 容量 厂家
U6 W25Q256BV 32M Byte Winbond
表6-1 QSPI Flash的型号和参数
QSPI FLASH 连接到 ZYNQ 芯片的 PS 部分 BANK500 的 GPIO 口上，在系统设计中需要配置这
些 PS 端的 GPIO 口功能为 QSPI FLASH 接口。为图 6-1 为 QSPI Flash 在硬件连接示意图。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 41 / 285
图6-1 QSPI Flash连接示意图
配置芯片引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号
QSPI_CLK PS_MIO6_500 A5
QSPI_CS PS_MIO1_500 A7
QSPI_D0 PS_MIO2_500 B8
QSPI_D1 PS_MIO3_500 D6
QSPI_D2 PS_MIO4_500 B7
QSPI_D3 PS_MIO5_500 A6
3.6.2 6.2 DDR3 DRAM
AX7010开发板上配有两个SKHynix(海力士）的2Gbit（512MB）的DDR3芯片(共计4Gbit),型
号为H5TQ2G63FFR（兼容MT41J128M16HA-125）。DDR的总线宽度共为32bit。DDR3 SDRAM的
最高运行速度可达533MHz(数据速率1066Mbps)。该DDR3存储系统直接连接到了ZYNQ处理系统
（PS）的BANK 502的存储器接口上。DDR3 SDRAM的具体配置如下表6-1所示。 
表6-1 DDR3 SDRAM配置
位号 芯片类型 容量 厂家
U8,U9 H5TQ2G63FFR-RDC 128M x 16bit SKHynix
DDR3 的硬件设计需要严格考虑信号完整性，我们在电路设计和 PCB 设计的时候已经充分
考虑了匹配电阻/终端电阻,走线阻抗控制，走线等长控制， 保证 DDR3 的高速稳定的工作。
DDR3 DRAM 的硬件连接示意图如图 6-2 所示:
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 42 / 285
图6-2 DDR3 DRAM原理图部分
图 6-3 为 DDR3 DRAM 实物图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 43 / 285
图 6-3 DDR3 DRAM 实物图
DDR3 DRAM 引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号
DDR3_DQS0_P PS_DDR_DQS_P0_502 C2
DDR3_DQS0_N PS_DDR_DQS_N0_502 B2
DDR3_DQS1_P PS_DDR_DQS_P1_502 G2
DDR3_DQS1_N PS_DDR_DQS_N1_502 F2
DDR3_DQS2_P PS_DDR_DQS_P2_502 R2
DDR3_DQS2_N PS_DDR_DQS_N2_502 T2
DDR3_DQS3_P PS_DDR_DQS_P3_502 W5
DDR3_DQS4_N PS_DDR_DQS_N3_502 W4
DDR3_DQ[0] PS_DDR_DQ0_502 C3
DDR3_DQ [1] PS_DDR_DQ1_502 B3
DDR3_DQ [2] PS_DDR_DQ2_502 A2
DDR3_DQ [3] PS_DDR_DQ3_502 A4
DDR3_DQ [4] PS_DDR_DQ4_502 D3
DDR3_DQ [5] PS_DDR_DQ5_502 D1
DDR3_DQ [6] PS_DDR_DQ6_502 C1
DDR3_DQ [7] PS_DDR_DQ7_502 E1
DDR3_DQ [8] PS_DDR_DQ8_502 E2
DDR3_DQ [9] PS_DDR_DQ9_502 E3
DDR3_DQ [10] PS_DDR_DQ10_502 G3
DDR3_DQ [11] PS_DDR_DQ11_502 H3
DDR3_DQ [12] PS_DDR_DQ12_502 J3
DDR3_DQ [13] PS_DDR_DQ13_502 H2
DDR3_DQ [14] PS_DDR_DQ14_502 H1
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 44 / 285
DDR3_DQ [15] PS_DDR_DQ15_502 J1
DDR3_DQ [16] PS_DDR_DQ16_502 P1
DDR3_DQ [17] PS_DDR_DQ17_502 P3
DDR3_DQ [18] PS_DDR_DQ18_502 R3
DDR3_DQ [19] PS_DDR_DQ19_502 R1
DDR3_DQ [20] PS_DDR_DQ20_502 T4
DDR3_DQ [21] PS_DDR_DQ21_502 U4
DDR3_DQ [22] PS_DDR_DQ22_502 U2
DDR3_DQ [23] PS_DDR_DQ23_502 U3
DDR3_DQ [24] PS_DDR_DQ24_502 V1
DDR3_DQ [25] PS_DDR_DQ25_502 Y3
DDR3_DQ [26] PS_DDR_DQ26_502 W1
DDR3_DQ [27] PS_DDR_DQ27_502 Y4
DDR3_DQ [28] PS_DDR_DQ28_502 Y2
DDR3_DQ [29] PS_DDR_DQ29_502 W3
DDR3_DQ [30] PS_DDR_DQ30_502 V2
DDR3_DQ [31] PS_DDR_DQ31_502 V3
DDR3_DM0 PS_DDR_DM0_502 A1
DDR3_DM1 PS_DDR_DM1_502 F1
DDR3_DM2 PS_DDR_DM2_502 T1
DDR3_DM3 PS_DDR_DM3_502 Y1
DDR3_A[0] PS_DDR_A0_502 N2
DDR3_A[1] PS_DDR_A1_502 K2
DDR3_A[2] PS_DDR_A2_502 M3
DDR3_A[3] PS_DDR_A3_502 K3
DDR3_A[4] PS_DDR_A4_502 M4
DDR3_A[5] PS_DDR_A5_502 L1
DDR3_A[6] PS_DDR_A6_502 L4
DDR3_A[7] PS_DDR_A7_502 K4
DDR3_A[8] PS_DDR_A8_502 K1
DDR3_A[9] PS_DDR_A9_502 J4
DDR3_A[10] PS_DDR_A10_502 F5
DDR3_A[11] PS_DDR_A11_502 G4
DDR3_A[12] PS_DDR_A12_502 E4
DDR3_A[13] PS_DDR_A13_502 D4
DDR3_A[14] PS_DDR_A14_502 F4
DDR3_BA[0] PS_DDR_BA0_502 L5
DDR3_BA[1] PS_DDR_BA1_502 R4
DDR3_BA[2] PS_DDR_BA2_502 J5
DDR3_S0 PS_DDR_CS_B_502 N1
DDR3_RAS PS_DDR_RAS_B_502 P4
DDR3_CAS PS_DDR_CAS_B_502 P5
DDR3_WE PS_DDR_WE_B_502 M5
DDR3_ODT PS_DDR_ODT_502 N5
DDR3_RESET PS_DDR_DRST_B_502 B4
DDR3_CLK_P PS_DDR_CKP_502 L2
DDR3_CLK_N PS_DDR_CKN_502 M2
DDR3_CKE PS_DDR_CKE_502 N3
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 45 / 285
3.6.3 6.3 千兆以太网接口
AX7010 开发板上通过 Realtek RTL8211E-VL 以太网 PHY 芯片用户提供网络通信服务。以太
网 PHY 芯片是连接到 ZYNQ 的 PS 端 BANK501 的 GPIO 接口上。RTL8211E-VL 芯片支持
10/100/1000 Mbps 网络传输速率，通过 RGMII 接口跟 Zynq7000 PS 系统的 MAC 层进行数据通
信。RTL8211E-VL 支持ＭDI/MDX 自适应，各种速度自适应，Master/Slave 自适应，支持 MDIO
总线进行 PHY 的寄存器管理。
RTL8211E-VL 上电会检测一些特定的 IO 的电平状态，从而确定自己的工作模式。表 6-2 描
述了 GPHY 芯片上电之后的默认设定信息。
配置 Pin 脚 说明 配置值
PHYAD[2:0] MDIO/MDC 模式的 PHY 地址 PHY Address 为 001
SELRGV RGMII 1.8V 或 1.5V 电平选择 1.8V
AN[1:0] 自协商配置 (10/100/1000M)自适应
RX Delay RX 时钟 2ns 延时 延时
TX Delay TX 时钟 2ns 延时 延时
表 6-2 PHY 芯片默认配置值
 当网络连接到千兆以太网时，FPGA 和 PHY 芯片 RTL8211E-VL 的数据传输时通过 RGMII 总线
通信，传输时钟为 125Mhz，数据在时钟的上升沿和下降样采样。
当网络连接到百兆以太网时，FPGA 和 PHY 芯片 RTL8211E-VL 的数据传输时通过 RMII 总线
通信，传输时钟为 25Mhz。数据在时钟的上升沿和下降样采样。
图 6-4 为 ZYNQ 与以太网 PHY 芯片连接示意图:
 
图 6-4 FPGA 与 PHY 连接示意图
图 6-5 为以太网 PHY 芯片的实物图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 46 / 285
图 6-5 以太网 PHY 芯片实物图
以太网引脚分配如下：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
ETH_GCLK PS_MIO16_501 A19 RGMII 发送时钟
ETH_TXD0 PS_MIO17_501 E14 发送数据 bit０ ETH_TXD1 PS_MIO18_501 B18 发送数据 bit1
ETH_TXD2 PS_MIO19_501 D10 发送数据 bit2
ETH_TXD3 PS_MIO20_501 A17 发送数据 bit3
ETH_TXCTL PS_MIO21_501 F14 发送使能信号
ETH_RXCK PS_MIO22_501 B17 RGMII 接收时钟
ETH_RXD0 PS_MIO23_501 D11 接收数据 Bit0
ETH_RXD1 PS_MIO24_501 A16 接收数据 Bit1
ETH_RXD2 PS_MIO25_501 F15 接收数据 Bit2
ETH_RXD3 PS_MIO26_501 A15 接收数据 Bit3
ETH_RXCTL PS_MIO27_501 D13 接收数据有效信号
ETH_MDC PS_MIO52_501 C10 MDIO 管理时钟
ETH_MDIO PS_MIO53_501 C11 MDIO 管理数据
3.6.4 6.4 USB2.0
AX7010使用的USB2.0收发器是一个1.8V的，高速的支持ULPI标准接口的USB3320C-EZK。
ZYNQ的USB总线接口和USB3320C-EZK收发器相连接，实现高速的USB2.0 Host模式和Slave模式的
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 47 / 285
数据通信。USB3320C的USB的数据和控制信号连接到ZYNQ芯片PS端的BANK501的IO口上，一个
24MHz的晶振为USB3320C提供系统时钟。
开发板上为用户提供了两个 USB 接口,一个是 Host USB 口，一个是 Slave USB 口。分别为扁
型 USB 接口(USB Type A) 和微型 USB 接口(Micro USB), 方便用户连接不同的 USB 外设。用户可
以通过开发板上的 J5，J6 的跳线实现 Host 和 Slave 的切换。表 6-3 为模式切换说明：
表 6-3 USB 接口模式切换说明
J5, J6 状态 USB 模式 说明
J5 和 J6 安装跳线帽 HOST 模式 开发板作为主设备，USB 口连接鼠标，
键盘，USB 等从外设
J5 和 J6 不安装跳线帽 OTG/Slave 模式 开发板作为从设备，USB 口连接电脑
ZYNQ处理器和USB3320C-EZK芯片连接的示意图如6-6所示：
图 6-6 Zynq7000 和 USB 芯片间连接示意图
图 6-7 为 USB2.0 部分的实物图，U11 为 USB3320C，J3 为 Host USB 接口, J4 为 Slave USB 接
口。跳线帽 J5 和 J6 用于 Host 和 Slave 模式的选择。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 48 / 285
图 6-7 USB2.0 部分的实物图
USB2.0 引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
OTG_DATA4 PS_MIO28_501 C16 USB 数据 Bit4
OTG_DIR PS_MIO29_501 C13 USB 数据方向信号
OTG_STP PS_MIO30_501 C15 USB 停止信号
OTG_NXT PS_MIO31_501 E16 USB 下一数据信号
OTG_DATA0 PS_MIO32_501 A14 USB 数据 Bit0
OTG_DATA1 PS_MIO33_501 D15 USB 数据 Bit1
OTG_DATA2 PS_MIO34_501 A12 USB 数据 Bit2
OTG_DATA3 PS_MIO35_501 F12 USB 数据 Bit3
OTG_CLK PS_MIO36_501 A11 USB 时钟信号
OTG_DATA5 PS_MIO37_501 A10 USB 数据 Bit5
OTG_DATA6 PS_MIO38_501 E13 USB 数据 Bit6
OTG_DATA7 PS_MIO39_501 C18 USB 数据 Bit7
OTG_RESETN PS_MIO46_501 D16 USB 复位信号
3.6.5 6.5 USB 转串口
AX7010开发板采用Silicon Labs CP2102GM的USB转UART芯片, USB接口采用Micro USB接口，
用户可以用一根Micro USB线连接到PC上进行串口通信。
UART的TX/RX信号与ZYNQ EPP 的PS BANK501的信号相连，因为该BANK的VCCMIO设置为
1.8V，但CP2102GM的数据电平为3.3V, 我们这里通过TXS0102DCUR电平转换芯片来连接。
CP2102GM和ZYNQ连接的示意图如图6-8所示：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 49 / 285
图 6-8 CP2102GM 连接示意图
图 6-9 为 USB 转串口的实物图
图 6-9 USB 转串口实物图
ZYNQ 串口引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
UART_TX PS_MIO48_501 B12 Uart数据输出
UART_RX PS_MIO49_501 C12 Uart数据输入
Silicon Labs 为主机 PC 提供了虚拟 COM 端口（VCP）驱动程序。这些驱动程序允许
CP2102GM USB-UART 桥接设备在通信应用软件（例如，TeraTerm 或超级终端）显示为一个
COM 端口。VCP 设备驱动程序必须在 PC 主机与 AX7010 开发板板建立通信前进行安装。
3.6.6 6.6 SD 卡槽
AX7010开发板包含了一个Micro型的SD卡接口，以提供用户访问SD卡存储器，用于存储
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 50 / 285
ZYNQ芯片的BOOT程序，Linux操作系统内核, 文件系统以及其它的用户数据文件。
SDIO信号与ZYNQ的PS BANK501的IO信号相连，因为该BANK的VCCMIO设置为1.8V，但SD卡
的数据电平为3.3V, 我们这里通过TXS02612电平转换器来连接。Zynq7000 PS和SD卡连接器的原
理图如图6-10所示。
图 6-10 SD 卡连接示意图
SD 卡槽在开发板的背面，图 6-11 SD 卡槽实物图
图 6-11 SD 卡槽实物图
SD 卡槽引脚分配
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
SD_CLK PS_MIO40 D14 SD时钟信号
SD_CMD PS_MIO41 C17 SD命令信号
SD_D0 PS_MIO42 E12 SD数据Data0
SD_D1 PS_MIO43 A9 SD数据Data1
SD_D2 PS_MIO44 F13 SD数据Data2
SD_D3 PS_MIO45 B15 SD数据Data3
SD_CD PS_MIO47 B14 SD卡插入信号
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 51 / 285
3.6.7 6.7 PS PMOD 连接器
AX7010 开发板预留了一个 12 针 2.54mm 间距的 PMOD 接口(J12)用于连接 PS BANK500 的
IO 和外部模块或电路。因为 BANK500 的 IO 是 3.3V 标准的，所以连接的外部设备和电路的信
号也需要 3.3V 电平标准。PMOD 连接器的原理图如图 6-12 所示
图 6-12 PMOD 连接器原理图
图 6-13 为 PS PMOD 连接器的实物图
图 6-13 PS PMOD 连接器的实物图
PS PMOD 连接器的引脚分配
PMOD 管脚 信号名称 ZYNQ 引脚名 ZYNQ 引脚号
PIN1 PMOD_IO0 PS_MIO11_500 C6 
PIN2 PMOD_IO2 PS_MIO9_500 B5
PIN3 PMOD_IO3 PS_MIO15_500 C8
PIN4 PMOD_IO4 PS_MIO7_500 D8
PIN5 GND - -
PIN6 +3.3V - -
PIN7 PMOD_IO1 PS_MIO10_500 E9
PIN8 PMOD_IO6 PS_MIO8_500 D5
PIN9 PMOD_IO7 PS_MIO14_500 C5
PIN10 PMOD_IO5 PS_MIO12_500 D9
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 52 / 285
PIN11 GND - -
PIN12 +3.3V - -
3.6.8 6.8 用户 LED
AX7010 开发板上，PS 部分的 BANK500 IO 上连接了 2 个 LED 发光二极管，用户可以使用这
两个 LED 灯来调试程序。当 BANK500 IO 电压为高时，LED 灯熄灭，当 BANK500 IO 电压为低
时，LED 会被点亮。ZYNQ BANK500 IO 和 LED 灯连接的示意图如图 6-14 所示：
图 6-14 Zynq-7000 和 LED 灯连接示意图
图 6-15 为 PS 的 LED 灯实物图
图 6-15 PS 的 LED 灯实物图
PS LED 灯的引脚分配
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
MIO0_LED PS_MIO0_500 E6 PS LED1灯
MIO13_LED PS_MIO13_500 E8 PS LED2灯
3.6.9 6.9 用户按键
AX7010 开发板上，PS 部分的 BANK501 IO 上连接了 2 个用户按键，用户可以使用这两个用
户按键来测试输入信号和中断触发。设计中按键按下，输入到 ZYNQ BANK501 IO 上的信号电压
为低，没有按下时，信号为高。 ZYNQ BANK501 IO 和按键连接的示意图如图 6-16 所示：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 53 / 285
图 6-16 Zynq-7000 和按键连接示意图
图 6-17 为 PS 的按键实物图
图 6-17 PS 的按键实物图
PS LED 灯的引脚分配
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
MIO_KEY1 PS_MIO50_501 B13 PS用户按键KEY1
MIO_KEY2 PS_MIO51_501 B9 PS用户按键KEY2
PL 端的外设
下面我们再对 PL 部分（FPGA 逻辑部分）连接的外设做一下介绍。
3.7.1 7.1 HDMI 接口
HDMI，全称为高清晰度多媒体视频输出接口。AX7010 开发板上通过 FPGA 的差分 IO 直接
连接到 HDMI 接口的差分信号和时钟，在 FPGA 内部实现 HMDI 信号的差分转并行再进行编解
码，实现 DMI 数字视频输入和输出的传输解决方案，最高支持 1080P@60Hz 的输入和输出的
功能。
HDMI 的信号连接到 ZYNQ 的 PL 部分的 BANK34 上，图 6-1-1 为 HDMI 设计的原理图，当开
发板作为 HDMI 显示设备时（HDMI IN），HDMI 信号作为输入，HPD(hot plug detect)信号作为输
出。当开发板作为 HDMI 主设备（HDMI OUT）时，则相反。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 54 / 285
图 7-1 为 HDMI 设计的原理图
开发板在作为 HDMI 主设备（HDMI OUT）时,需要提供给 HDMI 显示设备一个+5V 的电源。
电源输出控制电路如图 7-2 所示
图 7-2 HDMI 5V 输出电路
另外 HMDI 主设备会通过 IIC 总线读取 HDMI 显示设备的 EDID 设备信息。FPGA 的管脚电平
是 3.3V, 但 HDMI 的电平是+5V, 这里我们需要电平转换芯片 GTL2002D 来连接。IIC 的转换电路
如图 7-3 所示
图 7-3 GTL2002D 电平转换电路
图 7-4 为 HDMI 接口的实物图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 55 / 285
图 7-4 HDMI 接口的实物图
HDMI 接口的引脚分配
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
HDMI_CLK_P IO_L13P_T2_MRCC_34 N18 HDMI时钟信号正
HDMI_CLK_N IO_L13N_T2_MRCC_34 P19 HDMI时钟信号负
HDMI_D0_P IO_L16P_T2_34 V20 HDMI数据0正
HDMI_D0_N IO_L16N_T2_34 W20 HDMI数据0负
HDMI_D1_P IO_L15P_T2_DQS_34 T20 HDMI数据1正
HDMI_D1_N IO_L15N_T2_DQS_34 U20 HDMI数据1负
HDMI_D2_P IO_L14P_T2_SRCC_34 N20 HDMI数据2正
HDMI_D2_N IO_L14N_T2_SRCC_34 P20 HDMI数据2负
HDMI_SCL IO_L20N_T3_34 R18 HDMI IIC时钟
HDMI_SDA IO_L19P_T2_34 R16 HDMI IIC数据
HDMI_CEC IO_L17P_T2_34 Y18 HDMI遥控器信号
HDMI_HPD IO_L17N_T2_34 Y19 HDMI热插拔检测信号
HDMI_OUT_EN IO_L18P_T2_34 V16 HDMI电源输出控制
3.7.2 7.2 EEPROM 24LC04
AX7010 开发板板载了一片 EEPROM，型号为 24LC04,容量为：4Kbit（2*256*8bit），由 2 个
256byte 的 block 组成,通过 IIC 总线进行通信。板载 EEPROM 就是为了学习 IIC 总线的通信方
式。EEPROM 的 I2C 信号连接的 ZYNQ PL 端的 BANK34 IO 口上。图 7-5 为 EEPROM 的原理图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 56 / 285
图 7-5 EEPROM 原理图部分
图 7-6 为 EEPROM 实物图
图 7-6 EEPROM 实物图
EEPROM 引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
EEPROM_I2C_SCL IO_25_34 T19 IIC时钟信号
EEPROM_I2C_SDA IO_L12N_T1_MRCC_34 U19 IIC数据信号
3.7.3 7.3 实时时钟 DS1302
开发板板载了一片实时时钟 RTC 芯片，型号 DS1302，他的功能是提供到 2099 年内的日历
功能，年月日时分秒还有星期。如果系统中需要时间的话，那么 RTC 就需要涉及到产品中。他
外部需要接一个 32.768KHz 的无源时钟，提供精确的时钟源给时钟芯片，这样才能让 RTC 可以
准确的提供时钟信息给产品。同时为了产品掉电以后，实时时钟还可以正常运行，一般需要另
外配一个电池给时钟芯片供电，图 6-3-1 中为 BT1 为电池座，我们将纽扣电池（型号 CR1220，
电压为 3V）放入以后，当系统掉电池，纽扣电池还可以给 DS1302 供电，这样，不管产品是否
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 57 / 285
供电，DS1302 都会正常运行，不会间断，可以提供持续不断的时间信息。RTC 的接口信号也是
连接到 ZYNQ PL 端的 BANK34 和 BANK35 IO 口上。图 7-7 为 DS1302 原理图
图 7-7 DS1302 原理图
图 7-8 为 DS1302 实物图
图 7-8 DS1302 实物图
DS1302 接口引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
RTC _SCLK IO_0_34 R19 RTC的时钟信号
RTC_RESET IO_L22N_T3_AD7N_35 L15 RTC的复位信号
RTC _DATA IO_L22P_T3_AD7P_35 L14 RTC的数据信号
3.7.4 7.4 扩展口 J10
扩展口 J10 为 40 管脚的 2.54mm 的双排连接器，为用户扩展更多的外设和接口，目前
ALINX 黑金提供的模块有：ADDA 模块，液晶屏模块，千兆以太网模块，音频输入输出模块，
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 58 / 285
矩阵键盘模块，500W 双目视觉摄像头模块。扩展口上包含 5V 电源 1 路，3.3V 电源 2 路，地 3
路，IO 口 34 路。IO 口的信号连接到 ZYNQ PL 的 BANK35 和 BANK35 上，电平默认为 3.3V，扩
展口 J10 的部分 IO 可以通过更换开发板上电源芯片(SPX3819M5-3-3)改变 IO 的电平。切勿直接
跟 5V 设备直接连接，以免烧坏 FPGA。如果要接 5V 设备，需要接电平转换芯片。
在扩展口和 FPGA 连接之间串联了 33 欧姆的排阻，用于保护 FPGA 以免外界电压或电流过
高造成损坏。PCB 设计上 P 和 N 的走线使用差分走线，控制差分阻抗为 100 欧姆。扩展口(J10)
的电路如图 7-9 所示：
图 7-9 J10 扩展口原理图
图 7-10 为 J10 扩展口实物图，扩展口的 Pin1，Pin2 和 Pin39，Pin40 已经在板上标示出。
图 7-10 J10 扩展口实物图
J10 扩展口引脚分配
J10 管脚 信号名称 ZYNQ 引脚名 ZYNQ 引脚号
PIN1 GND - -
PIN2 +5V - -
PIN3 EX_IO1_1N IO_L22N_T3_34 W19
PIN4 EX_IO1_1P IO_L22P_T3_34 W18
PIN5 EX_IO1_2N IO_L6N_T0_34 R14
PIN6 EX_IO1_2P IO_L6P_T0_34 P14
PIN7 EX_IO1_3N IO_L7N_T1_34 Y17
PIN8 EX_IO1_3P IO_L7P_T1_34 Y16
PIN9 EX_IO1_4N IO_L10N_T1_34 W15
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 59 / 285
PIN10 EX_IO1_4P IO_L10P_T1_34 V15
PIN11 EX_IO1_5N IO_L8N_T1_34 Y14
PIN12 EX_IO1_5P IO_L8P_T1_34 W14
PIN13 EX_IO1_6N IO_L23N_T3_34 P18
PIN14 EX_IO1_6P IO_L23P_T3_34 N17
PIN15 EX_IO1_7N IO_L11N_T1_34 U15
PIN16 EX_IO1_7P IO_L11P_T1_34 U14
PIN17 EX_IO1_8N IO_L24N_T3_34 P16
PIN18 EX_IO1_8P IO_L24P_T3_34 P15
PIN19 EX_IO1_9N IO_L9N _T1_34 U17
PIN20 EX_IO1_9P IO_L9P_T1_34 T16
PIN21 EX_IO1_10N IO_L21_N_T3_34 V18
PIN22 EX_IO1_10P IO_L21_P_T3_34 V17
PIN23 EX_IO1_11N IO_L5N_T0_34 T15
PIN24 EX_IO1_11P IO_L5P_T0_34 T14
PIN25 EX_IO1_12N IO_L3N_T0_34 V13
PIN26 EX_IO1_12P IO_L3P_T0_34 U13
PIN27 EX_IO1_13N IO_L4N_T0_34 W13
PIN28 EX_IO1_13P IO_L4P_T0_34 V12
PIN29 EX_IO1_14N IO_L2N_T0_34 U12
PIN30 EX_IO1_14P IO_L2P_T0_34 T12
PIN31 EX_IO1_15N IO_L1N_T0_34 T10
PIN32 EX_IO1_15P IO_L1P_T0_34 T11
PIN33 EX_IO1_16N IO_L2N_T0_35 A20
PIN34 EX_IO1_16P IO_L2P_T0_35 B19
PIN35 EX_IO1_17N IO_L1N_T0_35 B20
PIN36 EX_IO1_17P IO_L1P_T0_35 C20
PIN37 GND - -
PIN38 GND - -
PIN39 +3.3V - -
PIN40 +3.3V - -
3.7.5 7.5 扩展口 J11
扩展口 J11 也为 40 管脚的 2.54mm 的双排连接器，为用户扩展更多的外设和接口，目前
ALINX 黑金提供的模块有：ADDA 模块，液晶屏模块，千兆以太网模块，音频输入输出模块，
矩阵键盘模块，500W 双目视觉摄像头模块。扩展口上包含 5V 电源 1 路，3.3V 电源 2 路，地 3
路，IO 口 34 路。IO 口的信号连接到 ZYNQ PL 的 BANK35 上，电平默认为 3.3V，扩展口 J11 的
全部 IO 可以通过更换开发板上电源芯片(SPX3819M5-3-3)改变 IO 的电平。切勿直接跟 5V 设备
直接连接，以免烧坏 FPGA。如果要接 5V 设备，需要接电平转换芯片。
在扩展口和 FPGA 连接之间串联了 33 欧姆的排阻，用于保护 FPGA 以免外界电压或电流过
高造成损坏，PCB 设计上 P 和 N 的走线使用差分走线，控制差分阻抗为 100 欧姆。扩展口(J11)
的电路如图 7-11 所示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 60 / 285
图 7-11 J11 扩展口原理图
图 7-12 为 J11 扩展口实物图，扩展口的 Pin1，Pin2 和 Pin39，Pin40 已经在板上标示出。
图 7-12 J11 扩展口实物图
J11 扩展口引脚分配
J11 管脚 信号名称 ZYNQ 引脚名 ZYNQ 引脚号
PIN1 GND - -
PIN2 +5V - -
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 61 / 285
PIN3 EX_IO2_1N IO_L6N_T0_35 F17
PIN4 EX_IO2_1P IO_L6P_T0_35 F16
PIN5 EX_IO2_2N IO_L15N_T2_35 F20
PIN6 EX_IO2_2P IO_L15P_T2_35 F19
PIN7 EX_IO2_3N IO_L18N_T2_35 G20
PIN8 EX_IO2_3P IO_L18P_T2_35 G19
PIN9 EX_IO2_4N IO_L14N_T2_35 H18
PIN10 EX_IO2_4P IO_L14P_T2_35 J18
PIN11 EX_IO2_5N IO_L9N_T1_35 L20
PIN12 EX_IO2_5P IO_L9P_T1_35 L19
PIN13 EX_IO2_6N IO_L7N_T1_35 M20
PIN14 EX_IO2_6P IO_L7P_T1_35 M19
PIN15 EX_IO2_7N IO_L12N_T1_35 K18
PIN16 EX_IO2_7P IO_L12P_T1_35 K17
PIN17 EX_IO2_8N IO_L10N_T1_35 J19
PIN18 EX_IO2_8P IO_L10P_T1_35 K19
PIN19 EX_IO2_9N IO_L17N_T2_35 H20
PIN20 EX_IO2_9P IO_L17P_T2_35 J20
PIN21 EX_IO2_10N IO_L11N_T1_35 L17
PIN22 EX_IO2_10P IO_L11P_T1_35 L16
PIN23 EX_IO2_11N IO_L8N_T1_35 M18
PIN24 EX_IO2_11P IO_L8P_T1_35 M17
PIN25 EX_IO2_12N IO_L4N_T0_35 D20
PIN26 EX_IO2_12P IO_L4P_T0_35 D19
PIN27 EX_IO2_13N IO_L5N_T0_35 E19
PIN28 EX_IO2_13P IO_L5P_T0_35 E18
PIN29 EX_IO2_14N IO_L16N_T2_35 G18
PIN30 EX_IO2_14P IO_L16P_T2_35 G17
PIN31 EX_IO2_15N IO_L13N_T2_35 H17
PIN32 EX_IO2_15P IO_L13P_T2_35 H16
PIN33 EX_IO2_16N IO_L19N_T3_35 G15
PIN34 EX_IO2_16P IO_L19P_T3_35 H15
PIN35 EX_IO2_17N IO_L20N_T3_35 J14
PIN36 EX_IO2_17P IO_L20P_T3_35 K14
PIN37 GND - -
PIN38 GND - -
PIN39 +3.3V - -
PIN40 +3.3V - -
3.7.6 7.6 用户 LED
AX7010 开发板的 PL 部分连接了 4 个 LED 发光二极管。4 个用户 LED 部分的原理图如图 6- 6-1，LED 灯的信号连接到 PL 部分 BANK35 的 IO 上。当 PL 部分 BANK35 的 IO 引脚输出为逻辑 0
时，LED 会被点亮，出为逻辑 1 时，LED 会被熄灭。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 62 / 285
图 7-13 PL 用户 LED 原理图
图 7-14 为这四个 LED 实物图
图 7-15 PL 用户 LED 实物图
PL 用户 LED 引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
LED1 IO_L23P_T3_35 M14 PL用户LED1灯
LED2 IO_L23N_T3_35 M15 PL用户LED2灯
LED3 IO_L24P_T3_35 K16 PL用户LED3灯
LED4 IO_L24N_T3_35 J16 PL用户LED4灯
3.7.7 7.7 用户按键
AX7010 开发板的 PL 部分板载了 4 个用户按键(KEY1~KEY4), 按键的信号连接到 ZYNQ 的
BANK34 和 BANK35 的 IO 上。按键都为低电平有效, 没有按下时，信号为高；按键按下时，信
号为低。4 个用户按键的原理图如图 7-16 所示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 63 / 285
图 7-16 个用户按键原理图
图 7-17 为连接到 PL 的 4 个用户按键实物图
图 7-17 4 个 PL 用户按键实物图
按键引脚分配：
信号名称 ZYNQ 引脚名 ZYNQ 引脚号 备注
KEY1 IO_L21P_T3_35 N15 PL用户按键1
KEY2 IO_L21N_T3_35 N16 PL用户按键2
KEY3 IO_L20P_T3_34 T17 PL用户按键3
KEY4 IO_L19N_T3_34 R17 PL用户按键4
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 64 / 285
第四章 Verilog 基础模块介绍
简介
本文主要介绍 verilog 基础模块，夯实基础，对深入学习 FPGA 会有很大帮助。
数据类型
4.2.1 常量
整数：整数可以用二进制 b 或 B，八进制 o 或 O，十进制 d 或 D，十六进制 h 或 H 表示，
例如， 8’b00001111 表示 8 位位宽的二进制整数，4’ha 表示 4 位位宽的十六进制整数。
X 和 Z：X 代表不定值，z 代表高阻值，例如，5’b00x11，第三位不定值，3’b00z 表示最低
位为高阻值。
下划线：在位数过长时可以用来分割位数，提高程序可读性，如 8’b0000_1111
参数 parameter: parameter 可以用标识符定义常量，运用时只使用标识符即可，提高可读
性及维护性，如定义 parameter width = 8 ; 定义寄存器 reg [width-1:0] a; 即定义了 8 位宽度的
寄存器。
参数的传递：在一个模块中如果有定义参数，在其他模块调用此模块时可以传递参数，并
可以修改参数，如下所示，在 module 后用#（）表示。
例如定义模块如下 
调用模块
module rom 
#(
 parameter depth =15,
 parameter width = 8 
 ）
 (
 input [depth-1:0] addr ,
input [width-1:0] data ,
output result 
) ;
endmodule
module top() ;
wire [31:0] addr ;
wire [15:0] data ;
wire result ;
rom 
#(
 .depth(32),
 .width(16) 
 )
r1 
(.addr(addr) , .data(data) , .result(result) ) ; 
endmodule
Parameter 可以用于模块间的参数传递，而 localparam 仅用于本模块内使用，不能用于参
数传递。Localparam 多用于状态机状态的定义。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 65 / 285
变量
变量是指程序运行时可以改变其值的量，下面主要介绍几个常用了变量类型。
1.1.1 Wire 型 Wire 类型变量，也叫网络类型变量，用于结构实体之间的物理连接，如门与门之间，不
能储存值，用连续赋值语句 assign 赋值，定义为 wire [n-1:0] a ; 其中 n 代表位宽，如定义 wire 
a ; assign a = b ; 是将 b 的结点连接到连线 a 上。如下图所示，两个实体之间的连线即是 wire 类
型变量。
1.1.2 Reg 型 Reg 类型变量，也称为寄存器变量，可用来储存值，必须在 always 语句里使用。其定义
为
reg [n-1:0] a ; 表示 n 位位宽的寄存器，如 reg [7:0] a; 表示定义 8 位位宽的寄存器 a。如
下所示定义了寄存器 q，生成的电路为时序逻辑，右图为其结构，为 D 触发器。
module top(d, clk, q) ;
input d ;
input clk ;
output reg q ;
always @(posedge clk)
begin
 q <= d ;
end 
endmodule
也可以生成组合逻辑，如数据选择器，敏感信号没有时钟，定义了 reg Mux，最终生成电
路为组合逻辑。
module top(a, b, c, d, sel, Mux) ;
input a ;
input b ;
input c ;
input d ;
input [1:0] sel ;
output reg Mux ;
always @(sel or a or b or c or d)
begin
 case(sel)
 2'b00 : Mux = a ;
 2'b01 : Mux = b ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 66 / 285
 2'b10 : Mux = c ;
 2'b11 : Mux = d ;
 endcase
end
 
endmodule
1.1.3 Memory 型
可以用 memory 类型来定义 RAM,ROM 等存储器，其结构为 reg [n-1:0] 存储器名[m-1:0]，
意义为 m 个 n 位宽度的寄存器。例如，reg [7:0] ram [255:0]表示定义了 256 个 8 位寄存器，
256 也即是存储器的深度，8 为数据宽度。
运算符
运算符可分为以下几类：
（1） 算术运算符（+，-，*，/，%） （2） 赋值运算符（=，<=） （3） 关系运算符（>，<，>=，<=，==，！=） （4） 逻辑运算符（&&，||，！）
（5） 条件运算符（？：）
（6） 位运算符（~，|，^，&，^~） （7） 移位运算符（<<，>>） （8） 拼接运算符（{ }）
4.4.1 算术运算符
“+”(加法运算符)，”-“（减法运算符），”*”(乘法运算符)，”/”（除法运算符，如 7/3 =2），
“%”（取模运算符，也即求余数，如 7%3=1，余数为 1）
4.4.2 赋值运算符
“=”阻塞赋值，”<=”非阻塞赋值。阻塞赋值为执行完一条赋值语句，再执行下一条，可理解
为顺序执行，而且赋值是立即执行；非阻塞赋值可理解为并行执行，不考虑顺序，在 always
块语句执行完成后，才进行赋值。如下面的阻塞赋值：
代码如下： 激励文件如下
module top(din,a,b,c,clk); `timescale 1 ns/1 ns 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 67 / 285
input din;
input clk;
output reg a,b,c;
always @(posedge clk) 
begin
 a = din;
 b = a;
 c = b;
end
endmodule
module top_tb() ;
reg din ;
reg clk ;
wire a,b,c ;
initial
begin
 din = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 din = ~din ;
 end
end
always #10 clk = ~clk ;
top 
t0(.din(din),.a(a),.b(b),.c(c),.clk(clk)) ;
endmodule
可以从仿真结果看到，在 clk 的上升沿，a 的值等于 din，并立即赋给 b，b 的值赋给 c。
如果改为非阻塞赋值，仿真结果如下，在 clk 上升沿，a 的值没有立即赋值给 b，b 为 a 原
来的值，同样，c 为 b 原来的值
可以从两者的 RTL 图看出明显不同：
 
阻塞赋值 RTL 图 非阻塞赋值 RTL 图
一般情况下，在时序逻辑电路中使用非阻塞赋值，可避免仿真时出现竞争冒险现象；在组
合逻辑中使用阻塞赋值，执行赋值语句后立即改变；在 assign 语句中必须用阻塞赋值。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 68 / 285
4.4.3 关系运算符
用于表示两个操作数之间的关系，如 a>b，a<b，多用于判断条件，例如：
If (a>=b) q <=1’b1 ;
else q <= 1’b0 ;
表示如果 a 的值大于等于 b 的值，则 q 的值为 1，否则 q 的值为 0
4.4.4 逻辑运算符
“&&”（两个操作数逻辑与），”||”（两个操作数逻辑或），”!”（单个操作数逻辑非）例如：
If (a>b && c <d) 表示条件为 a>b 并且 c<d; if (!a)表示条件为 a 的值不为 1，也就是 0。
4.4.5 条件运算符
“?:”为条件判断，类似于 if else，例如 assign a = (i>8)?1’b1:1’b0 ;判断 i 的值是否大于 8，如
果大于 8 则 a 的值为 1，否则为 0。
4.4.6 位运算符
“~”按位取反，”|”按位或，”^”按位异或，”&”按位与，”^”按位同或，除了”~”只需要一个
操作数外，其他几个都需要两个操作数，如 a&b，a|b。具体应用在后面的组合逻辑一节中有
讲解。
4.4.7 移位运算符
“<<”左移位运算符，”>>”右移位运算符，如 a<<1 表示，向左移 1 位，a>>2，向右移两位。
4.4.8 拼接运算符
“{ }”拼接运算符，将多个信号按位拼接，如{a[3:0], b[1:0]}，将 a 的低 4 位，b 的低 2 位拼接
成 6 位数据。另外，{n{a[3:0]}}表示将 n 个 a[3:0]拼接，{n{1’b0}}表示 n 位的 0 拼接。如{8{1’b0}}
表示为 8’b0000_0000.
4.4.9 优先级别
各种运算符的优先级别如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 69 / 285
组合逻辑
本节主要介绍组合逻辑，组合逻辑电路的特点是任意时刻的输出仅仅取决于输入信号，输
入信号变化，输出立即变化，不依赖于时钟。
4.5.1 与门
在 verilog 中以“&”表示按位与，如 c=a&b，真值表如下，在 a 和 b 都等于 1 时结果才为
1，RTL 表示如右图
 
代码实现如下： 激励文件如下：
module top(a, b, c) ;
input a ;
input b ;
output c ;
assign c = a & b ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
wire c ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 70 / 285
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
end
top t0(.a(a), .b(b),.c(c)) ;
endmodule
仿真结果如下：
如果 a 和 b 的位宽大于 1，例如定义 input [3:0] a, input [3:0]b，那么 a&b 则指 a 与 b 的对
应位相与。如 a[0]&b[0],a[1]&b[1]。
4.5.2 或门
在 verilog 中以“|”表示按位或，如 c = a|b , 真值表如下，在 a 和 b 都为 0 时结果才为
0。
 
代码实现如下： 激励文件如下
module top(a, b, c) ;
input a ;
input b ;
output c ;
assign c = a | b ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
wire c ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 71 / 285
top t0(.a(a), .b(b),.c(c)) ;
endmodule
仿真结果如下：
同理，位宽大于 1，则是按位或。
4.5.3 非门
在 verilog 中以“~”表示按位取反，如 b=~a，真值表如下，b 等于 a 的相反数。
 
代码实现如下： 激励文件如下：
module top(a, b) ;
input a ;
output b ;
assign b = ~a ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
wire b ;
initial
begin
 a = 0 ; 
 forever
 begin 
 #({$random}%100)
 a = ~a ; 
 end
end
top t0(.a(a), .b(b)) ;
endmodule
仿真结果如如下：
4.5.4 异或
在 verilog 中以“^”表示异或，如 c= a^b ，真值表如下，当 a 和 b 相同时，输出为 0。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 72 / 285
 
代码实现如下： 激励文件如下：
module top(a, b, c) ;
input a ;
input b ;
output c ;
assign c = a ^ b ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
wire c ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
end
top t0(.a(a), .b(b),.c(c)) ;
endmodule
仿真结果如下：
4.5.5 比较器
在 verilog 中以大于“>”，等于”==”，小于”<”，大于等于”>=”，小于等于”<=”，不等于”!=”
表示，以大于举例，如 c= a > b ;表示如果 a 大于 b，那么 c 的值就为 1，否则为 0。真值表如
下：
代码实现如下： 激励文件如下：
module top(a, b, c) ; `timescale 1 ns/1 ns 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 73 / 285
input a ;
input b ;
output c ;
assign c = a > b ;
endmodule
module top_tb() ;
reg a ;
reg b ;
wire c ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
end
top t0(.a(a), .b(b),.c(c)) ;
endmodule
仿真结果如下：
4.5.6 半加器
半加器和全加器是算术运算电路中的基本单元，由于半加器不考虑从低位来的进位，所以
称之为半加器，sum 表示相加结果，count 表示进位，真值表可表示如下：
可根据真值表写出代码如下： 激励文件如下：
module top(a, b, sum, count) ;
input a ;
input b ;
output sum ;
output count ;
assign sum = a ^ b ;
assign count = a & b ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
wire sum ;
wire count ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 74 / 285
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
 end
top t0(.a(a), .b(b),
.sum(sum), .count(count)) ;
endmodule
仿真结果如下：
4.5.7 全加器
而全加器需要加上低位来的进位信号 cin，真值表如下：
代码如下： 激励文件如下：
module top(cin, a, b, sum, count) ;
input cin ;
input a ;
input b ;
output sum ;
output count ;
assign {count,sum} = a + b + cin ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
reg cin ;
wire sum ;
wire count ;
initial
begin
 a = 0 ;
 b = 0 ;
 cin = 0 ;
 forever
 begin 
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
b = ~b ; 
#({$random}%100) 
 cin = ~cin ; 
 end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 75 / 285
end
top t0(.cin(cin),.a(a), .b(b),
.sum(sum), .count(count)) ;
endmodule
仿真结果如下：
4.5.8 乘法器
乘法的表示也很简单，利用”*”即可，如 a*b，举例代码如下：
module top(a, b, c) ;
input [1:0] a ;
input [1:0] b ;
output [3:0] c ;
assign c = a * b ;
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg [1:0] a ;
reg [1:0] b ;
wire [3:0] c ;
initial
begin
 a = 0 ;
 b = 0 ;
 forever
 begin 
 #({$random}%100)
 a = ~a ;
 #({$random}%100) 
 b = ~b ; 
 end
end
top t0(.a(a), .b(b),.c(c)) ;
endmodule
仿真结果如下：
4.5.9 数据选择器
在 verilog 中经常会用到数据选择器，通过选择信号，选择不同的输入信号输出到输出
端，如下图真值表，四选一数据选择器，sel[1:0]为选择信号，a,b,c,d 为输入信号，Mux 为输出
信号。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 76 / 285
代码如下： 激励文件如下：
module top(a, b, c, d, sel, Mux) ;
input a ;
input b ;
input c ;
input d ;
input [1:0] sel ;
output reg Mux ;
always @(sel or a or b or c or d)
begin
 case(sel)
 2'b00 : Mux = a ;
 2'b01 : Mux = b ;
 2'b10 : Mux = c ;
 2'b11 : Mux = d ;
 endcase
end
 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg a ;
reg b ;
reg c ;
reg d ;
reg [1:0] sel ;
wire Mux ;
initial
begin
 a = 0 ;
 b = 0 ;
 c = 0 ;
 d = 0 ;
 forever
 begin 
 #({$random}%100)
 a = {$random}%3 ;
 #({$random}%100) 
 b = {$random}%3 ;
 #({$random}%100)
 c = {$random}%3 ;
 #({$random}%100) 
 d = {$random}%3 ;
 end
 end
initial
begin
 sel = 2'b00 ;
 #2000 sel = 2'b01 ;
 #2000 sel = 2'b10 ;
 #2000 sel = 2'b11 ;
end
top 
t0(.a(a), .b(b),.c(c),.d(d), .sel(se
l),
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 77 / 285
.Mux(Mux)) ;
endmodule
仿真结果如下
4.5.10 3-8 译码器
3-8 译码器是一个很常用的器件，其真值表如下所示，根据 A2,A1,A0 的值，得出不同的结
果。
代码如下： 激励文件如下：
module top(addr, decoder) ;
input [2:0] addr ;
output reg [7:0] decoder ;
always @(addr)
begin
 case(addr)
 3'b000 : decoder =
`timescale 1 ns/1 ns 
module top_tb() ;
reg [2:0] addr ;
wire [7:0] decoder ; 
initial
begin
 addr = 3'b000 ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 78 / 285
8'b1111_1110 ;
 3'b001 : decoder =
8'b1111_1101 ;
 3'b010 : decoder =
8'b1111_1011 ;
 3'b011 : decoder =
8'b1111_0111 ;
 3'b100 : decoder =
8'b1110_1111 ;
 3'b101 : decoder =
8'b1101_1111 ;
 3'b110 : decoder =
8'b1011_1111 ;
 3'b111 : decoder =
8'b0111_1111 ; 
 endcase
end
 
endmodule
 #2000 addr = 3'b001 ;
 #2000 addr = 3'b010 ;
 #2000 addr = 3'b011 ;
 #2000 addr = 3'b100 ;
 #2000 addr = 3'b101 ;
 #2000 addr = 3'b110 ;
 #2000 addr = 3'b111 ;
end
top 
t0(.addr(addr),.decoder(decoder)) ;
endmodule
仿真结果如下：
4.5.11 三态门
在 FPGA 使用中，经常会用到双向 IO，需要用到三态门，如 bio = en? din: 1’bz ;其中 en 为
使能信号，用于打开关闭三态门，下面的 RTL 图即是实现了双向 IO，可参考代码。激励文件实
现两个双向 IO 的对接。
module top(en, din, dout, bio) ;
input din ;
input en ;
output dout ;
inout bio ;
assign bio = en? din : 1'bz ;
assign dout = bio ;
 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg en0 ;
reg din0 ;
wire dout0 ;
reg en1 ;
reg din1 ;
wire dout1 ;
wire bio ;
initial
begin
 din0 = 0 ;
 din1 = 0 ;
 forever
 begin 
 #({$random}%100)
 din0 = ~din0 ;
 #({$random}%100) 
din1 = ~din1 ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 79 / 285
 end
end
initial
begin
 en0 = 0 ;
 en1 = 1 ;
 #100000 
 en0 = 1 ;
 en1 = 0 ; 
end
top 
t0(.en(en0),.din(din0),.dout(dout0),
.bi
o(bio)) ;
top 
t1(.en(en1),.din(din1),.dout(dout1),
.bi
o(bio)) ;
endmodule
激励文件结构如下图
仿真结果如下，en0 为 0，en1 为 1 时，1 通道打开，双向 IO bio 就等于 1 通道的 din1，1
通道向外发送数据，0 通道接收数据，dout0 等于 bio；当 en0 为 1，en1 为 0 时，0 通道打
开，双向 IO bio 就等于 0 通道的 din0，0 通道向外发送数据，1 通道接收数据，dout1 等于 bio
时序逻辑
组合逻辑电路在逻辑功能上特点是任意时刻的输出仅仅取决于当前时刻的输入，与电路原
来的状态无关。而时序逻辑在逻辑功能上的特点是任意时刻的输出不仅仅取决于当前的输入信
号，而且还取决于电路原来的状态。下面以典型的时序逻辑分析。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 80 / 285
4.6.1 D 触发器
D 触发器在时钟的上升沿或下降沿存储数据，输出与时钟跳变之前输入信号的状态相同。
代码如下 激励文件如下
module top(d, clk, q) ;
input d ;
input clk ;
output reg q ;
always @(posedge clk)
begin
 q <= d ;
end
 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg d ;
reg clk ;
wire q ;
initial
begin
 d = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 d = ~d ;
 end
end
always #10 clk = ~clk ;
top t0(.d(d),.clk(clk),.q(q)) ;
endmodule
RTL 图表示如下
仿真结果如下，可以看到在 t0 时刻时，d 的值为 0，则 q 的值也为 0；在 t1 时刻 d 发生了
变化，值为 1，那么 q 相应也发生了变化，值变为 1。可以看到在 t0-t1 之间的一个时钟周期
内，无论输入信号 d 的值如何变化，q 的值是保持不变的，也就是有存储的功能，保存的值为
在时钟的跳变沿时 d 的值。
4.6.2 两级 D 触发器
软件是按照两级 D 触发器的模型进行时序分析的，具体可以分析在同一时刻两个 D 触发
器输出的数据有何不同，其 RTL 图如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 81 / 285
代码如下： 激励文件如下：
module top(d, clk, q, q1) ;
input d ;
input clk ;
output reg q ;
output reg q1 ;
always @(posedge clk)
begin
 q <= d ;
end
always @(posedge clk)
begin
 q1 <= q ;
end
 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg d ;
reg clk ;
wire q ;
wire q1 ;
initial
begin
 d = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 d = ~d ;
 end
end
always #10 clk = ~clk ;
top 
t0(.d(d),.clk(clk),.q(q),.q1(q1)) ;
endmodule
仿真结果如下，可以看到 t0 时刻，d 为 0，q 输出为 0，t1 时刻，q 随着 d 的数据变化而
变化，而此时钟跳变之前 q 的值仍为 0，那么 q1 的值仍为 0，t2 时刻，时钟跳变前 q 的值为
1，则 q1 的值相应为 1，q1 相对于 q 落后一个周期。
4.6.3 带异步复位的 D 触发器
异步复位是指独立于时钟，一旦异步复位信号有效，就触发复位操作。这个功能在写代码
时会经常用到，用于给信号复位，初始化。其 RTL 图如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 82 / 285
代码如下，注意要把异步复位信号放在敏感列表里，如果是低电平复位，即为 negedge，
如果是高电平复位，则是 posedge
module top(d, rst, clk, q) ;
input d ;
input rst ;
input clk ; output reg q ;
always @(posedge clk or negedge
rst)
begin
 if (rst == 1'b0)
 q <= 0 ;
 else
 q <= d ;
end
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg d ;
reg rst ;
reg clk ;
wire q ;
initial
begin
 d = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 d = ~d ;
 end
end
initial
begin
 rst = 0 ;
 #200 rst = 1 ;
end
always #10 clk = ~clk ;
top 
t0(.d(d),.rst(rst),.clk(clk),.q(q))
;
endmodule
仿真结果如下，可以看到在复位信号之前，虽然输入信号 d 数据有变化，但由于正处于复
位状态，输入信号 q 始终为 0，在复位之后 q 的值就正常了。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 83 / 285
4.6.4 带异步复位同步清零的 D 触发器
前面讲到异步复位独立于时钟操作，而同步清零则是同步于时钟信号下操作的，当然也不
仅限于同步清零，也可以是其他的同步操作，其 RTL 图如下：
代码如下，不同于异步复位，同步操作不能把信号放到敏感列表里
module top(d, rst, clr, clk, q) ;
input d ;
input rst ;
input clr ;
input clk ;
output reg q ;
always @(posedge clk or negedge
rst)
begin
 if (rst == 1'b0)
 q <= 0 ;
 else if (clr == 1'b1)
 q <= 0 ;
 else
 q <= d ;
end
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg d ;
reg rst ;
reg clr ;
reg clk ;
wire q ;
initial
begin
 d = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 d = ~d ;
 end
end
initial
begin
 rst = 0 ;
 clr = 0 ;
 #200 rst = 1 ;
 #200 clr = 1 ;
 #100 clr = 0 ;
end
always #10 clk = ~clk ;
top 
t0(.d(d),.rst(rst),.clr(clr),.clk(cl
k),
.q(q)) ;
endmodule
仿真结果如下，可以看到 clr 信号拉高后，q 没有立即清零，而是在下个 clk 上升沿之后执
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 84 / 285
行清零操作，也就是 clr 同步于 clk。
4.6.5 移位寄存器
移位寄存器是指在每个时钟脉冲来时，向左或向右移动一位，由于 D 触发器的特性，数据
输出同步于时钟边沿，其结构如下，每个时钟来临，每个 D 触发器的输出 q 等于前一个 D 触
发器输出的值，从而实现移位的功能。
代码实现： 激励文件：
module top(d, rst, clk, q) ;
input d ;
input rst ;
input clk ;
output reg [7:0] q ;
always @(posedge clk or negedge
rst)
begin
 if (rst == 1'b0)
 q <= 0 ;
 else
 q <= {q[6:0], d} ; //向左移位
 //q <= {d, q[7:1]} ; //向右移位
end
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg d ;
reg rst ;
reg clk ;
wire [7:0] q ;
initial
begin
 d = 0 ;
 clk = 0 ;
 forever
 begin 
 #({$random}%100)
 d = ~d ;
 end
end
initial
begin
 rst = 0 ;
 #200 rst = 1 ;
end
always #10 clk = ~clk ;
top 
t0(.d(d),.rst(rst),.clk(clk),.q(q))
;
endmodule
仿真结果如下，可以看到复位之后，每个 clk 上升沿左移一位
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 85 / 285
4.6.6 单口 RAM
单口 RAM 的写地址与读地址共用一个地址，代码如下，其中 reg [7:0] ram [63:0]意思是定
义了 64 个 8 位宽度的数据。其中定义了 addr_reg，可以保持住读地址，延迟一周期之后将数
据送出。
module top 
(
 input [7:0] data,
 input [5:0] addr,
 input wr,
 input clk,
 output [7:0] q 
);
reg [7:0] ram[63:0]; //declare ram 
reg [5:0] addr_reg; //addr 
register 
always @ (posedge clk)
begin
 if (wr) //write 
 ram[addr] <= data;
 
 addr_reg <= addr;
end
assign q = ram[addr_reg]; //read 
data 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg [7:0] data ; 
reg [5:0] addr ; 
reg wr ;
reg clk ;
wire [7:0] q ;
initial
begin
 data = 0 ;
 addr = 0 ;
 wr = 1 ;
 clk = 0 ;
 end
always #10 clk = ~clk ;
always @(posedge clk)
begin
 data <= data + 1'b1 ;
 addr <= addr + 1'b1 ;
end
top t0(.data(data),
 .addr(addr),
 .clk(clk),
 .wr(wr),
 .q(q)) ;
endmodule
仿真结果如下，可以看到 q 的输出与写入的数据一致
4.6.7 伪双口 RAM
伪双口 RAM 的读写地址是独立的，可以随机选择写或读地址，同时进行读写操作。代码
如下，在激励文件中定义了 en 信号，在其有效时发送读地址。
module top 
(
 input [7:0] data,
 input [5:0] write_addr,
`timescale 1 ns/1 ns 
module top_tb() ;
reg [7:0] data ; 
reg [5:0] write_addr ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 86 / 285
 input [5:0] read_addr, 
 input wr,
 input rd,
 input clk,
 output reg [7:0] q 
);
reg [7:0] ram[63:0]; //declare ram 
reg [5:0] addr_reg; //addr 
register 
always @ (posedge clk)
begin
 if (wr) //write 
 ram[write_addr] <= data;
 if (rd) //read 
 q <= ram[read_addr];
end
endmodule
reg [5:0] read_addr ; 
reg wr ;
reg clk ;
reg rd ;
wire [7:0] q ;
initial
begin
 data = 0 ;
 write_addr = 0 ;
 read_addr = 0 ;
 wr = 0 ;
 rd = 0 ;
 clk = 0 ;
 #100 wr = 1 ;
 #20 rd = 1 ;
end
always #10 clk = ~clk ;
always @(posedge clk)
begin
 if (wr)
 begin
 data <= data + 1'b1 ;
 write_addr <= write_addr +
1'b1 ;
 if (rd) 
 read_addr <= read_addr +
1'b1 ;
 end
end
top t0(.data(data),
 .write_addr(write_addr),
 .read_addr(read_addr),
 .clk(clk),
 .wr(wr),
 .rd(rd),
 .q(q)) ;
endmodule
仿真结果如下，可以看到在 rd 有效时，对读地址进行操作，读出数据
4.6.8 真双口 RAM
真双口 RAM 有两套控制线，数据线，允许两个系统对其进行读写操作，代码如下：
module top 
(
 input [7:0] data_a, data_b,
 input [5:0] addr_a, addr_b,
 input wr_a, wr_b,
 input rd_a, rd_b,
 input clk,
`timescale 1 ns/1 ns 
module top_tb() ;
reg [7:0] data_a, data_b ;
reg [5:0] addr_a, addr_b ;
reg wr_a, wr_b ;
reg rd_a, rd_b ; 
reg clk ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 87 / 285
 output reg [7:0] q_a, q_b 
);
reg [7:0] ram[63:0]; //declare ram 
//Port A 
always @ (posedge clk)
begin
 if (wr_a) //write 
 begin
 ram[addr_a] <= data_a;
 q_a <= data_a ;
 end
 if (rd_a) 
//read 
 q_a <= ram[addr_a];
end
//Port B 
always @ (posedge clk)
begin
 if (wr_b) //write 
 begin
 ram[addr_b] <= data_b;
 q_b <= data_b ;
 end
 if (rd_b) 
//read 
 q_b <= ram[addr_b];
end
endmodule
wire [7:0] q_a, q_b ;
initial
begin
 data_a = 0 ;
 data_b = 0 ;
 addr_a = 0 ;
 addr_b = 0 ;
 wr_a = 0 ;
 wr_b = 0 ;
 rd_a = 0 ;
 rd_b = 0 ;
 clk = 0 ;
 #100 wr_a = 1 ;
 #100 rd_b = 1 ;
end
always #10 clk = ~clk ;
always @(posedge clk)
begin
 if (wr_a)
 begin
 data_a <= data_a + 1'b1 ;
 addr_a <= addr_a + 1'b1 ;
 end
 else 
begin
 data_a <= 0 ;
 addr_a <= 0 ;
 end
end
always @(posedge clk)
begin
 if (rd_b)
 begin
 addr_b <= addr_b + 1'b1 ; 
 end
 else addr_b <= 0 ;
end
top 
t0(.data_a(data_a), .data_b(data_b),
 .addr_a(addr_a), .addr_b(addr
_b
),
 .wr_a(wr_a), .wr_b(wr_b),
 .rd_a(rd_a), .rd_b(rd_b),
 .clk(clk), 
 .q_a(q_a), .q_b(q_b)) ;
endmodule
仿真结果如下
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 88 / 285
4.6.9 单口 ROM
ROM 是用来存储数据的，可以按照下列代码形式初始化 ROM，但这种方法处理大容量的
ROM 就比较麻烦，建议用 FPGA 自带的 ROM IP 核实现，并添加初始化文件。
代码实现 激励文件
module top
(
 input [3:0] addr,
 input clk,
 output reg [7:0] q 
);
always @(posedge clk)
begin
 case(addr)
 4'd0 : q <= 8'd15 ;
 4'd1 : q <= 8'd24 ;
 4'd2 : q <= 8'd100 ;
 4'd3 : q <= 8'd78 ;
 4'd4 : q <= 8'd98 ;
 4'd5 : q <= 8'd105 ;
 4'd6 : q <= 8'd86 ;
 4'd7 : q <= 8'd254 ;
 4'd8 : q <= 8'd76 ;
 4'd9 : q <= 8'd35 ;
 4'd10 : q <= 8'd120 ;
 4'd11 : q <= 8'd85 ;
 4'd12 : q <= 8'd37 ;
 4'd13 : q <= 8'd19 ;
 4'd14 : q <= 8'd22 ;
 4'd15 : q <= 8'd67 ;
 default: q <= 8'd0 ;
 endcase
end 
endmodule
`timescale 1 ns/1 ns 
module top_tb() ;
reg [3:0] addr ;
reg clk ;
wire [7:0] q ;
initial
begin
 addr = 0 ;
 clk = 0 ;
end
always #10 clk = ~clk ;
always @(posedge clk)
begin
 addr <= addr + 1'b1 ;
end
top t0(.addr(addr),
 .clk(clk),
 .q(q)) ;
endmodule
仿真结果如下
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 89 / 285
4.6.10 有限状态机
在 verilog 里经常会用到有限状态机，处理相对复杂的逻辑，设定好不同的状态，根据触
发条件跳转到对应的状态，在不同的状态下做相应的处理。有限状态机主要用到 always 及
case 语句。下面以一个四状态的有限状态机举例说明。
在程序中设计了 8 位的移位寄存器，在 Idle 状态下，判断 shift_start 信号是否为高，如果
为高，进入 Start 状态，在 Start 状态延迟 100 个周期，进入 Run 状态，进行移位处理，如果
shift_stop 信号有效了，进入 Stop 状态，在 Stop 状态，清零 q 的值，再跳转到 Idle 状态。
Mealy 有限状态机，输出不仅与当前状态有关，也与输入信号有关，在 RTL 中会与输入信
号有连接。
module top 
(
 input shift_start,
 input shift_stop,
 input rst,
 input clk,
 input d,
 output reg [7:0] q 
);
parameter Idle = 2'd0 ; //Idle state 
parameter Start = 2'd1 ; //Start state 
parameter Run = 2'd2 ; //Run state 
parameter Stop = 2'd3 ; //Stop state 
 
reg [1:0] state ; //statement 
reg [4:0] delay_cnt ; //delay counter 
always @(posedge clk or negedge rst)
begin
 if (!rst)
 begin
 state <= Idle ;
 delay_cnt <= 0 ;
 q <= 0 ;
 end
 else
 case(state)
 Idle : begin
 if (shift_start)
 state <= Start ;
 end
 Start : begin
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 90 / 285
 if (delay_cnt == 5'd99)
 begin
 delay_cnt <= 0 ;
 state <= Run ;
 end
 else
 delay_cnt <= delay_cnt + 1'b1 ;
 end
 Run : begin
 if (shift_stop)
 state <= Stop ;
 else
 q <= {q[6:0], d} ;
 end
 Stop : begin
 q <= 0 ;
 state <= Idle ;
 end
 default: state <= Idle ;
 endcase
end 
endmodule
Moore 有限状态机，输出只与当前状态有关，与输入信号无关，输入信号只影响状态的改
变，不影响输出，比如对 delay_cnt 和 q 的处理，只与 state 状态有关。
module top 
(
 input shift_start,
 input shift_stop,
 input rst,
 input clk,
 input d,
 output reg [7:0] q 
);
parameter Idle = 2'd0 ; //Idle state 
parameter Start = 2'd1 ; //Start state 
parameter Run = 2'd2 ; //Run state 
parameter Stop = 2'd3 ; //Stop state 
 
reg [1:0] current_state ; //statement 
reg [1:0] next_state ;
reg [4:0] delay_cnt ; //delay counter 
//First part: statement transition 
always @(posedge clk or negedge rst)
begin
 if (!rst)
 current_state <= Idle ;
 else
 current_state <= next_state ;
end
//Second part: combination logic, judge statement transition 
condition 
always @(*)
begin
 case(current_state)
 Idle : begin
 if (shift_start)
 next_state <= Start ;
 else
 next_state <= Idle ;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 91 / 285
 end
 Start : begin
 if (delay_cnt == 5'd99)
 next_state <= Run ;
 else
 next_state <= Start ;
 end
 Run : begin
 if (shift_stop)
 next_state <= Stop ;
 else
 next_state <= Run ;
 end
 Stop : next_state <= Idle ;
 default: next_state <= Idle ;
 endcase
end
//Last part: output data 
always @(posedge clk or negedge rst)
begin
 if (!rst)
 delay_cnt <= 0 ;
 else if (current_state == Start)
 delay_cnt <= delay_cnt + 1'b1 ;
 else
 delay_cnt <= 0 ;
end
always @(posedge clk or negedge rst)
begin
 if (!rst)
 q <= 0 ;
 else if (current_state == Run)
 q <= {q[6:0], d} ;
 else
 q <= 0 ;
end 
 
endmodule
在上面两个程序中用到了两种方式的写法，第一种的 Mealy 状态机，采用了一段式的写
法，只用了一个 always 语句，所有的状态转移，判断状态转移条件，数据输出都在一个 always
语句里，缺点是如果状态太多，会使整段程序显的冗长。第二个 Moore 状态机，采用了三段
式的写法，状态转移用了一个 always 语句，判断状态转移条件是组合逻辑，采用了一个 always
语句，数据输出也是单独的 always 语句，这样写起来比较直观清晰，状态很多时也不会显得
繁琐。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 92 / 285
Mealy 有限状态机 RTL 图
Moore 有限状态机 RTL 图
激励文件如下：
`timescale 1 ns/1 ns 
module top_tb() ;
reg shift_start ;
reg shift_stop ;
reg rst ;
reg clk ;
reg d ;
wire [7:0] q ;
initial
begin
 rst = 0 ; 
 clk = 0 ;
 d = 0 ;
 #200 rst = 1 ;
 forever
 begin
 #({$random}%100)
 d = ~d ;
 end
end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 93 / 285
initial
begin
 shift_start = 0 ;
 shift_stop = 0 ;
 #300 shift_start = 1 ;
 #1000 shift_start = 0 ;
 shift_stop = 1 ;
 #50 shift_stop = 0 ;
end
always #10 clk = ~clk ;
top t0 
(
 .shift_start(shift_start),
 .shift_stop(shift_stop),
 .rst(rst),
 .clk(clk),
 .d(d),
 .q(q) 
);
endmodule
仿真结果如下：
总结
本文档介绍了组合逻辑以及时序逻辑中常用的模块，其中有限状态机较为复杂，但经常用
到，希望大家能够深入理解，在代码中多运用，多思考，有利于快速提升水平。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 94 / 285
第五章 PL 的"Hello World"LED 实验
实验 Vivado 工程为“led”。
对于 ZYNQ 来说 PL（FPGA）开发是至关重要的，这也是 ZYNQ 比其他 ARM 的有优势的地
方，可以定制化很多 ARM 端的外设，在定制 ARM 端的外设之前先让我们通过一个 LED 例程来
熟悉 PL（FPGA）的开发流程，熟悉 Vivado 软件的基本操作，这个开发流程和不带 ARM 的
FPGA 芯片完全一致。
在本例程中，我们要做的是 LED 灯控制实验，每秒钟控制开发板上的 LED 灯翻转一次，实
现亮、灭、亮、灭的控制。会控制 LED 灯，其它外设也慢慢就会了。
LED 硬件介绍
1) 开发板的 PL 部分连接了 4 个红色的用户 LED 灯。这 4 个灯完全由 PL 控制。
2) 我们可以根据原理图的连线关系确定 LED 和 PL 管脚的绑定关系。
对应的管脚信息
3) 原理图中以 PS_MIO 开头的 IO 都是 PS 端 IO，不需要绑定，也不能绑定
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 95 / 285
创建 Vivado 工程
1) 启动 Vivado，在 Windows 中可以通过双击 Vivado 快捷方式启动
2) 在 Vivado 开发环境里点击“Create New Project”，创建一个新的工程。
3) 弹出一个建立新工程的向导，点击“Next”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 96 / 285
4) 在弹出的对话框中输入工程名和工程存放的目录，我们这里取一个 led 的工程名。需要注
意工程路径“Project location”不能有中文空格，路径名称也不能太长。
5) 在工程类型中选择“RTL Project”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 97 / 285
6) 目标语言“Target language”选择“Verilog”，虽然选择 Verilog，但 VHDL 也可以使用，支
持多语言混合编程。
7) 点击“Next”，不添加任何文件
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 98 / 285
8) 在“Part”选项中，器件家族“Family”选择“Zynq-7000”，AX7020 开发板封装类型
“Package”选择“clg400”,Speed 选择”-2”减少选择范围。在下拉列表中选择
“xc7z020clg400-2”,“-2”表示速率等级，数字越大，性能越好，速率高的芯片向下兼容
速率低的芯片。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 99 / 285
AX7010 开发板选择型号“xc7z010clg400-1”
9) 点击“Finish”就可以完成以后名为“led”工程的创建。
10) Vivado 软件界面
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 100 / 285
创建 Verilog HDL 文件点亮 LED
1) 点击 Project Manager 下的 Add Sources 图标（或者使用快捷键 Alt+A）
2) 选择添加或创建设计源文件“Add or create design sources”,点击“Next”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 101 / 285
3) 选择创建文件“Create File”
4) 文件名“File name”设置为“led”，点击“OK”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 102 / 285
5) 点击“Finish”,完成“led.v”文件添加
6) 在弹出的模块定义“Define Module”,中可以指定“led.v”文件的模块名称“Module 
name”,这里默认不变为“led”，还可以指定一些端口，这里暂时不指定，点击“OK”。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 103 / 285
7) 在弹出的对话框中选择“Yes”
8) 双击“led.v”可以打开文件，然后编辑
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 104 / 285
9) 编写“led.v”,这里定义了一个 32 位的寄存器 timer, 用于循环计数 0~49999999(1 秒钟), 
计数到 49999999(1 秒)的时候, 寄存器 timer 变为 0，并翻转四个 LED。这样原来 LED 是灭
的话，就会点亮，如果原来 LED 为亮的话，就会熄灭。编写好后的代码如下：
module led(
 input sys_clk,
 input rst_n,
 output reg [3:0] led
 );
reg[31:0] timer_cnt;
always@(posedge sys_clk or negedge rst_n)
begin
 if (!rst_n)
 begin
 led <= 4'd0 ;
 timer_cnt <= 32'd0 ;
 end
 else if(timer_cnt >= 32'd49_999_999)
 begin
 led <= ~led;
 timer_cnt <= 32'd0;
 end
 else
 begin
 led <= led;
 timer_cnt <= timer_cnt + 32'd1;
 end
 
end
endmodule
10) 编写好代码后保存
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 105 / 285
添加管脚约束
Vivado 使用的约束文件格式为 xdc 文件。xdc 文件里主要是完成管脚的约束,时钟的约束, 
以及组的约束。这里我们需要对 led.v 程序中的输入输出端口分配到 FPGA 的真实管脚上。
1) 点击“Open Elaborated Design”
2) 在弹出的窗口中点击“OK”按钮
3) 在菜单中选择“Window -> I/O Ports”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 106 / 285
4) 在弹出的 I/O Ports 中可以看到管脚分配情况
5) 将复位信号 rst_n 绑定到 PL 端的按键，给 LED 和时钟分配管脚、电平标准，完成后点击保
存图标
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 107 / 285
6) 弹出窗口，要求保存约束文件，文件名我们填写“led”，文件类型默认“XDC”，点击
“OK”
7) 打开刚才生成的“led.xdc”文件，我们可以看到是一个 TCL 脚本，如果我们了解这些语
法，完全可以通过自己编写 led.xdc 文件的方式来约束管脚
下面来介绍一下最基本的 XDC 编写的语法，普通 IO 口只需约束引脚号和电压，管脚约束
如下：
set_property PACKAGE_PIN "引脚编号" [get_ports “端口名称”] 
电平信号的约束如下：
set_property IOSTANDARD "电平标准" [get_ports “端口名称”] 
这里需要注意文字的大小写，端口名称是数组的话用{ }刮起来，端口名称必须和源代码中
的名字一致，且端口名字不能和关键字一样。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 108 / 285
电平标准中“LVCMOS33”后面的数字指 FPGA 的 BANK 电压，LED 所在 BANK 电压为 3.3
伏，所以电平标准为“LVCMOS33”。Vivado 默认要求为所有 IO 分配正确的电平标准和管脚编
号。
添加时序约束
一个 FPGA 设计除了管脚分配以外，还有一个重要的约束，那就是时序约束，这里通过向
导方式演示如果进行一个时序约束。
1) 点击“Run Synthesis”开始综合
2) 弹出对话框点击“OK”
3) 综合完成以后点击“Cancel”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 109 / 285
4) 点击“Constraints Wizard”
5) 在弹出的窗口中点击“Next”
6) 时序约束向导分析出设计中的时钟，这里把“sys_clk”频率设置为 50Mhz，然后点击
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 110 / 285
“Skip to Finish”结束时序约束向导。
7) 弹出的窗口中点击“OK”
8) 点击“Finish”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 111 / 285
9) 这个时候 led.xdc 文件已经更新，点击“Reload”重新加载文件，并保存文件
生成 BIT 文件
1) 编译的过程可以细分为综合、布局布线、生成 bit 文件等，这里我们直接点击“Generate 
Bitstream”,直接生成 bit 文件。
2) 在弹出的对话框中可以选择任务数量，这里和 CPU 核心数有关，一般数字越大，编译越
快，点击“OK”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 112 / 285
3) 这个时候开始编译，可以看到右上角有个状态信息，在编译过程中可能会被杀毒软件、电
脑管家拦截运行，导致无法编译或很长时间没有编译成功。
4) 编译中没有任何错误，编译完成，弹出一个对话框让我们选择后续操作，可以选择
“Open Hardware Manger”，当然，也可以选择“Cancel”，我们这里选择 “Cancel”，先不
下载。
Vivado 仿真
接下来我们不妨小试牛刀，利用 Vivado 自带的仿真工具来输出波形验证流水灯程序设计结
果和我们的预想是否一致（注意：在生成 bit 文件之前也可以仿真）。具体步骤如下：
1） 设置 Vivado 的仿真配置，右击 SIMULATION 中 Simulation Settings。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 113 / 285
2） 在 Simulation Settings 窗口中进行如下图来配置，这里设置成 50ms（根据需要自行设定）,
其它按默认设置，单击 OK 完成。
3） 添加激励测试文件，点击 Project Manager 下的 Add Sources 图标,按下图设置后单击 Next。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 114 / 285
4） 点击 Create File 生成仿真激励文件。
在弹出的对话框中输入激励文件的名字，这里我们输入名为 vtf_led_test。 5） 点击 Finish 按钮返回。
这里我们先不添加 IO Ports，点击 OK。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 115 / 285
 在 Simulation Sources 目录下多了一个刚才添加的 vtf_led_test 文件。双击打开这个文
件，可以看到里面只有 module 名的定义，其它都没有。
6） 接下去我们需要编写这个 vtf_led_test.v 文件的内容。首先定义输入和输出信号，然后需要
实例化 led_test 模块，让 led_test 程序作为本测试程序的一部分。再添加复位和时钟的激励。
完成后的 vtf_led_test.v 文件如下：
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////
////////////
// Module Name: vtf_led_test
//////////////////////////////////////////////////////////////////////
////////////
module vtf_led_test;
// Inputs
reg sys_clk;
reg rst_n ;
// Outputs
wire [3:0] led;
// Instantiate the Unit Under Test (UUT)
led uut (
 .sys_clk(sys_clk), 
 .rst_n(rst_n),
 .led(led)
);
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 116 / 285
initial
begin
// Initialize Inputs
 sys_clk = 0;
 rst_n = 0 ;
 #1000 ;
 rst_n = 1;
end
//Create clock
always #10 sys_clk = ~ sys_clk; 
endmodule
7) 编写好后保存，vtf_led_test.v 自动成了这个仿真 Hierarchy 的顶层了，它下面是设计文件
led_test.v。
8) 点击 Run Simulation 按钮，再选择 Run Behavioral Simulation。这里我们做一下行为级的仿
真就可以了。
 如果没有错误，Vivado 中的仿真软件开始工作了。
10. 在弹出仿真界面后如下图，界面是仿真软件自动运行到仿真设置的 50ms 的波形。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 117 / 285
由于 LED[3：0]在程序中设计的状态变化时间长，而仿真又比较耗时，在这里观测 timer[31:0]计
数器变化。把它放到Wave中观察(点击Scope界面下的uut，再右键选择Objects界面下的timer，
在弹出的下拉菜单里选择 Add Wave Window)。
 添加后 timer 显示在 Wave 的波形界面上，如下图所示。
11. 点击如下标注的 Restart 按钮复位一下，再点击 Run All 按钮。（需要耐心！！！），可以看到仿
真波形与设计相符。（注意：仿真的时间越长，仿真的波形文件占用的磁盘空间越大，波形文
件在工程目录的 xx.sim 文件夹）
我们可以看到 led 的信号会变成 F，说明 LED1~LED4 灯同时变亮。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 118 / 285
下载
1) 连接好开发板的 JTAG 接口，给开发板上电
2) 在“HARDWARE MANAGER”界面点击“Auto Connect”，自动连接设备
3) 可以看到 JTAG 扫描到 arm 和 FPGA 内核
4) 选择 xc7z020_1，右键“Program Device...”
5) 在弹出窗口中点击“Program”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 119 / 285
6) 等待下载
7) 下载完成以后，我们可以看到 4 颗 LED 开始每秒变化一次。到此为止 Vivado 简单流程体
验完成。后面的章节会介绍如果把程序烧录到 Flash，需要 PS 系统的配合才能完成，只有
PL 的工程不能直接烧写 Flash。在”体验 ARM，裸机输出”Hello World”一章的常见问题中有
介绍。
在线调试
前面介绍了仿真和下载，但仿真并不需要程序烧写到板子，是比较理想化的结果，下面介
绍 Vivado 在线调试方法，观察内部信号的变化。Vivado 有内嵌的逻辑分析仪，叫做 ILA，可以
用于在线观察内部信号的变化，对于调试有很大帮助。在本实验中我们观察 timer_cnt 和 led
的信号变化。
5.9.1 添加 ILA IP 核 1） 点击 IP Catalog，在搜索框中搜索 ila，双击 ILA 的 IP
2） 修改名称为 ila，由于要采样两个信号，Probes 的数量设置为 2，Sample Data Depth 指的是
采样深度，设置的越高，采集的信号越多，同样消耗的资源也会越多。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 120 / 285
3） 在 Probe_Ports 页面，设置 Probe 的宽度，设置 PROBE0 位宽为 32，用于采样 timer_cnt，
设置 PROBE1 位宽为 4，用于采样 led。点击 OK
弹出界面，选择 OK
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 121 / 285
再如下设置，点击 Generate
4） 在 led.v 中例化 ila，并保存
5） 重新生成 Bitstream
6） 下载程序
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 122 / 285
这时候看到有 bit 和 ltx 文件，点击 program
7） 此时弹出在线调试窗口，出现了我们添加的信号
点击运行按钮，出现信号的数据
也可以触发采集，在 Trigger Setup 窗口点击“+”，深度选择 timer_cnt 信号
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 123 / 285
将 Radix 改为 U，也就是十进制，在 Value 中设置为 49999999，也就是 timer_cnt 计数的最大值
再次点击运行，即可以看到触发成功，此时 timer_cnt 显示为十六进制，而 led 也在此时翻
转。
5.9.2 MARK DEBUG
上面介绍了添加 ILA IP 的方式在线调试，下面介绍在代码中添加综合属性，实现在线调
试。
1） 首先打开 led.v，将 ila 的例化部分注释掉
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 124 / 285
2） 在 led 和 timer_cnt 的定义前面添加(* MARK_DEBUG=”true” *)，保存文件。
3） 点击综合
4） 综合结束后，点击 Set Up Debug
5) 弹出的窗口点击 Next
按照默认点击 Next
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 125 / 285
采样深度窗口，选择 Next
点击 Finish
点击保存
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 126 / 285
在 xdc 文件中即可看到添加的 ila 核约束
5） 重新生成 bitstream
6) 调试方法与前面一样，不再赘述。
实验总结
本章节介绍了如何在 PL 端开发程序，包括工程建立，约束，仿真，在线调试等方法，在
后续的代码开发方式中皆可参考此方法。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 127 / 285
第六章 Vivado 下 PLL 实验
实验 Vivado 工程为“pll_test”。
很多初学者看到板上只有一个 50Mhz 时钟输入的时候都产生疑惑，时钟怎么才 50Mhz？如
果要工作在 100Mhz、150Mhz 怎么办？ 其实在很多 FPGA 芯片内部都集成了 PLL，其他厂商可
能不叫 PLL，但是也有类似的功能模块，通过 PLL 可以倍频分频，产生其他很多时钟。本实验通
过调用 PLL IP core 来学习 PLL 的使用、vivado 的 IP core 使用方法。
实验原理
PLL(phase-locked loop)，即锁相环。是 FPGA 中的重要资源。由于一个复杂的 FPGA 系统往
往需要多个不同频率，相位的时钟信号。所以，一个 FPGA 芯片中 PLL 的数量是衡量 FPGA 芯片
能力的重要指标。FPGA 的设计中，时钟系统的 FPGA 高速的设计极其重要，一个低抖动, 低延
迟的系统时钟会增加 FPGA 设计的成功率。
本实验将通过使用 PLL, 输出一个方波到开发板上的扩展口（AX7020/AX7010 开发板 J11 的
PIN3 脚），来给大家演示在 Vivado 软件里使用 PLL 的方法。
 7 系列的 FPGA 使用了专用的全局(Global)和区域(Regional)IO 和时钟资源来管理设计中各种
的时钟需求。Clock Management Tiles(CMT)提供了时钟合成(Clock frequency synthesis)，倾斜矫正
(deskew)，过滤抖动(jitter filtering)功能。
每个 CMTs 包含一个 MMCM(mixed-mode clock manager)和一个 PLL。如下图所示，CMT 的输
入可以是 BUFR，IBUFG，BUFG，GT，BUFH，本地布线（不推荐使用），输出需要接到 BUFG 或者
BUFH 后再使用
 混合模式时钟管理器(MMCM)
 MMCM 用于在与给定输入时钟有设定的相位和频率关系的情况下，生成不同的时钟
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 128 / 285
信号。 MMCM 提供了广泛而强大的时钟管理功能，
 MMCM 内部的功能框图如下图所示:  数字锁相环(PLL)
锁相环（PLL）主要用于频率综合。使用一个 PLL 可以从一个输入时钟信号生成多个时钟
信号。
PLL 内部的功能框图如下图所示:
 想了解更多的时钟资源, 建议大家看看 Xilinx 提供的文档"7 Series FPGAs Clocking 
Resources User Guide"。
创建 Vivado 工程
本实验中为大家演示如果调用 Xilinx 提供的 PLL IP 核来产生不同频率的时钟, 并把其中的
一个时钟输出到 FPGA 外部 IO 上, 下面为程序设计的详细步骤。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 129 / 285
1) 新建一个 pll_test 的工程，点击 Project Manager 界面下的 IP Catalog。
2) 再在 IP Catalog 界面里选择 FPGA Features and Design\Clocking 下面的 Clocking Wizard，双击
打开配置界面。
3) 默认这个 Clocking Wizard 的名字为 clk_wiz_0, 这里我们不做修改。在第一个界面 Clocking 
Options 里， 我们选择 PLL 资源，输入的时钟频率为 50Mhz。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 130 / 285
4) 在 Output Clocks 界面里选择 clk_out1~clk_out4 四个时钟的输出，频率分别为 200Mhz, 
100Mhz, 50Mhz, 25Mhz。这里还可以设置时钟输出的相位，我们不做设置，保留默认相位,
点击 OK 完成,
5) 在弹出的对话框中点击 Generate 按钮生成 PLL IP 的设计文件。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 131 / 285
6) 这时一个 clk_wiz_0.xci 的 IP 会自动添加到我们的 pll_test 项目中, 用户可以双击它来修改
这个 IP 的配置。
 选择 IP Sources 这页，然后双击打开 clk_wiz_0.veo 文件，这个文件里提供了这个 IP 的实例
化模板。我们只需要把框框的中内容拷贝到我们 verilog 程序中，对 IP 进行实例化。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 132 / 285
7) 我们再来编写一个顶层设计文件来实例化这个 PLL IP, 编写 pll_test.v 代码如下。注意 PLL 的
复位是高电平有效，也就是高电平时一直在复位状态，PLL 不会工作，这一点很多新手会
忽略掉。这里我们将 rst_n 绑定到一个按键上，而按键是低电平复位，因此需要反向连接
到 PLL 的复位。
`timescale 1ns / 1ps
module pll_test(
input sys_clk, //system clock 50Mhz on board
input rst_n, //reset ,low active
output clk_out //pll clock output J8_Pin3
 );
 
wire locked;
/////////////////////PLL IP call////////////////////////////
clk_wiz_0 clk_wiz_0_inst
 (// Clock in ports
 .clk_in1(sys_clk), // IN 50Mhz
 // Clock out ports
 .clk_out1(), // OUT 200Mhz
 .clk_out2(), // OUT 100Mhz
 .clk_out3(), // OUT 50Mhz
 .clk_out4(clk_out), // OUT 25Mhz
 // Status and control signals
 .reset(~rst_n), // pll reset, high-active
 .locked(locked)); // OUT
endmodule
程序中先用实例化 clk_wiz_0, 把单端 50Mhz 时钟信号输入到 clk_wiz_0 的 clk_in1，把
clk_out4 的输出赋给 clk_out。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 133 / 285
注意：例化的目的是在上一级模块中调用例化的模块完成代码功能，在 Verilog 里例化信
号的格式如下：模块名必须和要例化的模块名一致，比如程序中的 clk_wiz_0，包括模块信号
名也必须一致，比如 clk_in1，clk_out1，clk_out2.....。连接信号为 TOP 程序跟模块之间传递的
信号，模块与模块之间的连接信号不能相互冲突，否则会产生编译错误。
8) 保存工程后，pll_test 自动成为了 top 文件，clk_wiz_0 成为 Pll_test 文件的子模块。
9) 再为工程添加 xdc 管脚约束文件 pll.xdc，添加方法参考”PL 的”Hello World”LED 实验”，也可
以直接复制以下内容。并编译生成 bitstream。
############## clock and reset define##################
create_clock -period 20 [get_ports sys_clk]
set_property IOSTANDARD LVCMOS33 [get_ports {sys_clk}]
set_property PACKAGE_PIN U18 [get_ports {sys_clk}]
set_property IOSTANDARD LVCMOS33 [get_ports {rst_n}]
set_property PACKAGE_PIN N15 [get_ports {rst_n}]
############## pll output define J11 PIN3##################
set_property IOSTANDARD LVCMOS33 [get_ports clk_out]
set_property PACKAGE_PIN F17 [get_ports clk_out]
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 134 / 285
仿真
 添加一个 vtf_pll_test 仿真文件，运行后 PLL 的 lock 信号会变高，说明 PLL IP 锁相环已经初始
化完成。clk_out 有时钟信号输出，输出的频率为输入时钟频率的 1/2, 为 25Mhz。仿真方法可
以参考”PL 的”Hello World”LED 实验”。
板上验证
编译工程并生成 pll_test.bit 文件，再把 bit 文件下载到 FPGA 中，接下去我们就可以用示
波器来测量输出时钟波形了。
用示波器探头的地线连接到开发板上的地（AX7020/AX7010 开发板 J11 的 PIN1 脚)，信号
端连接 AX7020 开发板 J11 的 PIN3 脚（测量的时候需要注意，避免示波器表头碰到其它管脚而
导致电源和地短路)。
这时我们可以在示波器里看到 25Mhz 的时钟波形，波形的幅度为 3.3V, 占空比为 1:1,波形
显示如下图所示：
如果您想输出其它频率的波形，可以修改时钟的输出为 clk_wiz_0 的 clk_out2 或 clk_out3
或 clk_out4。也可以修改 clk_wiz_0 的 clk_out4 为您想要的频率，这里也需要注意一下，因为
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 135 / 285
时钟的输出是通过 PLL 对输入时钟信号的倍频和分频系数来得到的，所以并不是所有的时钟频
率都可以用 PLL 能够精确产生的，不过 PLL 也会自动为您计算实际输出接近的时钟频率。
另外需要注意的是，有些用户的示波器的带宽和采样率太低，会导致测量高频时钟信号
的时候，高频部分衰减太大，测量波形的幅度会变低。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 136 / 285
第七章 FPGA 片内 RAM 读写测试实验
实验 Vivado 工程为“ram_test”。
RAM 是 FPGA 中常用的基础模块，可广泛用于缓存数据的情况，同样它也是 ROM，FIFO 的
基础。本实验将为大家介绍如何使用 FPGA 内部的 RAM 以及程序对该 RAM 的数据读写操作。
实验原理
Xilinx 在 VIVADO 里为我们已经提供了 RAM 的 IP 核, 我们只需通过 IP 核例化一个 RAM，根 据 RAM 的读写时序来写入和读取 RAM 中存储的数据。实验中会通过 VIVADO 集成的在线逻辑
分析仪 ila，我们可以观察 RAM 的读写时序和从 RAM 中读取的数据。
创建 Vivado 工程
在添加 RAM IP 之前先新建一个 ram_test 的工程, 然后在工程中添加 RAM IP，方法如下：
1） 点击下图中 IP Catalog，在右侧弹出的界面中搜索 ram，找到 Block Memory Generator,双击
打开。
2） 将 Component Name 改为 ram_ip,在 Basic 栏目下，将 Memory Type 改为 Simple Dual Prot 
RAM，也就是伪双口 RAM。一般来讲"Simple Dual Port RAM"是最常用的，因为它是两个端
口，输入和输出信号独立。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 137 / 285
3） 切换到 Port A Options 栏目下，将 RAM 位宽 Port A Width 改为 16，也就是数据宽度。将
RAM 深度 Port A Depth 改为 512，深度指的是 RAM 里可以存放多少个数据。使能管脚
Enable Port Type 改为 Always Enable。 4） 切换到 Port B Options 栏目下，将 RAM 位宽 Port B Width 改为 16，使能管脚 Enable Port 
Type 改为 Always Enable，当然也可以 Use ENB Pin，相当于读使能信号。而 Primitives 
Output Register 取消勾选，其功能是在输出数据加上寄存器，可以有效改善时序，但读出
的数据会落后地址两个周期。很多情况下，不使能这项功能，保持数据落后地址一个周
期。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 138 / 285
5） 在 Other Options 栏目中，这里不像 ROM 那样需要初始化 RAM 的数据，我们可以在程序中
写入，所以配置默认即可，直接点击 OK。
6) 点击“Generate”生成 RAM IP。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 139 / 285
RAM 的端口定义和时序
Simple Dual Port RAM 模块端口的说明如下：
信号名称 方向 说明
clka in 端口 A 时钟输入
wea in 端口 A 使能
addra in 端口 A 地址输入
dina in 端口 A 数据输入
clkb in 端口 B 时钟输入
addrb in 端口 B 地址输入
doutb out 端口 B 数据输输出
 RAM 的数据写入和读出都是按时钟的上升沿操作的，端口 A 数据写入的时候需要置高
wea 信号，同时提供地址和要写入的数据。下图为输入写入到 RAM 的时序图。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 140 / 285
RAM 写时序
而端口 B 是不能写入数据的，只能从 RAM 中读出数据，只要提供地址就可以了，一般情
况下可以在下一个周期采集到有效的数据。
RAM 读时序
测试程序编写
下面进行 RAM 的测试程序的编写，由于测试 RAM 的功能，我们向 RAM 的端口 A 写入一
串连续的数据，只写一次，并从端口 B 中读出，使用逻辑分析仪查看数据。代码如下
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////
////////////
module ram_test(
input clk, //50MHz时钟
input rst_n //复位信号，低电平有效
);
//-----------------------------------------------------------
reg [8:0] w_addr; //RAM PORTA写地址
reg [15:0] w_data; //RAM PORTA写数据
reg wea; //RAM PORTA使能
reg [8:0] r_addr; //RAM PORTB读地址
wire [15:0] r_data; //RAM PORTB读数据
//产生RAM PORTB读地址
always @(posedge clk or negedge rst_n)
begin
 if(!rst_n)
r_addr <= 9'd0;
 else if (|w_addr) //w_addr位或，不等于0
 r_addr <= r_addr+1'b1;
 else
r_addr <= 9'd0;
end
//产生RAM PORTA写使能信号
always@(posedge clk or negedge rst_n)
begin
 if(!rst_n)
 wea <= 1'b0;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 141 / 285
 else
 begin
 if(&w_addr) //w_addr的bit位全为1，共写入512个数据，写入完成
 wea <= 1'b0; 
 else 
 wea <= 1'b1; //ram写使能
 end
end
//产生RAM PORTA写入的地址及数据
always@(posedge clk or negedge rst_n)
begin
 if(!rst_n)
 begin
 w_addr <= 9'd0;
 w_data <= 16'd1;
 end
 else
 begin
 if(wea) //ram写使能有效
begin 
if (&w_addr) //w_addr的bit位全为1，共写入512个数据，写入完成
begin
w_addr <= w_addr ; //将地址和数据的值保持住，只写一次RAM
w_data <= w_data ;
end
else
begin
w_addr <= w_addr + 1'b1;
w_data <= w_data + 1'b1;
end
end
 end
end
//-----------------------------------------------------------
//实例化RAM
ram_ip ram_ip_inst (
 .clka (clk ), // input clka
 .wea (wea ), // input [0 : 0] wea
 .addra (w_addr ), // input [8 : 0] addra
 .dina (w_data ), // input [15 : 0] dina
 .clkb (clk ), // input clkb
 .addrb (r_addr ), // input [8 : 0] addrb
 .doutb (r_data ) // output [15 : 0] doutb
);
//实例化ila逻辑分析仪
ila_0 ila_0_inst ( .clk (clk ),
.probe0 (r_data ),
.probe1 (r_addr )
);
endmodule
为了能实时看到 RAM 中读取的数据值，我们这里添加了 ila 工具来观察 RAM PORTB 的数据
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 142 / 285
信号和地址信号。关于如何生成 ila 大家请参考”PL 的”Hello World”LED 实验”。
程序结构如下：
绑定引脚
############## clock and reset define##################
create_clock -period 20 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports {clk}]
set_property PACKAGE_PIN U18 [get_ports {clk}]
set_property IOSTANDARD LVCMOS33 [get_ports {rst_n}]
set_property PACKAGE_PIN N15 [get_ports {rst_n}]
仿真
仿真方法参考”PL 的”Hello World”LED 实验”，仿真结果如下，从图中可以看出地址 1 写入
的数据是 0002，在下个周期，也就是时刻 2，有效数据读出。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 143 / 285
板上验证
生成 bitstream，并下载 bit 文件到 FPGA。接下来我们通过 ila 来观察一下从 RAM 中读出的
数据是否为我们初始化的数据。
在 Waveform 的窗口设置 r_addr 地址为 0 作为触发条件，我们可以看到 r_addr 在不断的从
0 累加到 1ff, 随着 r_addr 的变化, r_data 也在变化, r_data 的数据正是我们写入到 RAM 中的 512
个数据，这里需要注意，r_addr 出现新地址时，r_data 对应的数据要延时两个时钟周期才会出
现，数据比地址出现晚两个时钟周期，与仿真结果一致。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 144 / 285
第八章 FPGA 片内 ROM 读写测试实验
实验 Vivado 工程为“rom_test”。
FPGA 本身是 SRAM 架构的，断电之后，程序就消失，那么如何利用 FPGA 实现一个 ROM 呢，
我们可以利用 FPGA 内部的 RAM 资源实现 ROM，但不是真正意义上的 ROM，而是每次上电都
会把初始化的值先写入 RAM。本实验将为大家介绍如何使用 FPGA 内部的 ROM 以及程序对该
ROM 的数据读操作。
实验原理
Xilinx 在 VIVADO 里为我们已经提供了 ROM 的 IP 核, 我们只需通过 IP 核例化一个 ROM，根 据 ROM 的读时序来读取 ROM 中存储的数据。实验中会通过 VIVADO 集成的在线逻辑分析仪 ila，
我们可以观察 ROM 的读时序和从 ROM 中读取的数据。
程序设计
8.2.1 创建 ROM 初始化文件
既然是 ROM，那么我们就必须提前给它准备好数据，然后在 FPGA 实际运行时，我们直接
读取这些 ROM 中预存储好的数据就行。Xilinx FPGA 的片内 ROM 支持初始化数据配置。如下图
所示，我们可以创建一个名为 rom_init.coe 的文件，注意后缀一定是“.coe”，前面的名称当然可
以随意起。
ROM 初始化文件的内容格式很简单, 如下图所示。第一行为定义数据格式, 16 代表 ROM 的
数据格式为 16 进制。从第 3 行开始到第 34 行，是这个 32*8bit 大小 ROM 的初始化数据。每行
数字后面用逗号，最后一行数字结束用分号。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 145 / 285
rom_init.coe 编写完成后保存一下, 接下去我们开始设计和配置 ROM IP 核。
8.2.2 添加 ROM IP 核
在添加 ROM IP 之前先新建一个 rom_test 的工程, 然后在工程中添加 ROM IP，方法如下：
1） 点击下图中 IP Catalog，在右侧弹出的界面中搜索 rom，找到 Block Memory Generator,双击
打开。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 146 / 285
2） 将 Component Name 改为 rom_ip,在 Basic 栏目下，将 Memory Type 改为 Single Prot ROM。 3） 切换到 Port A Options 栏目下，将 ROM 位宽 Port A Width 改为 8，将 ROM 深度 Port A 
Depth 改为 32，使能管脚 Enable Port Type 改为 Always，并取消 Primitives Output Register
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 147 / 285
4） 切换到 Other Options 栏目下，勾选 Load Init File，点击 Browse，选中之前制作好的.coe 文 件。 5） 点击 ok，点击 Generate 生成 ip 核。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 148 / 285
ROM 测试程序编写
ROM 的程序设计非常简单, 在程序中我们只要每个时钟改变 ROM 的地址, ROM 就会输出当
前地址的内部存储数据，例化 ila，用于观察地址和数据的变化。ROM IP 的实例化及程序设计如
下:
`timescale 1ns / 1ps
module rom_test(
input sys_clk, //50MHz时钟
input rst_n //复位，低电平有效
 );
wire [7:0] rom_data; //ROM读出数据
reg [4:0] rom_addr; //ROM输入地址
//产生ROM地址读取数据
always @ (posedge sys_clk or negedge rst_n)
begin
 if(!rst_n)
 rom_addr <= 10'd0;
 else
 rom_addr <= rom_addr+1'b1;
end 
//实例化ROM
rom_ip rom_ip_inst
(
 .clka (sys_clk ), //inoput clka
 .addra (rom_addr ), //input [4:0] addra
 .douta (rom_data ) //output [7:0] douta
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 149 / 285
);
//实例化逻辑分析仪
ila_0 ila_m0
(
 .clk (sys_clk),
 .probe0 (rom_addr),
.probe1 (rom_data)
);
endmodule
绑定引脚
############## clock and reset define##################
create_clock -period 20 [get_ports sys_clk]
set_property IOSTANDARD LVCMOS33 [get_ports {sys_clk}]
set_property PACKAGE_PIN U18 [get_ports {sys_clk}]
set_property IOSTANDARD LVCMOS33 [get_ports {rst_n}]
set_property PACKAGE_PIN N15 [get_ports {rst_n}]
仿真
仿真结果如下，符合预期，与 RAM 的读取数据一样，数据也是滞后于地址一个周期。
板上验证
以地址 0 为触发条件，可以看到读取的数据与仿真一致。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 150 / 285
第九章 FPGA 片内 FIFO 读写测试实验
实验 Vivado 工程为“fifo_test”。
FIFO 是 FPGA 应用当中非常重要的模块，广泛用于数据的缓存，跨时钟域数据处理等。学
好 FIFO 是 FPGA 的关键，灵活运用好 FIFO 是一个 FPGA 工程师必备的技能。本章主要介绍利用
XILINX 提供的 FIFO IP 进行读写测试。
实验原理
FIFO: First in, First out 代表先进的数据先出，后进的数据后出。Xilinx 在 VIVADO 里为我们已
经提供了 FIFO 的 IP 核, 我们只需通过 IP 核例化一个 FIFO，根据 FIFO 的读写时序来写入和读取
FIFO 中存储的数据。
其实 FIFO 是也是在 RAM 的基础上增加了许多功能，FIFO 的典型结构如下，主要分为读和
写两部分，另外就是状态信号，空和满信号，同时还有数据的数量状态信号，与 RAM 最大的不
同是 FIFO 没有地址线，不能进行随机地址读取数据，什么是随机读取数据呢，也就是可以任意
读取某个地址的数据。而 FIFO 则不同，不能进行随机读取，这样的好处是不用频繁地控制地址
线。
虽然用户看不到地址线，但是在 FIFO 内部还是有地址的操作的，用来控制 RAM 的读写接
口。其地址在读写操作时如下图所示，其中深度值也就是一个 FIFO 里最大可以存放多少个数
据。初始状态下，读写地址都为 0，在向 FIFO 中写入一个数据后，写地址加 1，从 FIFO 中读出
一个数据后，读地址加 1。此时 FIFO 的状态即为空，因为写了一个数据，又读出了一个数据。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 151 / 285
可以把 FIFO 想象成一个水池，写通道即为加水，读通道即为放水，假如不间断的加水和放
水，如果加水速度比放水速度快，那么 FIFO 就会有满的时候，如果满了还继续加水就会溢出
overflow，如果放水速度比加水速度快，那么 FIFO 就会有空的时候，所以把握好加水与放水的
时机和速度，保证水池一直有水是一项很艰巨的任务。也就是判断空与满的状态，择机写数据
或读数据。
根据读写时钟，可以分为同步 FIFO（读写时钟相同）和异步 FIFO（读写时钟不同）。同步
FIFO 控制比较简单，不再介绍，本节实验主要介绍异步 FIFO 的控制，其中读时钟为 75MHz，写
时钟为 100MHz。实验中会通过 VIVADO 集成的在想逻辑分析仪 ila，我们可以观察 FIFO 的读写
时序和从 FIFO 中读取的数据。
创建 Vivado 工程
9.2.1 添加 FIFO IP 核
在添加 FIFO IP 之前先新建一个 fifo_test 的工程, 然后在工程中添加 FIFO IP，方法如下：
1） 点击下图中 IP Catalog，在右侧弹出的界面中搜索 fifo，找到 FIFO Generator,双击打开。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 152 / 285
2） 弹出的配置页面中，这里可以选择读写时钟分开还是用同一个，一般来讲我们使用 FIFO 为
了缓存数据，通常两边的时钟速度是不一样的。所以独立时钟是最常用的，我们这里选择
“Independent Clocks Block RAM”，然后点击“Next”到下一个配置页面。
3） 切换到 Native Ports 栏目下，选择数据位宽 16；FIFO 深选择 512，实际使用大家根据需要
自行设置就可以。Read Mode 有两种方式，一个 Standard FIFO，也就是平时常见的 FIFO，
数据滞后于读信号一个周期，还有一种方式为 First Word Fall Through，数据预取模式，简 称 FWFT 模式。也就是 FIFO 会预先取出一个数据，当读信号有效时，相应的数据也有效。
我们首先做标准 FIFO 的实验。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 153 / 285
4） 切换到 Data Counts 栏目下，使能 Write Data Count（已经 FIFO 写入多少数据）和 Read Data 
Count（FIFO 中有多少数据可以读），这样我们可以通过这两个值来看 FIFO 内部的数据多
少。点击 OK,Generate 生成 FIFO IP。
9.2.2 FIFO 的端口定义与时序
信号名称 方向 说明
rst in 复位信号，高有效
wr_clk in 写时钟输入
rd_clk in 读时钟输入
din in 写数据
wr_en in 写使能，高有效
rd_en in 读使能，高有效
dout out 读数据
full out 满信号
empty out 空信号
rd_data_count out 可读数据数量
wr_data_count out 已写入的数据数量
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 154 / 285
FIFO 的数据写入和读出都是按时钟的上升沿操作的，当 wr_en 信号为高时写入 FIFO 数
据，当 almost_full 信号有效时，表示 FIFO 只能再写入一个数据，一旦写入一个数据了，full 信
号就会拉高，如果在 full 的情况下 wr_en 仍然有效，也就是继续向 FIFO 写数据，则 FIFO 的
overflow 就会有效，表示溢出。
标准 FIFO 写时序
当rd_en信号为高时读FIFO数据，数据在下个周期有效。valid为数据有效信号，almost_empty
表示还有一个数据读，当再读一个数据，empty 信号有效，如果继续读，则 underflow 有效，表
示下溢，此时读出的数据无效。
标准 FIFO 读时序
而从 FWFT 模式读数据时序图可以看出，rd_en 信号有效时，有效数据 D0 已经在数据线上
准备好有效了，不会再延后一个周期。这就是与标准 FIFO 的不同之处。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 155 / 285
FWFT FIFO 读时序
关于 FIFO 的详细内容可参考 pg057 文档，可在 xilinx 官网下载。
FIFO 测试程序编写
我们按照异步 FIFO 进行设计，用 PLL 产生出两路时钟，分别是 100MHz 和 75MHz，用于
写时钟和读时钟，也就是写时钟频率高于读时钟频率。
`timescale 1ns / 1ps
module fifo_test
(
input clk, //50MHz时钟
input rst_n //复位信号，低电平有效
);
reg [15:0] w_data ; //FIFO写数据
wire wr_en ; //FIFO写使能
wire rd_en ; //FIFO读使能
wire [15:0] r_data ; //FIFO读数据
wire full ; //FIFO满信号
wire empty ; //FIFO空信号
wire [8:0] rd_data_count ; //可读数据数量
wire [8:0] wr_data_count ; //已写入数据数量
wire clk_100M ; //PLL产生100MHz时钟
wire clk_75M ; //PLL产生100MHz时钟
wire locked ; //PLL lock信号，可作为系统复位
信号，高电平表示lock住
wire fifo_rst_n ; //fifo复位信号, 低电平有效
wire wr_clk ; //写FIFO时钟
wire rd_clk ; //读FIFO时钟
reg [7:0] wcnt ; //写FIFO复位后等待计数器
reg [7:0] rcnt ; //读FIFO复位后等待计数器
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 156 / 285
//例化PLL，产生100MHz和75MHz时钟
clk_wiz_0 fifo_pll
(
 // Clock out ports
 .clk_out1(clk_100M), // output clk_out1
 .clk_out2(clk_75M), // output clk_out2
 // Status and control signals
 .reset(~rst_n), // input reset
 .locked(locked), // output locked
 // Clock in ports
 .clk_in1(clk) // input clk_in1
 ); 
assign fifo_rst_n = locked ; //将PLL的LOCK信号赋值给fifo的复位信号
assign wr_clk = clk_100M ; //将100MHz时钟赋值给写时钟
assign rd_clk = clk_75M ; //将75MHz时钟赋值给读时钟
/* 写FIFO状态机 */
localparam W_IDLE = 1 ;
localparam W_FIFO = 2 ;
reg[2:0] write_state;
reg[2:0] next_write_state;
always@(posedge wr_clk or negedge fifo_rst_n)
begin
if(!fifo_rst_n)
write_state <= W_IDLE;
else
write_state <= next_write_state;
end
always@(*)
begin
case(write_state)
W_IDLE:
begin
if(wcnt == 8'd79) //复位后等待一定时间，safety 
circuit模式下的最慢时钟60个周期
next_write_state <= W_FIFO;
else
next_write_state <= W_IDLE;
end
W_FIFO:
next_write_state <= W_FIFO; //一直在写FIFO状态
default:
next_write_state <= W_IDLE;
endcase
end
//在IDLE状态下，也就是复位之后，计数器计数
always@(posedge wr_clk or negedge fifo_rst_n)
begin
if(!fifo_rst_n)
wcnt <= 8'd0;
else if (write_state == W_IDLE)
wcnt <= wcnt + 1'b1 ;
else
wcnt <= 8'd0;
end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 157 / 285
//在写FIFO状态下，如果不满就向FIFO中写数据
assign wr_en = (write_state == W_FIFO) ? ~full : 1'b0;
//在写使能有效情况下，写数据值加1
always@(posedge wr_clk or negedge fifo_rst_n)
begin
if(!fifo_rst_n)
w_data <= 16'd1;
else if (wr_en)
w_data <= w_data + 1'b1;
end
/* 读FIFO状态机 */
localparam R_IDLE = 1 ;
localparam R_FIFO = 2 ;
reg[2:0] read_state;
reg[2:0] next_read_state;
///产生FIFO读的数据
always@(posedge rd_clk or negedge fifo_rst_n)
begin
if(!fifo_rst_n)
read_state <= R_IDLE;
else
read_state <= next_read_state;
end
always@(*)
begin
case(read_state)
R_IDLE:
begin
if (rcnt == 8'd59) //复位后等待一定时间，
safety circuit模式下的最慢时钟60个周期
next_read_state <= R_FIFO;
else
next_read_state <= R_IDLE;
end
R_FIFO:
next_read_state <= R_FIFO ; //一直在读FIFO状态
default:
next_read_state <= R_IDLE;
endcase
end
//在IDLE状态下，也就是复位之后，计数器计数
always@(posedge rd_clk or negedge fifo_rst_n)
begin
if(!fifo_rst_n)
rcnt <= 8'd0;
else if (write_state == W_IDLE)
rcnt <= rcnt + 1'b1 ;
else
rcnt <= 8'd0;
end
//在读FIFO状态下，如果不空就从FIFO中读数据
assign rd_en = (read_state == R_FIFO) ? ~empty : 1'b0;
//-----------------------------------------------------------
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 158 / 285
//实例化FIFO
fifo_ip fifo_ip_inst 
(
 .rst (~fifo_rst_n ), // input rst
 .wr_clk (wr_clk ), // input wr_clk
 .rd_clk (rd_clk ), // input rd_clk
 .din (w_data ), // input [15 : 0] din
 .wr_en (wr_en ), // input wr_en
 .rd_en (rd_en ), // input rd_en
 .dout (r_data ), // output [15 : 0] dout
 .full (full ), // output full
 .empty (empty ), // output empty
 .rd_data_count (rd_data_count), // output [8 : 0] rd_data_count
 .wr_data_count (wr_data_count) // output [8 : 0] wr_data_count
);
//写通道逻辑分析仪
ila_m0 ila_wfifo ( .clk(wr_clk),
.probe0(w_data),
.probe1(wr_en),
.probe2(full),
.probe3(wr_data_count)
);
//读通道逻辑分析仪
ila_m0 ila_rfifo ( .clk(rd_clk),
.probe0(r_data),
.probe1(rd_en),
.probe2(empty),
.probe3(rd_data_count)
);
endmodule
在程序中采用 PLL 的 lock 信号作为 fifo 的复位，同时将 100MHz 时钟赋值给写时钟，
75MHz 时钟赋值给读时钟。
有一点需要注意的是，FIFO 设置默认为采用 safety circuit，此功能是保证到达内部 RAM 的
输入信号是同步的，在这种情况下，如果异步复位后，则需要等待 60 个最慢时钟周期，在本
实验中也就是 75MHz 的 60 个周期，那么 100MHz 时钟大概需要(100/75)x60=80 个周期。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 159 / 285
因此在写状态机中，等待 80 个周期进入写 FIFO 状态
在读状态机中，等待 60 个周期进入读状态
如果 FIFO 不满，就一直向 FIFO 写数据
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 160 / 285
如果 FIFO 不空，就一直从 FIFO 读数据
例化两个逻辑分析仪，分别连接写通道和读通道的信号
仿真
以下为仿真结果，可以看到写使能 wr_en 有效后开始写数据，初始值为 0001，从开始写
到 empty 不空，是需要一定周期的，因为内部还要做同步处理。在不空后，开始读数据，读出
的数据相对于 rd_en 滞后一个周期。
在后面可以看到如果 FIFO 满了，根据程序的设计，满了就不向 FIFO 写数据了，wr_en 也
就拉低了。为什么会满呢，就是因为写时钟比读时钟快。如果将写时钟与读时钟调换，也就是
读时钟快，就会出现读空的情况，大家可以试一下。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 161 / 285
如果将 FIFO 的 Read Mode 改成 First Word Fall Through
仿真结果如下，可以看到 rd_en 有效的时候数据也有效，没有相差一个周期
板上验证
生成好 bit 文件，下载 bit 文件，会出现两个 ila，先来看写通道的，可以看到 full 信号为高
电平时，wr_en 为低电平，不再向里面写数据。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 162 / 285
而读通道也与仿真一致
如果以 rd_en 上升沿作为触发条件，点击运行，然后按下复位，也就是我们绑定的 PL 
KEY1，会出现下面的结果，与仿真一致，标准 FIFO 模式下，数据滞后 rd_en 一个周期。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 163 / 285
第十章 Vivado 下按键实验
实验 Vivado 工程为“key_test”。
按键是 FPGA 设计当中最常用也是最简单的外设，本章通过按键检测实验，检测开发板的
按键功能是否正常，并了解硬件描述语言和 FPGA 的具体关系，学习 Vivado RTL ANALYSIS 的使
用。
按键硬件电路
AX7020/AX7010 开发板按键部分电路
从图中可以看到，电路的按键松开时是高电平，按下时是低电平。
AX7020/AX7010 开发板 LED 部分电路
而 LED 部分，低电平亮，高电平灭
程序设计
这个程序没有设计的很复杂，通过简单的硬件描述语言看透硬件描述语言和 FPGA 硬件的
联系。首先我们将按键输入经过 2 组 D 触发器。经过 D 触发器的信号，会在 D 触发器时钟输
入的上升沿锁存然后再送到输出。
D触发器 按键输入 时钟输入 D触发器 第一级 第二级 LED
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 164 / 285
在进行硬件描述语言编码之前，我们已经把硬件构建完成，这是一个正常的开发流程。有
了硬件设计思路无论是通过画图还是通过 Verilog HDL、VHDL 都能完成设计，根据设计的复杂
程序和对某种语言的熟悉程序来选择工具。
创建 Vivado 工程
1) 首先建立按键的测试工程，添加 verilog 测试代码，完成编译分配管脚等流程。
`timescale 1ns / 1ps
module key_test
(
input clk, //system clock 50Mhz on board
input [3:0] key, //input four key signal,when the 
keydown,the value is 0
output[3:0] led //LED display ,when the siganl 
low,LED lighten
);
reg[3:0] led_r; //define the first stage register , generate 
four D Flip-flop 
reg[3:0] led_r1; //define the second stage register ,generate 
four D Flip-flop
always@(posedge clk)
begin
led_r <= key; //first stage latched data
end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 165 / 285
always@(posedge clk)
begin
led_r1 <= led_r; //second stage latched data
end
assign led = led_r1;
endmodule
2) 我们可以使用 RTL ANALYSIS 工具查看设计
3) 分析 RTL 图，可以看出第一级 D 触发器连接按键输入，第二级直接输入，和预期设计一
致。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 166 / 285
板上验证
Bit 文件下载到开发板以后，开发板上的" PL LED1"、" PL LED2"、" PL LED3"、" PL LED4"都
处于灭状态，按键“PL KEY1”按下“PL LED1”亮，按键“PL KEY2”按下“PL LED2” 亮，按
键“PL KEY3”按下“PL LED3” 亮, 按键“PL KEY4”按下“PL LED4” 亮。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 167 / 285
第十一章 按键消抖实验
实验 Vivado 工程为“key_debounce”。
本文主要讲解按键消抖原理及程序编写，程序实现按键按下后数字加 1，并在 led 出来，
通过 vivado 软件编译调试。
实验原理
按键作为基本的人机输入接口，在很多电子设计中都能见到，由于机械特性，在按键按下
或松开的时候，按键输入值是有抖动的，无论按下去是多平稳，都难以消除抖动，按键消抖方
式有很多，本实验主要是通过 FPGA 计时来消抖。实验中设计了一个计数器，当按键输入有变化
时，计时器清零，否则就累加，直到加到一个预定值（例如 10ms），就认为按键稳定，输出按键
值，这样就得到以后没有抖动的按键值。由于在很多地方需要用到按键下降沿或上升沿的检测，
按键消抖模块直接集成了上升沿和下降沿检测的功能。
程序设计
如下图所示，通过按键消抖后，在按键按下时，十进制计数器加 1，通过 LED 灯显示出
来。
4位十进制 计数器 LED显示 按键消抖 下降沿 按键输入按键输入 按键消抖后 按键按下 按键松开
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 168 / 285
按键消抖部分的原理在上节已经讲过，按键消抖部分代码写的非常精炼，阅读起来稍显费
解，建议结合仿真波形去读代码。在提供的例程文件下的 src 文件夹中同时提供了仿真文件
key_debounce_tb.v，可以通过添加仿真文件来进行仿真观察代码中信号的变化。
信号名称 方向 说明
clk in 时钟输入
rst_n in 异步复位输入，低复位
button_in in 按键输入
button_posedge out 消抖后按键上升沿，高有效，1 个时钟周期
button_negedge out 消抖后按键下升沿，高有效，1 个时钟周期
button_out out 消抖后按键输出
按键消抖模块（ax_debounce）端口
LED 显示部分在本章不做说明，就例程中按键消抖模块“ax_debounce”模块做一些讲解，
模块中通过了两级 D 触发器来寄存键值，只有当按键值稳定时才将按键值输出。我们可以看到
在 assign 赋值语句中有一条“assign a_reset=（DFF1 ^ DFF2）”，学过数字电路的应该都知道“ ^ ”
是异或运算符，运算符两边相同运算结果为 0， 不同运算结果为 1。在程序中 DFF1 和 DFF2 比
较运算后的值通过“assign”赋给“a_reset”，表示比较锁存键值的前后两级寄存器的值是否一
致，只有前后两级寄存器的值一致，也就是 a_reset 的值为 0 时，才表示当前锁存的键值没有变
化。当计数器累加到“TIMER_MAX_VAL”，表示锁存的键值已经稳定可以输出。另外在模块中我
们可以看到“{.......}”符号，要注意这可不是大括号，这表示位拼接运算符，其作用是将运算符
内的两位，或是多位信号拼接在一起，具体用法请参考例程。
`timescale 1 ns / 100 ps
module ax_debounce 
(
 input clk,
 input rst,
 input button_in,
 output reg button_posedge,
 output reg button_negedge,
 output reg button_out
);
//// ---------------- internal constants --------------
parameter N = 32 ; // debounce timer bitwidth
parameter FREQ = 50; //model clock :Mhz
parameter MAX_TIME = 20; //ms
localparam TIMER_MAX_VAL = MAX_TIME * 1000 * FREQ;
////---------------- internal variables ---------------
reg [N-1 : 0] q_reg; // timing regs
reg [N-1 : 0] q_next;
reg DFF1, DFF2; // input flip-flops
wire q_add; // control flags
wire q_reset;
reg button_out_d0;
//// ------------------------------------------------------
////contenious assignment for counter control
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 169 / 285
assign q_reset = (DFF1 ^ DFF2); // xor input flip flops to 
look for level chage to reset counter
assign q_add = ~(q_reg == TIMER_MAX_VAL); // add to counter when q_reg 
msb is equal to 0
 
//// combo counter to manage q_next 
always @ ( q_reset, q_add, q_reg)
begin
 case( {q_reset , q_add})
 2'b00 :
 q_next <= q_reg;
 2'b01 :
 q_next <= q_reg + 1;
 default :
 q_next <= { N {1'b0} };
 endcase 
end
//// Flip flop inputs and q_reg update
always @ ( posedge clk or posedge rst)
begin
 if(rst == 1'b1)
 begin
 DFF1 <= 1'b0;
 DFF2 <= 1'b0;
 q_reg <= { N {1'b0} };
 end
 else
 begin
 DFF1 <= button_in;
 DFF2 <= DFF1;
 q_reg <= q_next;
 end
end
//// counter control
always @ ( posedge clk or posedge rst)
begin
if(rst == 1'b1)
button_out <= 1'b1;
 else if(q_reg == TIMER_MAX_VAL)
 button_out <= DFF2;
 else
 button_out <= button_out;
end
always @ ( posedge clk or posedge rst)
begin
if(rst == 1'b1)
begin
button_out_d0 <= 1'b1;
button_posedge <= 1'b0;
button_negedge <= 1'b0;
end
else
begin
button_out_d0 <= button_out;
button_posedge <= ~button_out_d0 & button_out;
button_negedge <= button_out_d0 & ~button_out;
end
end
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 170 / 285
endmodule
最后，程序中需要说明的是“button_posedge”和“button_negedge”两个输出信号，这
是一种常用的上升沿和下降沿的采集方法，其描述的 RTL 视图如下：
 当然还有其他的边沿检测电路的描述方法，但是其基本原理都是在逻辑时序电路里先将需
要检测的信号作为输入非阻塞赋值给一个自定义寄存器，通过判断前后两级寄存器的值来判断
是上升沿或是下降沿，由 0 ->1 变化是上升沿，由 1 -> 0 变化是下降沿；
仿真
这里我们添加了一个激励程序 key_debounce_tb.v 文件，用来仿真按键 key 的输入。
仿真的结果如下，我们看到按键一共有 5 次被按下，但是因为前面 4 次按键按下的低电平保持
时间都小于 20ms, 这 4 次的按下都被程序判断为抖动，只有第 5 次的按键按下时间大于了
20ms, 才判断为按键有按下，这时 LED 灯的状态有了变化。
同样按键松开后，也会判断高电平的保持时间是否大于 20ms, 因为前面 4 次的高电平都
低于 20ms, 程序都把它们当做按键的抖动，只有第 5 次的高电平保持时间大于 20ms, q_add 的
信号才有变化。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 171 / 285
实验现象
开发板上电后下载程序，按下“PL KEY2”按键，可以看到 4 个 LED 会变化，对应二进制
数据，按一次加一，如果不经过消抖，是无法实现按一次加一的。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 172 / 285
第十二章 PWM 呼吸灯实验
实验 Vivado 工程为“pwm_led”。
本文主要讲解使用 PWM 控制 LED，实现呼吸灯的效果。
实验原理
如下图所示，用一个 N 比特的计数器，最大值可以表示为 2 的 N 次方，最小值 0，计数器
以“period”为步进值累加，加到最大值后会溢出，进入下一个累加周期。当计数器值大于
“duty”时，脉冲输出高，否则输出低，这样就可以完成图中红色线所示的脉冲占空比可调的
脉冲输出，同时“period”可以调节脉冲频率，可以理解为计数器的步进值。
PWM 脉宽调制示意图
不同的脉冲占空比的方波输出后加在 LED 上，LED 灯就会显示不同的亮度，通过不断地调
节方波的占空比，从而实现 LED 灯亮度的调节。
实验设计
PWM 模块设计非常简单，在上面的原理中已经讲到，这里不再说原理。
信号名称 方向 说明
clk in 时钟输入
rst in 异步复位输入，高复位
period in PWM 脉宽周期（频率）控制。period = PWM 输出频
率 * (2 的 N 次方) / 系统时钟频率。显然 N 越大，频
率精度越高。
duty in 占空比控制，占空比 = duty / (2 的 N 次方）* 100%
PWM 模块（ax_pwm）端口
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 173 / 285
`timescale 1ns / 1ps
module ax_pwm
#(
parameter N = 16 //pwm bit width 
)(
 input clk,
 input rst,
 input[N - 1:0]period,//pwm step value
 input[N - 1:0]duty, //duty value
 output pwm_out //pwm output
 );
reg[N - 1:0] period_r; //period register
reg[N - 1:0] duty_r; //duty register
reg[N - 1:0] period_cnt; //period counter
reg pwm_r;
assign pwm_out = pwm_r;
always@(posedge clk or posedge rst)
begin
 if(rst==1)
 begin
 period_r <= { N {1'b0} };
 duty_r <= { N {1'b0} };
 end
 else
 begin
 period_r <= period;
 duty_r <= duty;
 end
end
//period counter, step is period value
always@(posedge clk or posedge rst)
begin
 if(rst==1)
 period_cnt <= { N {1'b0} };
 else
 period_cnt <= period_cnt + period_r;
end
always@(posedge clk or posedge rst)
begin
 if(rst==1)
 begin
 pwm_r <= 1'b0;
 end
 else
 begin
 if(period_cnt >= duty_r) //if period counter is bigger or 
equals to duty value, then set pwm value to high
 pwm_r <= 1'b1;
 else
 pwm_r <= 1'b0;
 end
end
那么如何实现呼吸灯的效果呢？我们知道呼吸灯效果是由暗不断的变亮，再由亮不断的变
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 174 / 285
暗的过程，而亮暗效果是由占空比来调节的，因此我们主要来控制占空比，也就是控制 duty
的值。
在下面的测试代码中，通过设置 period 的值，设定 PWM 的频率为 200Hz，PWM_PLUS 状
态即是增加 duty 值，如果增加到最大值，将 pwm_flag 置 1，并开始将 duty 值减少，待减少到
最小的值，则开始增加 duty 值，不断循环。其中 PWM_GAP 状态为调整间隔，时间为 100us。
`timescale 1ns / 1ps
module pwm_test(
 input clk, //50MHz
 input rst_n, //low active
 output led //high-off, low-on
 );
 
localparam CLK_FREQ = 50 ; //50MHz
localparam US_COUNT = CLK_FREQ ; //1 us counter
localparam MS_COUNT = CLK_FREQ*1000 ; //1 ms counter
localparam DUTY_STEP = 32'd100000 ; //duty step
localparam DUTY_MIN_VALUE = 32'h6fffffff ; //duty minimum value
localparam DUTY_MAX_VALUE = 32'hffffffff ; //duty maximum value
 
localparam IDLE = 0; //IDLE state
localparam PWM_PLUS = 1; //PWM duty plus state
localparam PWM_MINUS = 2; //PWM duty minus state
localparam PWM_GAP = 3; //PWM duty adjustment gap
wire pwm_out; //pwm output
reg[31:0] period; //pwm step value
reg[31:0] duty; //duty value
reg pwm_flag ; //duty value plus and minus flag, 0: plus; 1: 
minus
reg[3:0] state;
reg[31:0] timer; //duty adjustment counter
assign led = ~pwm_out ; //led low active
always@(posedge clk or negedge rst_n)
begin
if(rst_n == 1'b0)
begin
period <= 32'd0;
timer <= 32'd0;
duty <= 32'd0;
pwm_flag <= 1'b0 ;
state <= IDLE;
end
else
case(state)
IDLE:
begin
period <= 32'd17179; //The pwm step value, pwm 
200Hz(period = 200*2^32/50000000)
state <= PWM_PLUS;
duty <= DUTY_MIN_VALUE;
end
PWM_PLUS :
begin
if (duty > DUTY_MAX_VALUE - DUTY_STEP) //if duty is 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 175 / 285
bigger than DUTY MAX VALUE minus DUTY_STEP , begin to minus duty value
begin
pwm_flag <= 1'b1 ;
duty <= duty - DUTY_STEP ;
end
else
begin
pwm_flag <= 1'b0 ;
duty <= duty + DUTY_STEP ;
end
state <= PWM_GAP ;
end
PWM_MINUS :
begin
if (duty < DUTY_MIN_VALUE + DUTY_STEP) //if duty is 
little than DUTY MIN VALUE plus duty step, begin to add duty value
begin
pwm_flag <= 1'b0 ;
duty <= duty + DUTY_STEP ;
end
else
begin
pwm_flag <= 1'b1 ;
duty <= duty - DUTY_STEP ;
end
state <= PWM_GAP ;
end
PWM_GAP:
begin
if(timer >= US_COUNT*100) //adjustment gap is 100us
begin
if (pwm_flag)
state <= PWM_MINUS ;
else
state <= PWM_PLUS ;
timer <= 32'd0;
end
else
begin
timer <= timer + 32'd1;
end
end
default:
begin
state <= IDLE;
end
endcase
end
//Instantiate pwm module
ax_pwm
#(
 .N(32) )
ax_pwm_m0(
 .clk (clk),
 .rst (~rst_n),
 .period (period),
 .duty (duty),
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 176 / 285
 .pwm_out (pwm_out)
 );
endmodule
下载验证
生成 bitstream，并下载 bit 文件，可以看到 PL LED1 灯产生呼吸灯效果。PWM 是比较常用
的模块，比如风扇转速控制，电机转速控制等等。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 177 / 285
第十三章 I2C 接口 EEPROM 实验
实验 Vivado 工程为“i2c_eeprom_test”。
本实验通过使用开源软件 opencores 上的 I2C master 控制器去控制 I2C 接口的 EEPROM 读
写，练习如何有效的使用开源代码提升开发效率。
实验原理
在开发板上，FPGA 芯片通过 I2C 总线连接 EEPROM 24LC04, I2C 的两根总线各上拉一个 4.7K
的电阻到 3.3V，所以当总线上没有输出时会被拉高， 24LC04 的写保护没有使能，不然 FPGA 会
无法写入数据。因为在电路上 A0~A2 都为低，所以 24LC04 的设备地址为 0xA0。
AX7020/AX7010 开发板部分电路
I2C 总线协议和时序
 I2C 标准速率为 100kbit/s，快速模式 400kbit/s，支持多机通讯， 支持多主控模块，但同
一时刻只允许有一个主控。由数据线 SDA 和时钟 SCL 构成串行总线； 每个电路和模块都有唯一
的地址。
在这里以 AT24C04 为例说明 I2C 读写的基本操作和时序，I2C 设备的操作可分为写单个存储
字节，写多个存储字节，读单个存储字节和读多个存储字节。各个操作如下图所示。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 178 / 285
下面对 I2C 总线通信过程中出现的几种信号状态和时序进行分析。
①总线空闲状态
I2C 总线总线的 SDA 和 SCL 两条信号线同时处于高电平时，规定为总线的空闲状态。此时各
个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平
拉高。
②启动信号(Start)
在时钟线 SCL 保持高电平期间，数据线 SDA 上的电平被拉低（即负跳变），定义为 I2C 总线
总线的启动信号，它标志着一次数据传输的开始。启动信号是由主控器主动建立的，在建立该
信号之前 I2C 总线必须处于空闲状态，如下图所示。
③停止信号(Stop)
在时钟线 SCL 保持高电平期间，数据线 SDA 被释放，使得 SDA 返回高电平（即正跳变），称
为 I2C 总线的停止信号，它标志着一次数据传输的终止。停止信号也是由主控器主动建立的，
建立该信号之后，I2C 总线将返回空闲状态。
④数据位传送
 在 I2C 总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在 SCL 串行
时钟的配合下，在 SDA 上逐位地串行传送每一位数据。进行数据传送时，在 SCL 呈现高电平期
间，SDA 上的电平必须保持稳定，低电平为数据 0，高电平为数据 1。只有在 SCL 为低电平期间，
才允许 SDA 上的电平改变状态。
⑤应答信号（ACK 和 NACK）
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 179 / 285
I2C 总线上的所有数据都是以 8 位字节传送的，发送器每发送一个字节，就在时钟脉冲 9 期
间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK 简
称应答位），表示接收器已经成功地接收了该字节；
应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。对
于反馈有效应答位 ACK 的要求是，接收器在第 9 个时钟脉冲之前的低电平期间将 SDA 线拉低，
并且确保在该时钟的高电平期间为稳定的低电平。
如果接收器是主控器，则在它收到最后一个字节后，发送一个 NACK 信号，以通知被控发
送器结束数据发送，并释放 SDA 线，以便主控接收器发送一个停止信号。
程序设计
I2C 时序虽然简单，但是写的不好也会出现很多问题，在开源网站 http://opencores.org/上
我们可以找到很多非常好的代码，这些代码大部分都提供详细的文档和仿真。俗话说，他山之
石，可以攻玉，恰当的使用开源代码，不光能提升我们的开发效率，也能学习别人的开发思路。
由于代码大部分都是经过很长时间反复修改，反复精炼后的，所以有些代码理解起来可能比较
困难，在不能很好的理解别人代码的时候，最好的办法就是仿真。
从 IP core 文档得知，i2c_master_byte_ctrl 模块主要完成一个字节的读写，我们只需要按照
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 180 / 285
I2C 读写的要求，完成设备地址、寄存器地址、数据等读写即可。
i2c_master_top 模块是对 i2c_master_byte_ctrl 模块的再次封装，完成一个寄存器的读写，由
于不同的设备寄存器可能是 8bit，也可能是 16bit，这里 i2c_addr_2byte 信号来控制寄存器地址
是 8 位还是 16 位。
i2c_master_top 模块状态机，如果是写寄存器操作，先写一个字节设备地址（写操作），再
写 1 个字节或 2 个字节的寄存器地址，再写一个字节的数据；如果是读操作，先写一个字节的
设备地址（写操作），再写 1 个字节或 2 字节的寄存器地址，完成地址的写入，再次写设备地址
（读操作），然后读取一个字节的数据。不管怎么说，程序设计都是要满足芯片时序要求的，所
以在阅读程序之前最好先把芯片的数据手册仔细阅读一遍。
i2c_master_top 状态机
信号名称 方向 说明
clk in 时钟输入
rst in 异步复位输入，高复位
clk_div_cnt in I2C 时钟分频因子，等于系统时钟频率/（5 * I2C
时钟频率） - 1。例如 50Mhz 系统时钟，
100Khz 的 I2C，配置为 99，400Khz 的 I2C，配
置为 24。
scl_pad_i in I2C 时钟数据输入，本实验可忽略
scl_pad_o out I2C 时钟输出
scl_padoen_o out I2C 时钟输出使能，低有效，I2C 外部有上拉电
阻，如果输出高阻态，则会被拉到高电平，在
本实验中，高电平输出时输出高阻
sda_pad_i in I2C 数据输入
sda_pad_o out I2C 数据输出
sda_padoen_o out I2C 数据输出使能，低有效。在本实验中，高电
平输出时输出高阻。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 181 / 285
i2c_addr_2byte in 寄存器地址是 8 位还是 16 位，1：16 位，0:8
位
i2c_read_req in I2C 寄存器读请求
i2c_read_req_ack out I2C 寄存器读请求应答
i2c_write_req in I2C 寄存器写请求
i2c_write_req_ack out I2C 寄存器写请求应答
i2c_slave_dev_addr in I2C 设备地址，8bit，最低位忽略，有效数据位
是高 7 位。
i2c_slave_reg_addr in 寄存器地址，8 位地址时，低 8 位有效
i2c_write_data in 写寄存器数据
i2c_read_data out 读寄存器数据
error out 设备无应答错误
i2c_master_top 模块端口
i2c_eeprom_test 模块完成 EEPROM 的读写，EEPROM 设备地址是 A0，程序中将地址 00 的
数据读出，然后通过 LED 显示，在按键按下时，数字加一并再次写入 EEPROM 并显示出来。在
I2C 控制器中，代码的大部分功能在备注中也有很多批注。
module i2c_eeprom_test(
 input sys_clk, //system clock 50Mhz on board
 input rst_n, //reset ,low active
 input key, //data will add 1 when push key
 inout i2c_sda,
 inout i2c_scl,
 output [3:0] led
);
localparam S_IDLE = 0;
localparam S_READ = 1;
localparam S_WAIT = 2;
localparam S_WRITE = 3;
reg[3:0] state;
wire button_negedge;
reg[7:0] read_data;
reg[31:0] timer;
wire scl_pad_i;
wire scl_pad_o;
wire scl_padoen_o;
wire sda_pad_i;
wire sda_pad_o;
wire sda_padoen_o;
reg[ 7:0] i2c_slave_dev_addr;
reg[15:0] i2c_slave_reg_addr;
reg i2c_write_req;
wire i2c_write_req_ack;
reg[ 7:0] i2c_write_data;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 182 / 285
reg i2c_read_req;
wire i2c_read_req_ack;
wire[7:0] i2c_read_data;
assign led = ~read_data[3:0];
ax_debounce ax_debounce_m0
(
 .clk (sys_clk),
 .rst (~rst_n),
 .button_in (key),
 .button_posedge (),
 .button_negedge (button_negedge),
 .button_out ()
);
always@(posedge sys_clk or negedge rst_n)
begin
 if(rst_n == 1'b0)
 begin
 state <= S_IDLE;
 i2c_write_req <= 1'b0;
 read_data <= 8'h00;
 timer <= 32'd0;
 i2c_write_data <= 8'd0;
 i2c_slave_reg_addr <= 16'd0;
 i2c_slave_dev_addr <= 8'ha0;//1010 000 0, device address
 i2c_read_req <= 1'b0;
 end
 else
 case(state)
 S_IDLE:
 begin
 if(timer >= 32'd499_999)//wait 10ms
 state <= S_READ;
 else
 timer <= timer + 32'd1;
 end
 S_READ:
 begin
 if(i2c_read_req_ack) //if read request ack, then 
i2c read data valid
 begin
 i2c_read_req <= 1'b0;
 read_data <= i2c_read_data;
 state <= S_WAIT;
 end
 else
 begin
 i2c_read_req <= 1'b1;
 i2c_slave_dev_addr <= 8'ha0;
 i2c_slave_reg_addr <= 16'd0;
 end
 end
 S_WAIT:
 begin
 if(button_negedge) //when push button, then data 
add 1, and switch to write state
 begin
 state <= S_WRITE;
 read_data <= read_data + 8'd1;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 183 / 285
 end
 end
 S_WRITE:
 begin
 if(i2c_write_req_ack) //if write request ack, then 
switch to read state
 begin
 i2c_write_req <= 1'b0;
 state <= S_READ;
 end
 else
 begin
 i2c_write_req <= 1'b1;
 i2c_write_data <= read_data;
 end
 end
 
 default:
 state <= S_IDLE;
 endcase
end
//i2c bidirection control
assign sda_pad_i = i2c_sda;
assign i2c_sda = ~sda_padoen_o ? sda_pad_o : 1'bz;
assign scl_pad_i = i2c_scl;
assign i2c_scl = ~scl_padoen_o ? scl_pad_o : 1'bz;
i2c_master_top i2c_master_top_m0
(
 .rst (~rst_n),
 .clk (sys_clk),
 .clk_div_cnt (16'd99), //Standard mode:100Khz; 
prescale = 50MHz/(5*100Khz) - 1
 
 // I2C signals 
 // i2c clock line
 .scl_pad_i (scl_pad_i), // SCL-line input
 .scl_pad_o (scl_pad_o), // SCL-line output (always 
1'b0)
 .scl_padoen_o (scl_padoen_o), // SCL-line output enable 
(active low)
 // i2c data line
 .sda_pad_i (sda_pad_i), // SDA-line input
 .sda_pad_o (sda_pad_o), // SDA-line output (always 
1'b0)
 .sda_padoen_o (sda_padoen_o), // SDA-line output enable 
(active low)
 
 
 .i2c_addr_2byte (1'b0), //register address is 1 
byte
 .i2c_read_req (i2c_read_req),
 .i2c_read_req_ack (i2c_read_req_ack),
 .i2c_write_req (i2c_write_req),
 .i2c_write_req_ack (i2c_write_req_ack),
 .i2c_slave_dev_addr (i2c_slave_dev_addr),
 .i2c_slave_reg_addr (i2c_slave_reg_addr),
 .i2c_write_data (i2c_write_data),
 .i2c_read_data (i2c_read_data),
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 184 / 285
 .error ()
);
ila_0 ila_m0 ( .clk (sys_clk), // input wire clk
.probe0 (read_data) // input wire [7:0] probe0
);
endmodule
根据 IP 核文档中说明，i2c 核用的是 5 倍的 SCL 时钟，如果想得到 100KHz 的 I2C 时钟，在
本实验中 prescale 就等于参考时钟 50MHz 除以 5*100KHz，再减去 1，也就是 99，这一点要注
意。
实验现象
下载实验程序后，可以看到 LED 显示一个二进制数字，这个数字是存储在 EEPROM 中 00 地
址的数据，数据是随机的，这个时候按键 PL KEY2 按下，数字加一，并写入了 EEPROM，再次下
载程序，可以看到直接显示更新后的数据。
在程序中我们添加了逻辑分析仪，用来观察读数据的值，每按一次 PL KEY2 键运行一次可
以看到数据增加 1。
 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 185 / 285
第十四章 RS232 实验
实验 Vivado 工程为“rs232_test”。
本章采用 AN3485 模块的 RS232 电路实现 UART 数据传输。
模块介绍
黑金 AN3845 模块专门为工业现场应用设计的 RS232/485/422 通信模块。它包含一路
RS232 接口，2 路 RS485 和 2 路 RS422 通信接口。配合开发板实现 RS232、485 和 422 的数据远
程传输和通信。RS232、485 和 422 接口分别采用 MAX3232、MAX3485 和 MAX3490 芯片作为
电平转换芯片。模块留有一个 40 针的排母用于连接开发板，RS232 接口为一个标准的 DB9 串
口公座，通过串口线直接连接电脑或者其他设备； RS485 和 RS422 接口采用接线端子跟外部
连接，超远距离传输可达上千米，另外 RS485 和 RS422 接口部分带有正负 15KV 的 ESD 防护功
能。
AN3845 模块实物照片如下：
AN3845 通信模块正面图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 186 / 285
14.1.1 模块参数说明
以下为 AN3485 通信模块的详细参数:  RS232 接口
 一路标准的 DB9 公座串行接口；
 使用 MAX3232 作为 RS232 和 TTL 电平的转换；
 传输率高达 120Kbps 数据通讯速率
 RS485 接口
 两路 RS485 接口，采用 3 线的接线端子；
 使用 MAX3485 作为 RS485 和 TTL 的电平转换;  工业级设计，抗干扰能力超强，同时采用有效的防雷设计;  具有 120 欧匹配电阻，插上跳线帽即可使能匹配电阻，长距离传输时建议短接。
 支持多机通讯，允许接在最多 128 个设备的总线上
 传输率高达 500Kbps 数据通讯速率。  RS422 接口
 两路 RS422 接口，采用 5 线的接线端子；
 使用 MAX3490 作为 RS422 和 TTL 的电平转换;  工业级设计，抗干扰能力超强，同时采用有效的防雷设计;  具有 120 欧匹配电阻，插上跳线帽即可使能匹配电阻，长距离传输时建议短接。
 支持多机通讯，允许接在最多 128 个设备的总线上
 传输率高达 500Kbps 数据通讯速率。
14.1.2 模块功能说明
AN3485 模块的 RS232 接口采用 MAX3232 芯片实现 RS232 和+3.3V TTL 电平的转换。TTL 电
平的串口接收和发送信号（RXD, TXD）连接到 40 针的连接器上跟外面的 FPGA 芯片或者 ARM
芯片实现串口通信。RS232 串口通信的最高速度为 120kbps，RS232 接口的原理设计图如下图
所示。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 187 / 285
程序设计
本文所述的串口指异步串行通信，异步串行是指 UART（Universal Asynchronous 
Receiver/Transmitter），通用异步接收/发送。本实验程序设计为每秒钟向串口发送” HELLO 
ALINX”，如果收到 RXD 接收的数据，再把接收的数据发送出去，实现回环的功能。
14.2.1 异步串口通信协议
消息帧从一个低位起始位开始，后面是 7 个或 8 个数据位，一个可用的奇偶位和一个或几
个高位停止位。接收器发现开始位时它就知道数据准备发送，并尝试与发送器时钟频率同步。
如果选择了奇偶校验，UART 就在数据位后面加上奇偶位。奇偶位可用来帮助错误校验。在接收
过程中，UART 从消息帧中去掉起始位和结束位，对进来的字节进行奇偶校验，并将数据字节从
串行转换成并行。UART 传输时序如下图所示：
从波形上可以看出起始位是低电平，停止位和空闲位都是高电平，也就是说没有数据传输
时是高电平，利用这个特点我们可以准确接收数据，当一个下降沿事件发生时，我们认为将进
行一次数据传输。
14.2.2 波特率
常见的串口通信波特率有 2400 、9600、115200 等，发送和接收波特率必须保持一致才能
正确通信。波特率是指 1 秒最大传输的数据位数，包括起始位、数据位、校验位、停止位。假
如通信波特率设定为 9600，那么一个数据位的时间长度是 1/9600 秒，本实验中的波特率由
50MHz 时钟产生。
FPGA RS232接收程 序 RS232发送程 序 MAX3232 芯片 RXD TXD RS232控制 程序 USB转串 口 串口 USB
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 188 / 285
14.2.3 接收模块设计
串口接收模块 uart_rx 是个参数化可配置模块，参数“CLK_FRE”定义接收模块的系统时钟
频率，单位是 Mhz，参数“BAUD_RATE”是波特率。接收状态机状态转换图如下：
“S_IDLE”状态为空闲状态，上电后进入“S_IDLE”，如果信号“rx_pin”有下降沿，我们
认为是串口的起始位，进入状态“S_START”,等一个 BIT 时间起始位结束后进入数据位接收状
态“S_REC_BYTE”,本实验中数据位设计是 8 位，接收完成以后进入“S_STOP”状态，在
“S_STOP”没有等待一个 BIT 周期，只等待了半个 BIT 时间，这是因为如果等待了一个周期，
有可能会错过下一个数据的起始位判断，最后进入“S_DATA”状态，将接收到的数据送到其他
模块。在这个模块我们提一点：为了满足采样定理，在接受数据时每个数据都在波特率计数器
的时间中点进行采样，以避免数据出错的情况：
//receive serial data bit data
always@(posedge clk or negedge rst_n)
begin
if(rst_n == 1'b0)
rx_bits <= 8'd0;
else if(state == S_REC_BYTE && cycle_cnt == CYCLE/2 - 1)
rx_bits[bit_cnt] <= rx_pin;
else
rx_bits <= rx_bits;
end
注意：本实验没有设计奇偶校验位。
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低电平复位
rx_data out 8 接收到的串口数据（8 位数据）
rx_data_valid out 1 接收到的串口数据有效（高有效）
rx_data_ready in 1 表示用户可以从接收模块接收数据，当
rx_data_ready 和 rx_data_valid 都为高时数据
送出
rx_pin in 1 串口接收数据输入
串口接收模块 uart_rx 端口
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 189 / 285
14.2.4 发送模块设计
发送模块 uart_tx 设计和接收模块相似，也是使用状态机，状态转换图如下：
上电后进入“S_IDLE”空闲状态，如果有发送请求，进入发送起始位状态“S_START”,起
始位发送完成后进入发送数据位状态“S_SEND_BYTE”,数据位发送完成后进入发送停止位状态
“S_STOP”,停止位发送完成后又进入空闲状态。在数据发送模块中，从顶层模块写入的数据
直接传递给寄存器‘tx_reg’，并通过‘tx_reg’寄存器模拟串口传输协议在状态机的条件转换
下进行数据传送：
always@(posedge clk or negedge rst_n)
begin
if(rst_n == 1'b0)
tx_reg <= 1'b1;
else
case(state)
S_IDLE,S_STOP:
tx_reg <= 1'b1;
S_START:
tx_reg <= 1'b0;
S_SEND_BYTE:
tx_reg <= tx_data_latch[bit_cnt];
default:
tx_reg <= 1'b1;
endcase
end
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低电平复位
tx_data in 8 要发送的串口数据(8 位数据）
tx_data_valid in 1 发送的串口数据有效（高有效）
tx_data_ready out 1 发送模块已准备好发送数据，用户可将
tx_data_valid 信号拉高发送数据给发送模
块。当 tx_data_ready 和 tx_data_valid 都为高
时数据被发送
tx_pin out 1 串口发送数据发送
串口发送模块 uart_tx 端口
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 190 / 285
14.2.5 波特率的产生
在发送和接收模块中，声明了参数 CYCLE，也就是 UART 一个周期的计数值，当然计数是
在 50MHz 时钟下进行的。用户只要设定好 CLK_FRE 和 BAUD_RATE 这两个参数即可。
14.2.6 测试程序
测试程序设计 FPGA 为 1 秒向串口发送一次“HELLO ALINX\r\n”,不发送期间，如果接受到
串口数据，直接把接收到的数据送到发送模块再返回。“\r\n”,在这里和 C 语言中表示一致，
都是回车换行。
测试程序分别例化了发送模块和接收模块，同时将参数传递进去，波特率设置为
115200。
always@(posedge sys_clk or negedge rst_n)
begin
if(rst_n == 1'b0)
begin
wait_cnt <= 32'd0;
tx_data <= 8'd0;
state <= IDLE;
tx_cnt <= 8'd0;
tx_data_valid <= 1'b0;
end
else
case(state)
IDLE:
state <= SEND;
SEND:
begin
wait_cnt <= 32'd0;
tx_data <= tx_str;
if(tx_data_valid == 1'b1 && tx_data_ready == 1'b1 && tx_cnt < 8'd12)//Send 12 bytes 
data
begin
tx_cnt <= tx_cnt + 8'd1; //Send data counter
end
else if(tx_data_valid && tx_data_ready)//last byte sent is complete
begin
tx_cnt <= 8'd0;
tx_data_valid <= 1'b0;
state <= WAIT;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 191 / 285
end
else if(~tx_data_valid)
begin
tx_data_valid <= 1'b1;
end
end
WAIT:
begin
wait_cnt <= wait_cnt + 32'd1;
if(rx_data_valid == 1'b1)
begin
tx_data_valid <= 1'b1;
tx_data <= rx_data; // send uart received data
end
else if(tx_data_valid && tx_data_ready)
begin
tx_data_valid <= 1'b0;
end
else if(wait_cnt >= CLK_FRE * 1000000) // wait for 1 second
state <= SEND;
end
default:
state <= IDLE;
endcase
end
//combinational logic
//Send "HELLO ALINX\r\n"
always@(*)
begin
case(tx_cnt)
8'd0 : tx_str <= "H";
8'd1 : tx_str <= "E";
8'd2 : tx_str <= "L";
8'd3 : tx_str <= "L";
8'd4 : tx_str <= "O";
8'd5 : tx_str <= " ";
8'd6 : tx_str <= "A";
8'd7 : tx_str <= "L";
8'd8 : tx_str <= "I";
8'd9 : tx_str <= "N";
8'd10: tx_str <= "X";
8'd11: tx_str <= "\r";
8'd12: tx_str <= "\n";
default:tx_str <= 8'd0;
endcase
end 
uart_rx# (
 .CLK_FRE(CLK_FRE),
 .BAUD_RATE(115200) ) uart_rx_inst
(
 .clk (sys_clk ),
 .rst_n (rst_n ),
 .rx_data (rx_data ),
 .rx_data_valid (rx_data_valid ),
 .rx_data_ready (rx_data_ready ),
 .rx_pin (uart_rx )
);
uart_tx# (
 .CLK_FRE(CLK_FRE),
 .BAUD_RATE(115200)
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 192 / 285
) uart_tx_inst
(
 .clk (sys_clk ),
 .rst_n (rst_n ),
 .tx_data (tx_data ),
 .tx_data_valid (tx_data_valid ),
 .tx_data_ready (tx_data_ready ),
 .tx_pin (uart_tx )
);
仿真
这里我们添加了一个串口接收的激励程序 vtf_uart_test.v 文件，用来仿真 uart 串口接收。
这里向串口模块的 uart_rx 发送 0xa3 的数据, 每位的数据按 115200 的波特率发送，1 位起始
位，8 位数据位和 1 位停止位。
仿真的结果如下，当程序接收到 8 位数据的时候，rx_data_valid 有效，rx_data[7:0]的数据
位 a3。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 193 / 285
实验测试
将 AN3485 模块插到 J11 扩展口上，这里使用了 USB 转 RS232/RS485/RS422 的设备，由于
很多电脑都没有 9 针的串行接口，我们通过串口线与 USB 转串口设备连接，再通过 USB 连接
到电脑上。如果电脑有串口的话，可以直接连接串口。
在设备管理器中找到串口号”COM5”
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 194 / 285
打开串口调试，端口选择“COM5”（根据自己情况选择），波特率设置 115200，检验位选
None，数据位选 8，停止位选 1，然后点击“打开串口”。此软件在例程文件夹下。
打开串口以后，每秒可收到“HELLO ALINX”，在发送区输入框输入要发送的文字，点击
“手动发送”，可以看到接收到自己发送的字符。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 195 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 196 / 285
第十五章 RS422 实验
实验 Vivado 工程为“rs422_test”。
本章利用 AN3485 模块实现 RS422 接口数据传输。关于模块，在前面的 RS232 实验中已经
介绍过，本实验不再赘述。RS422 与 RS232 在与 FPGA 的连接的接口上是一样的，都是 TXD 和
RXD，因此，本实验在 RS232 实验的基础上，例化出两路连接到 RS422 接口芯片 MAX3490
上。
RS422 接口部分原理图
程序设计
程序设计比较简单，以 RS232 实验为基础，例化两路 uart_test 即可。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 197 / 285
实验测试
RS422 的接口部分是差分的信号，共四根信号线，两根发送 TXD+和 TXD-，对应 Y 和 Z，两
根接收 RXD+和 RXD-，对应 A 和 B。 与 RS232 实验一样，也采用 USB 转串口的设备连接，使用杜绑线将模块的 RS422_1 的 Y 和 Z 分别与设备的 R+和 R-连接，将模块的 A 和 B 分别与设备的 T+和 T-连接。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 198 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 199 / 285
下载程序后，即可在串口工具中看到 RS232 实验同样的效果，可以利用同样的方法测试
RS422_2 接口。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 200 / 285
第十六章 RS485 实验
实验 Vivado 工程为“rs485_test”。
本章以 AN3485 模块介绍 RS485 的数据传输。
实验原理
前面介绍过 RS232 和 RS422 的实验，而 RS485 与 RS422 类似，也是采用差分信号传输，但
RS485 是半双工传输，也就是说，同一时刻只能有一个方向的数据传输。而且接口也比 RS422
少，只有差分信号 A 和 B，而与 ARM 或 FPGA 相连的信号为 DE（方向选择）,DI（输入信号
TXD），RO（输出信号 RXD）。
从 MAX3485 文档中，发送方向，如果 DE 为 1 时，也就是输出使能，DI 值为 1 时，对于
差分信号 A 和 B 值为 1 和 0，否则为 0 和 1。
从接收来看，如果 DE 为 0，A 和 B 之间差值大于等于+0.2V，则 RO 值为 1，否则为 0。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 201 / 285
程序设计
由于 RS485 是半双工传输，那么我们需要制定传输协议进行握手，设定第一个字节为
8’h55，表示一帧数据的开始，接下来是传输的数据长度信息，由于 FIFO 大小限制（256），范
围为 1~255，接下来是数据。格式即为：起始 8’h55+数据长度+数据。
其中 uart_tx 和 uart_rx 跟 RS232 实验一样，在这里只修改 uart_test 即可。我们设计的功能
为初始状态下将 DE 设为 0，也就是输入，等待接收上位机发来的数据，并缓存到 FIFO 中，
FIFO 大小设置为 256，然后切换 DE 为 1，也就是输出，把接收到的数据从 FIFO 中读出并发送
出去。注意缓存的数据是除去起始 8’h55 和数量信息的。
在 RCV_HEAD 状态时，判断接收到的数据是否是”S”。 在 RCV_COUNT 状态时，如果数据长度小于 0，则跳转到 IDLE 状态，如果大于 0，则进入
接收数据状态。
在 RCV_DATA 状态下，把数据写入 FIFO，并且检查数据长度，切换 RS485 的方向为输出，
并跳转状态。
在切换总线状态时，为了可靠工作，在 WAIT 状态下，延时 1ms 进行方向切换。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 202 / 285
再然后是发送 FIFO 中的数据，SEND_WAIT 状态是控制读使能信号 fifo_rden，并且判断数
据是否发送完，发送完后进入 IDLE 状态。
实验测试
我们仍然使用 USB 转串口设备，通过杜邦线将 RS485_1 的 A 和 B 分别与设备的 A 和 B 连接。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 203 / 285
‘
打开串口工具，设置好串口号波特率，选择 16 进制发送，发送数据以 8’h55 开头，点击
发送，即可在接收窗口看到返回的数据。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 204 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 205 / 285
第十七章 HDMI 输出实验
实验 Vivado 工程为“hdmi_output_test”。
前面我们介绍了 led 闪灯实验，只是为了了解 Vivado 的基本开发流程，本章这个实验相对
LED 闪灯实验复杂点，做一个 HDMI 输出的彩条，这也是我们后面学习显示、视频处理的基
础。实验还不涉及到 PS 系统，从实验设计可以看出如果要非常好的使用 ZYNQ 芯片，需要良 好的 FPGA 基础知识。
硬件介绍
开发板没有使用 HDMI 编码芯片，而是将 FPGA 的 3.3V 差分 IO 直接连接到 HDMI 连接器，
FPGA 完成 24 位 RGB 编码输出 TMDS 差分信号。
17.1.1 TMDS 原理
HDMI 采用和 DVI 相同的传输原理——TMDS（Transition Minimized Differentialsignal），最小
化传输差分信号。
TMDS 传输系统分为分为两个部分：发送端和接收端。TMDS 发送端收到 HDMI 接口传来的
表示 RGB 信号的 24 位并行数据（TMDS 对每个像素的 RGB 三原色分别按 8bit 编码，即 R 信号
有 8 位，G 信号有 8 位，B 信号有 8 位），然后对这些数据进行编码和并/串转换，再将表示 3 个
RGB 信号的数据分别分配到独立的传输通道发送出去。接收端接收来自发送端的串行信号，对
其进行解码和串/并转换，然后发送到显示器的控制端。与此同时也接收时钟信号，以实现同步。
TMDS 的原理
每一个 TMDS 链路都包括 3 个传输 RGB 信号的数据通道和 1 个传输时钟信号的通道。每一
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 206 / 285
个数据通道都通过编码算法，将 8 位的视、音频数据转换成最小化传输、直流平衡的 10 位数
据。这使得数据的传输和恢复更加可靠。最小化传输差分信号是通过异或及异或非等逻辑算法
将原始 8 位信号数据转换成 10 位，前 8 为数据由原始信号经运算后获得，第 9 位指示运算的方
式，第 10 位用来对应直流平衡。
一般来说，HDMI 传输的编码格式中要包含视频数据、控制数据和数据包（数据包中包含音
频数据和附加信息数据，例如纠错码等）。TMDS 每个通道在传输时要包含一个 2bit 的控制数据、
8bit 的视频数据或者 4bit 的数据包即可。在 HDMI 信息传输过程中，可以分为三个阶段：视频
数据传输周期、控制数据传输周期和数据岛传输周期，分别对应上述的三种数据类型。
下面介绍 TMDS 中采用的技术：
1.传输最小化
8 位数据经过编码和直流平衡得到 10 位最小化数据，这仿佛增加了冗余位，对传输链路的
带宽要求更高，但事实上，通过这种算法得到的 10 位数据在更长的同轴电缆中传输的可靠性增
强了。下图是一个例子，说明对一个 8 位的并行 RED 数据编码、并/串转换。
第一步：将 8 位并行 RED 数据发送到 TMDS 发送端。
第二步：并/串转换.
第三步：进行最小化传输处理，加上第 9 位，即编码过程。第 9 位数据称为编码位。
2.直流平衡
直流平衡（DC-balanced）就是指在编码过程中保证信道中直流偏移为零。方法是在原来的
9 位数据的后面加上第 10 位数据，这样，传输的数据趋于直流平衡，使信号对传输线的电磁干
扰减少，提高信号传输的可靠性。
3.差分信号
TMDS 差分传动技术是一种利用 2 个引脚间电压差来传送信号的技术。传输数据的数值（“0”
或者“1”）由两脚间电压正负极性和大小决定。即，采用 2 根线来传输信号，一根线上传输原
来的信号，另一根线上传输与原来信号相反的信号。这样接收端就可以通过让一根线上的信号
减去另一根线上的信号的方式来屏蔽电磁干扰，从而得到正确的信号。
如下图所示：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 207 / 285
另外，还有一个显示数据通道（DDC），是用于读取表示接收端显示器的清晰度等显示能力
的扩展显示标识数据(EDID)的信号线。搭载 HDCP（High-bandwidth Digital Content Protection，高
带宽数字内容保护技术）的发送、接收设备之间也利用 DDC 线进行密码键的认证。
17.1.2 视频时序标准
HDMI 显示器扫描方式从屏幕左上角一点开始，从左向右逐点扫描，每扫描完一行,电子束
回到屏幕的左边下一行的起始位置，在这期间，CRT 对电子束进行消隐，每行结束时，用行同步
信号进行同步；当扫描完所有的行，形成一帧，用场同步信号进行场同步，并使扫描回到屏幕
左上方，同时进行场消隐，开始下一帧。
完成一行扫描的时间称为水平扫描时间，其倒数称为行频率；完成一帧（整屏）扫描的时
间称为垂直扫描时间，其倒数称为场频率，即刷新一屏的频率，常见的有 60Hz，75Hz 等等。标
准的显示的场频 60Hz。
时钟频率：以 1024x768@59.94Hz(60Hz)为例，每场对应 806 个行周期,其中 768 为显示行。
每显示行包括 1344 点时钟,其中 1024 点为有效显示区。由此可知：需要点时钟频率：806*1344*60
约 65MHz。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 208 / 285
视频时序
VGA 扫描，基本元素是行扫描，多行组成一帧，下图显示一行的时序，其中“Active”Video
是一行视频的有效像素，大部分分辨率时钟中 Top/Left Border 和 Bottom / Right Border 都是 0。 “Blanking”是一行的同步时间，“Blanking”时间加上 Active”Video 时间就是一行的时间。“Blanking”
又分为“Front Porch”、“Sync”、“Back Porch”三段。
行同步时序
以下是 720p 的时序参数
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 209 / 285
1280x720@60Hz 时序参数
Vivado 工程建立
本实验将实现 HDMI 输出显示，verilog 实现编程驱动 HDMI 输出，在 HDMI 显示器里显
示测试图像彩条。HDMI 输出显示模块分成 3 个模块实现，分别是时钟模块 vidio_pll, 彩条生
成模块 color_bar 和 VGA 转 DVI 模块 rgb2dvi。实现的逻辑框图如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 210 / 285
17.2.1 添加 HDMI 编码器 IP 核
1) 新建一个名为“hdmi_output_test”的工程
VGA 的数据很多人都比较清楚，为 RGB 数据，而 HDMI 为 TMDS 差分信号，RGB 数据在
FPGA 比较容易操作，那么我们需要做的就是把 RGB 数据转成 HDMI 的 TMDS 差分信号，因此
采用了 RGB to DVI 的 IP（DVI 与 HDMI 都是 TMDS 信号）。
2) 复制 repo 文件夹（这个文件夹可以到给的例程工程中找到）到工程目录，这个文件夹里
包含了 HDMI 编码器的 IP，是别的厂家提供
3) 点击“IP Catalog”，默认这些 IP 和都是 Xilinx 提供，现在我们要添加第三方 IP，或者我们
自己做的 IP
color_bar HS/VS/DE video_pll video_clk video_clk5x sys_clk 8位R数据 encode encode encode 8位G数据 8位B数据 video_clk video_clk video_clk 10位B数据 10位G数据 10位R数据 DataSeria lizer Tmds_clk_p/n Tmds_data0_p/n Tmds_data1_p/n Tmds_data2_p/n 10'b1111100000 video_clk5x DataSeria lizer DataSeria lizer ClockSeri alizer video_clk5x video_clk5x video_clk5x
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 211 / 285
4) 右键“Add Repository...”
5) 路径选择刚才复制的 repo 文件夹
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 212 / 285
6) 添加 IP 成功提示添加了多少个 IP
7) 找到“RGB to DVI Video Encoder(Source)”，双击
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 213 / 285
8) 弹出下面窗口，“Component Name”元件名保持不变，其他参数也不用改，点击“OK”
9) 弹出一个“Generate Output Products”窗口，其中“Number of jobs”指线程数量，越高越
快
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 214 / 285
10) 可以看到一个名为 rgb2dvi_0
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 215 / 285
17.2.2 添加像素时钟 PLL 模块
为了驱动 HDMI 编码器，需要提供像素时钟和 5 倍像素时钟，5 倍像素时钟用于 10:1 串行
化。
1) 在“IP Catlog”窗口搜索关键字“clock”，双击“Clocking Wizard”
2) 这次给元件起个名字，在“Component Name”中填写“video_clock”，“clk_in1”填写
50，这里 50Mhz 和开发板 PL 端晶振频率一致。
3) 输出时钟“clk_out1”用于视频像素时钟，这里填写 74.25，这是 1280x720@60 分辨率的
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 216 / 285
像素时钟，每一种分辨率的像素时钟都不同，需要非常了解视频标准才能知道每一种视频
分辨率的像素时钟，“clk_out2”用于编码器串行化，像素时钟的 5 倍，这里填写 371.25，
然后点击“OK”生成 IP。
17.2.3 添加彩条发生模块
4) 彩条发生模块是一段 Verilog 代码，用于产生视频时序和水平方向的 8 个彩条，可以到给
的例程中复制现有代码。在 color_bar 文件中定义了不同分辨率的参数，供用户使用。
添加 video_define 文件，在其中定义了 1280x720 的宏
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 217 / 285
17.2.4 添加顶层模块
5) top 模块例化了彩条发生模块，HDMI 编码模块，和像素时钟生成模块，代码参考例程给
的工程。
添加 XDC 约束文件
添加以下的 xdc 约束文件到项目中，在约束文件里添加了时钟和 HDMI 相关的管脚。
set_property PACKAGE_PIN U18 [get_ports {sys_clk}]
set_property IOSTANDARD LVCMOS33 [get_ports {sys_clk}]
create_clock -period 20.000 -waveform {0.000 10.000} [get_ports sys_clk]
set_property IOSTANDARD TMDS_33 [get_ports TMDS_clk_n]
set_property PACKAGE_PIN N18 [get_ports TMDS_clk_p]
set_property IOSTANDARD TMDS_33 [get_ports TMDS_clk_p]
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_n[0]}]
set_property PACKAGE_PIN V20 [get_ports {TMDS_data_p[0]}]
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_p[0]}]
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_n[1]}]
set_property PACKAGE_PIN T20 [get_ports {TMDS_data_p[1]}]
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 218 / 285
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_p[1]}]
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_n[2]}]
set_property PACKAGE_PIN N20 [get_ports {TMDS_data_p[2]}]
set_property IOSTANDARD TMDS_33 [get_ports {TMDS_data_p[2]}]
set_property PACKAGE_PIN V16 [get_ports hdmi_oen]
set_property IOSTANDARD LVCMOS33 [get_ports hdmi_oen]
下载调试
保存工程并编译生成 bit 文件，连接 HDMI 接口到 HDMI 显示器，需要注意，这里使用
1280x720@60Hz，请确保自己的显示器支持这个分辨率。
AX7020/AX7010 硬件连接图
下载后显示器显示如下图像
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 219 / 285
实验总结
本实验初步接触到视频显示，涉及到视频知识，这不是 zynq 学习的重点，zynq 在视频处
理领域用途广泛，需要学习者有良好的基础知识。实验中仅仅使用 PL 来驱动 HDMI 芯片，初
步学习了第三方自定 IP 的用法，后面我们会学习如何自定义 IP。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 220 / 285
第十八章 HDMI 字符显示实验
实验 Vivado 工程为“hdmi_char”。 在 HDMI 输出实验中讲解了 HDMI 显示原理和显示方式，本实验介绍如何使用 FPGA 实现字
符显示，通过这个实验更加深入的了解 HDMI 的显示方式。
实验原理
实验通过字符转换工具将字符转换为 16 进制 coe 文件存放到单端口的 ROM IP 核中，再从
ROM 中把转换后的数据读取出来显示到 HDMI 上。
程序设计
字符显示例程是在 HDMI 显示的基础上增加了一个 osd_display 的模块，“osd_display”模块
是用来读取存储在 Rom ip 核里转换后的字符信息，并在指定区域显示。程序框图如下图所示：
 1） 在“timing_gen_xy”模块是根据 HDMI 时序标准定义了“x_cnt”和“y_cnt”两个计数器并由
这两个计数器产生了 HDMI 显示的“x”坐标和“y”坐标。程序中用“vs_edge”和“de_falling”
分别表示场同步开始信号和数据有效结束信号。其原理如下图所示：
信号名称 方向 说明
osd_display encode video_clk encode encode 8位B数据 video_clk video_clk video_clk 10位B数据 10位G数据 10位R数据 DataSeria lizer Tmds_clk_p/n Tmds_data0_p/n Tmds_data1_p/n Tmds_data2_p/n 10'b1111100000 osd_rom timing_gen_ xy video_clk5x DataSeria lizer DataSeria lizer ClockSeri alizer video_clk5x video_clk5x video_clk5x color_bar HS/VS/DE video_pll video_clk video_clk5x sys_clk 8位R数据 8位G数据 8位B数据 HS/VS/DE
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 221 / 285
rst_n in 异步复位输入,低复位
clk in 外部时钟输入
i_hs in 行同步信号
i_vs in 场同步信号
i_de in 数据有效信号
i_data in color_bar 数据
o_hs out 输出行同步信号
o_vs out 输出场同步信号
o_de out 输出数据有效信号
o_data out 输出数据
x out 生成 X 坐标
y out 生成 Y 坐标
timing_gen_xy 模块端口
2） 下面介绍如何存储文字信息的 ROM IP，首先需要生成能够被 XILINX FPGA 识别的.coe 文件。
首先在工程文件夹下找到“FPGA 字模提取”工具。
双击.exe 文件打开工具
 
在提取工具的“字符输入”框中输入需要显示的字符，字体和字符高度可以自定义选择。
设置完成后点击“转换”按钮，在界面左下角可以看到转换后的字符点阵大小，点阵的宽和高
在程序中是需要用到的
 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 222 / 285
点阵的宽和高这里位 144x32,需要跟 osd_display 程序中定义的一致：
点击“保存”按钮，将文件保存到本例程源文件目录下，需要注意的是在保存类型下应该
选择 Xilinx（*.coe）,点击“保存”按钮。
回到字符提取工具界面出现如下对话框表示保存完成，点击确定，退出即可
 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 223 / 285
找到生成的.coe 文件打开后可以看到如下：
调用单端口 Rom IP 核的过程在前面 ROM 的使用中已经介绍过，设置为 Single Port ROM
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 224 / 285
在 PortA Options 栏中设置如下：
 按如下图添加 osd.coe 文件（找到前面生成的 coe 文件），完成后点击“OK”按钮： 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 225 / 285
3） osd_display 模块包含 timing_gen_xy 模块和 osd_rom 模块。osd_rom 里存储的字符数据，如
果数据为 1，OSD 的区域显示 ROM 中的前景红色（显示 ALINX 芯驿），如果数据是 0，OSD
的区域显示数据为背景色（彩条）。
设置区域有效信号，也就是字符显示在此区域中，起始坐标设置成（9，9），区域大小可以
根据字符生成工具设置的区域设置。
在 ROM 的读地址部分可能很多人不理解，为什么是[15:3]，也就是八个时钟周期才读出一
个数据，这是因为字符的一个点只表示 1bit，而 ROM 的存储数据宽度是 8 位，因此需要八个周
期取出一个数据，并比较每个 bit 位的值，将字符一个点转换成图像上的一个像素。
信号名称 方向 说明
rst_n in 异步复位输入,低复位
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 226 / 285
pclk in 外部时钟输入
i_hs in 行同步信号
i_vs in 场同步信号
i_de in 数据有效信号
i_data in color_bar 数据
o_hs out 输出行同步信号
o_vs out 输出场同步信号
o_de out 输出数据有效信号
o_data out 输出数据
osd_display 模块端口
实验现象
连接好开发板和显示器，连接方式参考《HDMI 输出实验》教程，需要注意，开发板的各
个连接器不要带电热插拔，下载好实验程序，可以看到显示器显示以彩条为背景的字符。开发
板作为 HDMI 输出设备，只能通过 HDMI 显示设备来显示，不要试图通过笔记本电脑的 HDMI
接口来显示，因为笔记本也是输出设备。
AX7020/AX7010 硬件连接图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 227 / 285
默认字符显示的位置在坐标为（9，9），另外用户可以修改下面的 pos_y 和 pos_x 的判断
条件将字符显示在显示屏的任意位置：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 228 / 285
第十九章 HDMI 时钟显示实验
实验 Vivado 工程为“hdmi_rtc_char”。
本章在字符显示实验基础上，通过阅读 DS1302 芯片手册，了解 DS1302 操作时序和相关
寄存器，然后设计程序将 DS1302 RTC 时间通过 HDMI 显示出来，类似于一个电子钟。
实验原理
RTC（Real-Time Clock)实时时钟为系统提供一个可靠的时间，并且在断电的情况下，RTC 实
时时钟也可以通过电池供电，一直运行下去。RTC 通过类 SPI 总线向 FPGA 传送 8 位数据（BCD
码）。数据包括秒，分，小时，日期，天，月和年。在本实验中我们将读取 RTC 的时,分,秒的数
据并在数码管中显示时间。
硬件介绍
开发板上 RTC 设计采用 DALLAS 公司的低功耗实时时钟芯片 DS1302, DS1302 的 VCC2 为主
电源，VCC1 为后备电源。在主电源关闭的情况下，也能可以通过电池保持时钟的连续运行。
DS1302 外接 32.768kHz 晶振为 RTC 电路提供振荡源。 RTC 部分的原理图如下图所示：
DS1302 的时序和控制
19.3.1 写数据时序
其接口部分类似于 SPI 接口，但不同之处是其数据接口是双向的。DS1302 芯片写操作的时
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 229 / 285
序图。第一个字节是“访问寄存器的地址”，第二字节是“写数据”。在写操作的时候，都是
“上升沿有效”，然而还有一个条件，就是 CE（/RST）信号必须拉高。（数据都是从 LSB 开始发
送，亦即是最低位开始至最高位结束）。
DS1302 写时序
19.3.2 读数据时序
基本上和写操作的时序图大同小异，区别的地方就是在第二个字节是“读数据”的动作。
第二字节读数据开始时，SCLK 信号都是下降沿送出数据，这个时候可以使用上升沿读取数
据。CE（/RST）信号同样是必须拉高。（第一节数据是从 LSB 开始输出，第二节数据是从 LSB
开始读入）。
DS1302 读时序
19.3.3 命令格式和寄存器
无论是读操作还是写操作，在时序图中，第一个字节都是“访问寄存器的地址”，然而这一
字节数据有自己的格式。
BIT 7 固定。 BIT 6 表示是访问寄存器本身，还是访问 RAM 空间。 BIT 5 到 BIT1 表示是
寄存器或 RAM 空间的地址。 BIT 0 表示是访问寄存器本身是写操作，还是读操作。
下图是 DS1302 的寄存器地址和数据格式
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 230 / 285
程序设计
19.4.1 DS1302 读写设计
通过分析 DS1302 读写时序，可以看出和 SPI 时序类似，只不过数据输出和输入分时复用
了，spi master 状态机设计，主要完成一个字节 spi 数据的读写，由于是全双工的，写一个字节
的同时也读一个字节。首先空闲状态“IDLE”接收到写请求后进入“DCLK_IDLE”状态，这个状
态为 spi 时钟沿变化保持一定的时间，用来控制 spi 时钟的周期，然后进入 spi 时钟沿的变化状
态，一个字节上升沿和下降沿一共 16 个数据沿。在最后一个数据沿进入“LAST_HALF_CYCLE”
状态，为让最后一个沿也保持一定的时间，再进入应答状态，完成一次写请求。 rtc_osd encode video_clk encode encode 8位B数据 video_clk video_clk video_clk 10位B数据 10位G数据 10位R数据 DataSeria lizer Tmds_clk_p/n Tmds_data0_p/n Tmds_data1_p/n Tmds_data2_p/n 10'b1111100000 char_repo timing_gen_ xy video_clk5x DataSeria lizer DataSeria lizer ClockSeri alizer video_clk5x video_clk5x video_clk5x color_bar HS/VS/DE video_pll video_clk video_clk5x sys_clk 8位R数据 8位G数据 8位B数据 HS/VS/DE rtc_sclk rtc_ce rtc_data 24位RTC数据 spi_master ds1302_io ds1302_cmd ds1302
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 231 / 285
spi master 模块状态图
spi_master 模块中模拟了一个 spi 时钟，在状态机进入到‘DCLK_EDGE’时进行翻转
//SPI clock edge counter
always@(posedge sys_clk or posedge rst)
begin
if(rst)
clk_edge_cnt <= 5'd0;
else if(state == DCLK_EDGE)
clk_edge_cnt <= clk_edge_cnt + 5'd1;
else if(state == IDLE)
clk_edge_cnt <= 5'd0;
end
信号名称 方向 说明
sys_clk in 时钟输入
rst in 异步复位输入，高复位
nCS out spi 片选信号，等于 nCS_ctrl。
DCLK out spi 串行时钟
MOSI out spi 串行数据输出
MISO in spi 串行数据输入
CPOL in Clock Polarity，spi 时钟的极性
0：空闲状态为 0 1：空闲状态为 1
CPHA in Clock Phase，spi 时钟的相位，
0：第一个沿采样，
1：第二个沿采样
nCS_ctrl in nCS 控制
clk_div in spi 时钟频率控制
spi 时钟=系统时钟/(2*（2+ clk_div）)
clk_div 最小值可以为 0，当为 0 时，spi 时钟是系统
时钟的 1/4
wr_req in 写一个字节请求
wr_ack out 写应答，高有效
data_in in 数据
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 232 / 285
data_out out 返回的数据，当写应答时有效
spi master 端口说明
ds1302_io 模块完成 DS1302 寄存器读写控制，状态机如下图所示。
状态“S_IDLE”空闲状态，收到读写寄存器请求写进入“S_CE_HIGH”状态，将 CE 拉高，
然后根据请求类型，进入读（S_READ）或写状态(S_WRITE)。 “S_WRITE”状态下一个状态进入写地址状态“S_WRITE_ADDR”,再进入写数据状态
“S_WRITE_DATA”，完成一个寄存器的写入，最后应答，拉低 CE。 “S_READ”状态下一个状态进入读地址状态“S_READ_ADDR”,再进入读数据状态
“S_READ_DATA”，完成一个寄存器的读取，最后应答，拉低 CE。
ds1302_io 状态机
信号名称 方向 说明
clk in 时钟输入
rst in 异步复位输入，高复位
ds1302_ce out DS1302 CE，高有效
ds1302_sclk out DS1302 串行时钟
ds1302_io inout DS1302 数据
cmd_read in 读寄存器请求，发出请求时准备好地址
cmd_write in 写寄存器请求，发出请求时准备好地址和数据
cmd_read_ack out 读寄存器应答，应答时读取数据有效
cmd_write_ack out 写寄存器应答
read_addr in 读寄存器地址
write_addr in 写寄存器地址
read_data out 读出的数据
write_data in 写寄存器数据
ds1302_io 端口
ds1302 模块主要完成时间寄存器的读写控制，状态机状态较为简单。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 233 / 285
ds1302 模块状态机
信号名称 方向 说明
clk in 时钟输入
rst in 异步复位输入，高复位
ds1302_ce out DS1302 CE，高有效
ds1302_sclk out DS1302 串行时钟
ds1302_io inout DS1302 数据
write_time_req in ds1302 写时间请求，请求发出时，时间数据
write_second、write_minute、write_hour、
write_date、write_month、write_week、write_year
要有效
write_time_ack out 写时间请求应答
write_second in 写时间：秒，BCD 码，00-59
write_minute in 写时间：分，BCD 码,，00-59
write_hour in 写时间：时，BCD 码,，00-23
write_date in 写时间：日，BCD 码,，01-31
write_month in 写时间：月，BCD 码,，01-12
write_week in 写时间：周，BCD 码,，01-07
write_year in 写时间：年，BCD 码,，00-99
read_time_req in 读时间请求
read_time_ack out 读时间请求应答
read_second out 读时间：秒，BCD 码，00-59
read_minute out 读时间：分，BCD 码,，00-59
read_hour out 读时间：时，BCD 码,，00-23
read_date out 读时间：日，BCD 码,，01-31
read_month out 读时间：月，BCD 码,，01-12
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 234 / 285
read_week out 读时间：周，BCD 码,，01-07
read_year out 读时间：年，BCD 码,，00-99
ds1302 模块端口
ds1302_test 模块主要 CH 状态检测，CH 位于秒寄存器的 BIT7 位，上电后首先读取时间，
判断秒寄存器的 CH 状态，如果为高，表示 DS1302 暂停，状态机进入“S_WRITE_CH”，将 CH
写 0，并将一个初始时间写入，然后循环不断的读取时间寄存器。
ds1302_test 状态机
信号名称 方向 说明
clk in 时钟输入
rst in 异步复位输入，高复位
ds1302_ce out DS1302 CE，高有效
ds1302_sclk out DS1302 串行时钟
ds1302_io inout DS1302 数据
read_second out 时间：秒，BCD 码，00-59
read_minute out 时间：分，BCD 码，00-59
read_hour out 时间：时，BCD 码，00-23
read_date out 时间：日，BCD 码，01-31
read_month out 时间：月，BCD 码，01-12
read_week out 时间：周，BCD 码，01-07
read_year out 时间：年，BCD 码，00-99
ds1302_test 端口
19.4.2 字符叠加设计
参考前面字符叠加实验，由于前面的实验字符是静态的，而本节需要将 RTC 的数据动态的
显示出来，因此一个字符显示区域的内容是可变的，我们需要做字符库。也就是 0~9 以及分隔
符”:”，考虑到字符较多，如果放在一个 ROM 里不容易调用。因此不再用例化 ROM 的方式，
而是采用 case 语句制作字符库 char_repo.v。比如在下面的图中即是数字 0 的字符库表达式。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 235 / 285
至于字符库的数据也是由“FPGA 字模提取”软件产生的，点阵宽 x 高为 16x32，也就
是 64 个字节。
程序中的 char_addr_sel 用来选择用哪个字符，0~9 对应数字 0~9，10 对应“：”
信号名称 方向 说明
clk in 时钟输入
char_addr_sel in 用来选择字符，0~9 对应数字 0~9，10 对应”:”
char_addr in 字符数据地址
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 236 / 285
char_data out 字符数据
char_repo 模块接口信号
rtc_osd.v 是用来将 RTC 的数据叠加到彩条上的，并设置了以下一些参数，由于一个字符宽
度是 16，也就是 16 个像素点，因此将两个字符间隔设置为 16。
由于时分秒加上分隔符共 8 个字符，因此产生出八个显示有效区域
根据 RTC 数据值，进行字符选择信号的译码
信号名称 方向 说明
rst_n in 异步复位输入,低复位
pclk in 外部时钟输入
rtc_data In RTC 数据，24bit，分别为时分秒数据
i_hs in 行同步信号
i_vs in 场同步信号
i_de in 数据有效信号
i_data in color_bar 数据
o_hs out 输出行同步信号
o_vs out 输出场同步信号
o_de out 输出数据有效信号
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 237 / 285
o_data out 输出数据
rtc_osd 模块信号
实验现象
连接好下载线，HDMI 线，将程序下载到板子上以后，可以看到 HDMI 显示器背景为彩
条，在左上方会显示时间，每秒会变一下。
AX7020/AX7010 硬件连接图
纽扣电池型号为 CR1220，安装时注意正极朝上，取下时用镊子拨动黄色弹片，即可弹出
电池。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 238 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 239 / 285
第二十章 7 寸液晶屏显示实验
实验 Vivado 工程为“lcd7_test”。
基于 HDMI 输出实验，本章介绍 7 寸液晶屏的显示。
硬件介绍
AN970 LCD 触摸屏模块由 TFT 液晶屏，电容触摸屏和驱动板组成，详细信息查看
AN970 用户手册。AN970 实物照片如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 240 / 285
1. LCD 屏的驱动时序
LCD 屏显示方式从屏幕左上角一点开始，从左向右逐点显示，每显示完一行,再回到屏幕
的左边下一行的起始位置，在这期间，需要对行进行消隐，每行结束时，用行同步信号进行同
步；LCD 的驱动有两种方式，一种为 HV 模式，另一种为 DE 模式，这两种模式都能驱动 LCD
屏，数据在 DCLK 的上升沿采样。以下为行显示的时序图：
LCD 行的显示时序参数如下表所示：
当显示完所有的行，形成一帧，用场同步信号进行场同步，并使 LCD 显示回到屏幕左上
方，同时进行场消隐,开始下一帧。以下为列显示的时序图：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 241 / 285
LCD 列的显示时序参数如下表所示：
程序设计
本章实验其实很简单，与 HDMI 显示最大的不同是不需要 rgb 转 dvi 的模块，输出按照
RGB 即可。以下是文件结构，去掉了 rgb2dvi 模块。
同时因为液晶屏的分辨率是 800x480，需要修改 video_define.v 的宏定义。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 242 / 285
同时将 PLL 的输出时钟频率修改为 33MHz，即 800x480 的像素时钟。
同时在 top.v 中例化了 ax_pwm，用于调节液晶屏的亮度，设置为 200Hz，30%点空比。
实验现象
连接液晶屏到 J11 扩展口，下载程序，即可看到彩条显示。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 243 / 285
同时也准备了字符显示和 RTC 显示的例程：
字符显示
RTC 显示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 244 / 285
第二十一章 AD7606 多通道波形显示实验
实验 Vivado 工程为“ad7606_hdmi_test”。
本实验练习使用 ADC，实验中使用的 ADC 模块型号为 AN706，最大采样率 200Khz，精度为
16 位。实验中把 AN706 的 2 路输入以波形方式在 HDMI 上显示出来，我们可以用更加直观的方
式观察波形，是一个数字示波器雏形。
8 路 200K 采样 16 位 ADC 模块
实验预期结果
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 245 / 285
实验原理
AD7606是一款集成式8通道同步采样数据采集系统，片内集成输入放大器、过压保护电路、
二阶模拟抗混叠滤波器、模拟多路复用器、16 位 200 kSPS SAR ADC 和一个数字滤波器, 2.5 V 基
准电压源、基准电压缓冲以及高速串行和并行接口。
AD7606 采用+5V 单电源供电, 可以处理±10V 和±5V 真双极性输入信号, 同时所有通道均
以高达 200KSPS 的吞吐速率采样。输入钳位保护电路可以耐受最高达±16.5V 的电压。
无论以何种采样频率工作, AD7606 的模拟输入阻抗均为 1M 欧姆。它采用单电源工作方式, 
具有片内滤波和高输入阻抗, 因此无需驱动运算放大器和外部双极性电源。
AD7606 抗混叠滤波器的 3dB 截至频率为 22kHz; 当采样速率为 200kSPS 时, 它具有 40dB 抗
混叠抑制特性。灵活的数字滤波器采用引脚驱动, 可以改善信噪比(SNR), 并降低 3dB 带宽。
21.1.1 AD7606 时序
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 246 / 285
AD7606 可以对所有 8 路的模拟输入通道进行同步采样。当两个 CONVST 引脚(CONVSTA 和
CONVSTB)连在一起时， 所有通道同步采样。此共用 CONVST 信号的上升沿启动对所有模拟输入
通道的同步采样(V1 至 V8)。
AD7606 内置一个片内振荡器用于转换。所有 ADC 通道的转换时间为 tCONV。BUSY 信号告
知用户正在进行转换， 因此当施加 CONVST 上升沿时，BUSY 变为逻辑高电平， 在整个转换过
程结束时变成低电平。BUSY 信号下降沿用来使所有八个采样保持放大器返回跟踪模式。BUSY 下
降沿还表示，现在可以从并行总线 DB[15:0]读取 8 个通道的数据。
21.1.2 AD7606 配置
在 AN706 8 通道的 AD 模块硬件电路设计中，我们对 AD7606 的 3 个配置 Pin 脚通过加上拉
或下拉电阻来设置 AD7606 的工作模式。
AD7606 这款芯片支持外部基准电压输入或内部基准电压。如果使用外部基准电压，芯片的
REFIN/REFOUT 需要外接一个 2.5V 的基准源。如果使用内部的基准电压。REFIN/REFOUT 引脚为
2.5V 的内部基准电压输出。REF SELECT 引脚用于选择内部基准电压或外部基准电压。在本模块
中，因为考虑到 AD7606 的内部基准电压的精度也非常高（2.49V~2.505V)，所以电路设计选择使
用了内部的基准电压。
Pin 脚名 设置电平 说明
REF SELECT 高电平 使用内部的基准电压 2.5V
AD7606 的 AD 转换数据采集可以采用并行模式或者串行模式， 用户可以通过设置
PAR/SER/BYTE SEL 引脚电平来设置通信的模式。我们在设计的时候，选择并行模式读取 AD7606
的 AD 数据。
Pin 脚名 设置电平 说明
PAR/SER/BYTE SEL 低电平 选择并行接口
AD7606 的 AD 模拟信号的输入范围可以设置为±5V 或者是±10V，当设置±5V 输入范围时，
1LSB=152.58uV；当设置±10V 输入范围时，1LSB=305.175uV 。用户可以通过设置 RANGE 引脚电
平来设置模拟输入电压的范围。我们在设计的时候，选择±5V 的模拟电压输入范围。
Pin 脚名 设置电平 说明
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 247 / 285
RANGE 低电平 模拟信号输入范围选择：±5V
AD7606 内置一个可选的数字一阶 sinc 滤波器，在使用较低吞吐率或需要更高信噪比的应用
中，应使用滤波器。数字滤波器的过采样倍率由过采样引脚 OS[2:0]控制。下表提供了用来选择
不同过采样倍率的过采样位解码。
在 AN706 模块的硬件设计中, OS[2:0] 已经引到外部的接口中，FPGA 或 CPU 可以通过控制
OS[2:0]的管脚电平来选择是否使用滤波器，以达到更高的测量精度。
21.1.3 AD7606 AD 转换
AD7606 的输出编码方式为二进制补码。所设计的码转换在连续 LSB 整数的中间(既 1/2LSB
和 3/2LSB)进行。AD7606 的 LSB 大小为 FSR/65536。AD7606 的理想传递特性如下图所示：
程序设计
本实验显示部分是基于前面的 HDMI 显示彩条的实验，在彩条上叠加网格线和波形, 整个
项目的框图如下图所示：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 248 / 285
grid_di splay rgb2d vi TMDS HDMI显示 器 video_pll wav_dis play wave1_r wave1_g wave1_b wave1_hs wave1_vs wave1_de wave0_r wave0_g wave0_b wave0_hs wave0_vs wave0_de wav_dis play 第一路 AD波形叠加 第二路 AD波形叠加 ad7606_sa mple ad7606_sa mple 通道2采集 通道1采集 grid_r grid_g grid_b grid_hs grid_vs grid_de color_b ar 网格线叠加 video_r video_g video_b video_hs video_vs video_de AN706模块 adc_pll ad7606_if
ad7606_if 模块为 AN706 的接口模块，完成 AD706 输入的 8 路 AD 的数据采集，按照
AD706 芯片的时序产生 AD 转换信号 ad_convstab，等待 ADC 忙信号无效后，产生片选信号，
依次读取 8 路 AD 数据。
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低复位
adc_data in 16 ADC 数据输入
ad_busy in 1 ADC 忙信号
first_data in 1 第一通道数据指示信号
ad_os out 3 ADC 过采样
ad_cs out 1 ADC 片选
ad_rd out 1 ADC 读信号
ad_reset out 1 ADC 复位信号
ad_convstab out 1 ADC 转换信号
adc_data_valid in 1 ADC 数据有效
ad_ch1 out 16 ADC 通道 1 数据
ad_ch2 out 16 ADC 通道 2 数据
buf_data buf_addr buf_wr buf_data buf_addr buf_wr
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 249 / 285
ad_ch3 out 16 ADC 通道 3 数据
ad_ch4 out 16 ADC 通道 4 数据
ad_ch5 out 16 ADC 通道 5 数据
ad_ch6 out 16 ADC 通道 6 数据
ad_ch7 out 16 ADC 通道 7 数据
ad_ch8 out 16 ADC 通道 8 数据
ad7606_sample 模块主要完成 ad706 的单路数据转换。首先需要对输入数据转换为无符号
数，最后的数据只取高 8 位的数据，数据宽度转换到 8bit（为了跟其它 8 位的 AD 模块程序兼
容）。另外每次采集 1280 个数据，然后等待一段时间再继续采集下面的 1280 个数据。
信号名称 方向 宽度
(bit)
说明
adc_clk in 1 adc 系统时钟
rst in 1 异步复位，高复位
adc_data in 16 ADC 数据输入
adc_data_valid in 1 adc 数据有效
adc_buf_wr out 1 ADC 数据写使能
adc_buf_addr out 12 ADC 数据写地址
adc_buf_data out 8 无符号 8 位 ADC 数据
ad7606_sample 模块端口
grid_display 模块主要完成视频图像的网格线叠加，本实验将彩条视频输入，然后叠加一个
网格后输出， 这一块网格区域提供给后面的波形显示模块使用，这个网格区域是位于显示器水
平方向（从左到右）从 9 到 1018，垂直方向（从上到下）从 9 到 308 的视频显示位置。
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
grid_display 模块端口
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 250 / 285
wav_display 显示模块主要是完成波形数据的叠加显示，模块内含有一个双口 ram，写端口
是由 ADC 采集模块写入，读端口是显示模块。在网格显示区域有效的时候，每行显示都会读
取 RAM 中存储的 AD 数据值，跟 Y 坐标比较来判断显示波形或者不显示。
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
wave_color in 24 波形颜色，rgb
adc_clk in 1 adc 模块时钟
adc_buf_wr in 1 adc 数据写使能
adc_buf_addr in 12 adc 数据写地址
adc_buf_data in 8 adc 数据，无符号数
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
wav_display 模块端口
RAM 的配置如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 251 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 252 / 285
timing_gen_xy 模块为其它模块的子模块，完成视频图像的坐标生成，x 坐标，从左到右增
大，y 坐标从上到下增大。
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 视频行同步输出
o_vs out 1 视频场同步输出
o_de out 1 视频数据有效输出
o_data out 24 视频数据输出
x out 12 坐标 x 输出
y out 12 坐标 y 输出
timing_gen_xy 模块端口
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 253 / 285
实验现象
连接电路如下，插入 AN706 模块，连接 SMA 到波形发生器，为了方便观察显示效果，波
形发生器采样频率设置范围为 500Hz~10KHz，电压幅度最大为 10V，结果即为本章最前面的效
果图。
AX7020/AX7010 硬件连接图（J11 扩展口）
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 254 / 285
第二十二章 AD9238 双通道波形显示实验
实验 Vivado 工程为“ad9238_hdmi_test”。
硬件介绍
22.1.1 两通道 AD 模块说明
黑金高速 AD 模块 AN9238 为 2 路 65MSPS， 12 位的模拟信号转数字信号
模块。模块的 AD 转换采用了 ADI 公司的 AD9238 芯片， AD9238 芯片支持 2 路 AD 输入转换，所以 1 片 AD9238 芯片一共支持 2 路的 AD 输入转换。模拟信
号输入支持单端模拟信号输入，输入电压范围为-5V~+5V，接口为 SMA 插座。
模块有一个标准 2.54mm 间距的 40 针的排母，用于连接 FPGA 开发板，
AN9238 模块实物照片如下：
 AN9238 模块实物图
参数说明
以下为 AN9238 高速 AD 模块的详细参数:  AD 转换芯片：1 片 AD9238
 AD 转换通道：2 路;  AD 采样速率： 65MSPS；  AD 采样数据位数： 12 位；
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 255 / 285
 数字接口电平标准：+3.3V 的 CMOS 电平
 AD 模拟信号输入范围：-5V~+5V；  模拟信号输入接口：SMA 接口；
 测量精度：10mV 左右；
 工作温度：-40°~85°；
22.1.2 模块功能说明
AN9238 模块的原理设计框图如下：
针排母连接器针排母连接器
关于 AD9238 的电路具体参考设计请参考 AD9238 的芯片手册。
1) 单端输入及运放电路
单端输入 AD1 和 AD2 通过 J5 或者 J6 两个 SMA 头输入，单端输入的电压为
-5V~+5V。
板上通过运放 AD8065 芯片和分压电阻把-5V~+5V 输入的电压缩小成-
1V~+1V。如果用户想输入更宽范围的电压输入只要修改前端的分压电阻的阻值。
4040 双通道AD芯片 AD9238 SMA 接口 12位AD2数据 单端转差 分AD8138 运放 AD8065 AD1输入 SMA 接口 单端转差 分AD8138 运放 AD8065 AD2输入 65M AD2时钟 SMA 接口SMA 接口SMA 接口SMA 接口 12位AD1数据 65M AD1时钟
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 256 / 285
下表为模拟输入信号和 AD8065 运放输出后的电压对照表：
AD 模拟输入值 AD8065 运放输出
-5V -1V
0V 0V
+5V +1V
2) 单端转差分及 AD 转换
-1V~+1V 的输入电压通过 AD8138 芯片转换成差分信号（VIN+ − VIN
−）， 差分信号的共模电平由 AD 的 CML 管脚决定。
下表为模拟输入信号到 AD8138 差分输出后的电压对照表：
AD 模拟输入值 AD8065 运放输出 AD8138 差分输出（VIN+−
VIN−） -5V -1V -1V
0V 0V 0V
+5V +1V +1V
3) AD9238 转换
默认 AD 是配置成 offset binary 的，AD 转换的值如下图所示：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 257 / 285
在模块电路设计中，AD9238 的 VREF 的值为 1V，这样最终的模拟信号输入
和 AD 转换的数据如下：
AD 模拟输
入值
AD8055 运放
输出
AD8138 差分输出
（VIN+−VIN−）
AD9238 数字
输出
-5V -1V -1V 000000000000
0V 0V 0V 100000000000
+5V +1V +1V 11111111111
从表中我们可以看出，-5V 输入的时候，AD9238 转换的数字值最小，+5V
输入的时候，AD9238 转换的数字值最大。
4) AD9238 数字输出时序
AD9238 双通道 AD 的数字输出为+3.3V 的 CMOS 输出模式，2 路通道(A 和 B）独立的数据和时钟。AD 数据在时钟的上降沿转换数据，FPGA 端可用 AD 时
钟的采样 AD 数据。
程序设计
本实验显示部分是基于前面的 HDMI 显示彩条的实验，在彩条上叠加网格线和波形, 整个
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 258 / 285
项目的框图如下图所示：
ad9238_sample 模块主要完成 AN9238 的单路数据转换。最后的数据只取高 8 位的数据，
数据宽度转换到 8bit（为了跟其它 8 位的 AD 模块程序兼容）。另外每次采集 1280 个数据，然
后等待一段时间再继续采集下面的 1280 个数据。
信号名称 方向 宽度
(bit)
说明
adc_clk in 1 adc 系统时钟
rst in 1 异步复位，高复位
adc_data in 12 ADC 数据输入
adc_buf_wr out 1 ADC 数据写使能
adc_buf_addr out 12 ADC 数据写地址
adc_buf_data out 8 无符号 8 位 ADC 数据
ad7606_sample 模块端口
grid_display 模块主要完成视频图像的网格线叠加，本实验将彩条视频输入，然后叠加一个
网格后输出， 这一块网格区域提供给后面的波形显示模块使用，这个网格区域是位于显示器水
平方向（从左到右）从 9 到 1018，垂直方向（从上到下）从 9 到 308 的视频显示位置。
buf_data buf_addr buf_wr buf_data buf_addr buf_wr grid_di splay rgb2d vi TMDS HDMI显示 器 video_pll wav_dis play wave1_r wave1_g wave1_b wave1_hs wave1_vs wave1_de wave0_r wave0_g wave0_b wave0_hs wave0_vs wave0_de wav_dis play 第一路 AD波形叠加 第二路 AD波形叠加 ad9238_sa mple ad9238_sa mple 通道2采集 通道1采集 grid_r grid_g grid_b grid_hs grid_vs grid_de color_b ar 网格线叠加 video_r video_g video_b video_hs video_vs video_de AN9238模块 adc_pll
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 259 / 285
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
grid_display 模块端口
wav_display 显示模块主要是完成波形数据的叠加显示，模块内含有一个双口 ram，写端口
是由 ADC 采集模块写入，读端口是显示模块。在网格显示区域有效的时候，每行显示都会读
取 RAM 中存储的 AD 数据值，跟 Y 坐标比较来判断显示波形或者不显示。
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
wave_color in 24 波形颜色，rgb
adc_clk in 1 adc 模块时钟
adc_buf_wr in 1 adc 数据写使能
adc_buf_addr in 12 adc 数据写地址
adc_buf_data in 8 adc 数据，无符号数
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 260 / 285
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
wav_display 模块端口
RAM 的配置如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 261 / 285
timing_gen_xy 模块为其它模块的子模块，完成视频图像的坐标生成，x 坐标，从左到右增
大，y 坐标从上到下增大。
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 视频行同步输出
o_vs out 1 视频场同步输出
o_de out 1 视频数据有效输出
o_data out 24 视频数据输出
x out 12 坐标 x 输出
y out 12 坐标 y 输出
timing_gen_xy 模块端口
实验现象
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 262 / 285
连接电路如下，调节信号发生器的频率和幅度，AN9238 输入范围-5V-5V，为了便于观察
波形数据，建议信号输入频率 200Khz 到 1Mhz。观察显示器输出，红色波形为 CH1 输入、
蓝色为 CH2 输入、黄色网格最上面横线代表 5V，最下面横线代表-5V，中间横线代表 0V，
每个竖线间隔是 10 个采样点。
AX7020/AX7010 硬件连接图（J11 扩展口）
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 263 / 285
第二十三章 ADDA 测试实验
实验 Vivado 工程为“an108_adda_hdmi_test”。
本实验练习使用 ADC 和 DAC，实验中使用的 ADDA 模块型号为 AN108，ADC 最大采样率
32Mhz，精度为 8 位，DAC 最大采样率 125Mhz，精度为 8 位。实验中用 DAC 输出正弦波，然后
使用 ADC 采集并把波形在 HDMI 显示器显示。
ADDA 模块
实验预期结果
硬件介绍
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 264 / 285
23.1.1 数模转换（DA）电路
如硬件结构图所示，DA 电路由高速 DA 芯片、7 阶巴特沃斯低通滤波器、幅度调节电路和
信号输出接口组成。
我们使用的高速 DA 芯片是 AD 公司推出的 AD9708。AD9708 是 8 位，125MSPS 的 DA 转换
芯片，内置 1.2V 参考电压，差分电流输出。芯片内部结构图如下图所示
AD9708 芯片差分输出以后，为了防止噪声干扰，电路中接入了 7 阶巴特沃斯低通滤波器，
带宽为 40MHz，频率响应如下图所示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 265 / 285
滤波器参数如下图所示
滤波器之后，我们使用了 2 片高性能 145MHz 带宽的运放 AD8056，实现差分变单端，以及
幅度调节等功能，使整个电路性能得到了最大限度的提升。幅度调节，使用的是 5K 的电位器，
最终的输出范围是-5V~5V（10Vpp）。
注：由于电路器的精度不是很精确，最终的输出有一定误差，有可能波形幅度不能达到
10Vpp，也有可能出现波形削顶等问题，这些都属正常情况。
23.1.2 模数转换（AD）电路
如硬件结构图中所示，AD 电路由高速 AD 芯片、衰减电路和信号输入接口组成。
我们使用的高速 AD 芯片是由 AD 公司推出的 8 位，最大采样率 32MSPS 的 AD9280 芯片。
内部结构图如下图所示
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 266 / 285
根据下图的配置，我们将 AD 电压输入范围设置为：0V~2V
在信号进入 AD 芯片之前，我们用一片 AD8056 芯片构建了衰减电路，接口的输入范围是-
5V~+5V(10Vpp)。衰减以后，输入范围满足 AD 芯片的输入范围（0~2V）。转换公式如下：
当输入信号 Vin=5(V)的时候，输入到 AD 的信号 Vad=2(V)；
当输入信号 Vin=-5(V)的时候，输入到 AD 的信号 Vad=0(V)；
程序设计
本实验程序设计跟 AN706 波形显示实验基本类似，只是 ADDA 模块是单通道的 AD，这里
只是一路采集波形的叠加。另外 FPGA 通过 ROM IP 产生正弦波数据输出到 DA 芯片进行 DA 转
换，产生正选波模拟信号，用户只有用 BNC 线把模块的 AD 和 DA 端口连接起来就形成环路。
这样 HDMI 显示器上显示的就是 DA 正选波的信号了。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 267 / 285 grid_di splay rgb2d vi TMDS HDMI显示 器 video_pll wav_dis play wave0_r wave0_g wave0_b wave0_hs wave0_vs wave0_de AD波形叠加 ad9m2p8l0e_sa AD采集 grid_r grid_g grid_b grid_hs grid_vs grid_de color_b ar 网格线叠加 video_r video_g video_b video_hs video_vs video_de ADDA模块 ROM dac_clk adc_pll adc_clk DA输出
ad9280_sample 模块主要完成 ad9280 的 AD 8 位数据采集和转换，每次采集 1280 个数据，
然后等待一段时间再继续采集下次的 1280 个数据。
信号名称 方向 宽度
(bit)
说明
adc_clk in 1 adc 系统时钟
rst in 1 异步复位，高复位
adc_data in 8 ADC 数据输入
adc_buf_wr out 1 ADC 数据写使能
adc_buf_addr out 12 ADC 数据写地址
adc_buf_data out 8 无符号 8 位 ADC 数据
ad9280_sample 模块端口
grid_display 模块主要完成视频图像的网格线叠加，本实验将彩条视频输入，然后叠加一个
网格后输出， 这一块网格区域提供给后面的波形显示模块使用，这个网格区域是位于显示器水
平方向（从左到右）从 9 到 1018，垂直方向（从上到下）从 9 到 308 的视频显示位置。
buf_data buf_addr buf_wr
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 268 / 285
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
grid_display 模块端口
wav_display 显示模块主要是完成波形数据的叠加显示，模块内含有一个双口 ram，写端口
是由 ADC 采集模块写入，读端口是显示模块。在网格显示区域有效的时候，每行显示都会读
取 RAM 中存储的 AD 数据值，跟 Y 坐标比较来判断显示波形或者不显示。
信号名称 方向 宽度
(bit)
说明
pclk in 1 像素时钟
rst_n in 1 异步复位，低电平复位
wave_color in 24 波形颜色，rgb
adc_clk in 1 adc 模块时钟
adc_buf_wr in 1 adc 数据写使能
adc_buf_addr in 12 adc 数据写地址
adc_buf_data in 8 adc 数据，无符号数
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 带网格视频行同步输出
o_vs out 1 带网格视频场同步输出
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 269 / 285
o_de out 1 带网格视频数据有效输出
o_data out 24 带网格视频数据输出
wav_display 模块端口
timing_gen_xy 模块为其它模块的子模块，完成视频图像的坐标生成，x 坐标，从左到右增
大，y 坐标从上到下增大。
信号名称 方向 宽度
(bit)
说明
clk in 1 系统时钟
rst_n in 1 异步复位，低电平复位
i_hs in 1 视频行同步输入
i_vs in 1 视频场同步输入
i_de in 1 视频数据有效输入
i_data in 24 视频数据输入
o_hs out 1 视频行同步输出
o_vs out 1 视频场同步输出
o_de out 1 视频数据有效输出
o_data out 24 视频数据输出
x out 12 坐标 x 输出
y out 12 坐标 y 输出
timing_gen_xy 模块端口
另外在本例程中添加了一个 ROM IP 模块，需要对 ROM IP 初始化数据。这里仅介绍如何使
用波形数据生成工具，在软件工具及驱动文件夹下找到工具，其图标如下所示：
 
1. 双击.exe 打开工具，打开界面如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 270 / 285
2. 可以根据需要自选波形，本例程中选择正弦波，数据长度和位宽保持默认
3.点击保存按钮，将生成的数据文件保存到工程目录文件下（注意保存的文件类型）：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 271 / 285
4. 保存后出现如下对话框表示保存成功，点击确定后关闭工具
将 .coe 文件保存到生成的 Rom IP 核中即可，这里不再重复介绍
实验现象
连接 AN108 的 DAC 输入到信号发生器的输出，这里使用的是专用屏蔽线，如果使用其他
线可能会有较大干扰。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 272 / 285
AN108 连接示意图
J11 扩展口
调节信号发生的频率和幅度，AN108 输入范围-5V-5V，为了便于观察波形数据，建议信
号输入频率 200Khz 到 1Mhz。观察显示器输出，红色波形为 ADC 输入、黄色网格最上面横线代
表 5V，最下面横线代表-5V，中间横线代表 0V，每个竖线间隔是 10 个采样点。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 273 / 285
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 274 / 285
第二十四章 AD9767 双通道正弦波产生实验
实验 Vivado 工程为“ad9767_dual_sin_wave”。
本章介绍利用 AN9767 模块实现两路正弦波产生的实验。
硬件介绍
双通道 14 位 DA 输出模块 AN9767 采用 ANALOG DEVICES 公司的 AD9767 芯片，支持独立
双通道、14 位、125MSPS 的数模转换。模块留有一个 40 针的排母用于连接 FPGA 开发板，2 个 BNC 连接器用于模拟信号的输出。
AN9767 模块实物照片如下：
 AN9767 模块正面图
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 275 / 285
 AN9767 模块背面图
24.1.1 AN9767 模块的参数说明
以下为 AN9767 双通道 DA 模块的详细参数:  DA 转换芯片：AD9767；  通道数：2 通道；
 DA 转换位数：14bit；  DA 更新速率：125 MSPS；  输出电压范围：-5V~+5V；  模块 PCB 层数：4 层，独立的电源层和 GND 层；
 模块接口：40 针 2.54mm 间距排座，方向向下；
 工作温度：-40°~85° 模块使用芯片均满足工业级温度范围
 输出接口：2 路 BNC 模拟输出接口（用 BNC 线可以直接连接到示波器）；
24.1.2 AN9767 模块的原理框图
AN9767 模块的原理设计框图如下：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 276 / 285
24.1.3 AD9767 芯片简介
AD9767 是双端口、高速、双通道、14 位 CMOS DAC, 芯片集成两个高品质 TxDAC+®内核、
一个基准电压源和数字接口电路,采用 48 引脚小型 LQFP 封装。器件提供出色的交流和直流性
能，同时支持最高 125 MSPS 的更新速率。AD9767 的功能框图如下：
40 AD 40 AD针数据输出扩展口针数据输出扩展口 第一级运放 （电流转电压） 第一级运放 （电流转电压） 高速双通道DAC 芯片 AD9767 高速双通道DAC 芯片 AD9767 AM1117 AM1117 5V输入电压 3.3V电压 BBNNCC接接口口 第二级运放 （电压放大） 第二级运放 （电压放大） MC34063A MC34063A MC34063A MC34063A +6V电压 -6V电压 低低通通滤滤波波 第一级运放 （电流转电压） 第一级运放 （电流转电压） BBNNCC接接口口 第二级运放 （电压放大） 第二级运放 （电压放大） 低低通通滤滤波波
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 277 / 285
24.1.4 电流电压转换及放大
AD9767 的两路 DA 输出都为补码形式的电流输出 IoutA 和 IoutB。当 AD9767 数字输入为满
量程时（DAC 的输入的 14 位数据都为高），IoutA 输出满量程的电流输出 20mA。IoutB 输出的
电流为 0mA。具体的电流和 DAC 的数据的关系如下公式所示：
其中 IoutFS=32 x Iref，在 AN9767 模块设计中, Iref 的值由电阻 R16 的值决定，如果
R16=19.2K，那 Iref 的值就是 0.625mA。这样 IoutFS 的值就是 20mA。
AD9767 输出的电流通过第一级运放 AD6045 转换成-1V~+1V 的电压。具体的转换电路如下
图所示：
第一级运放转换后的-1V~+1V 的电压通过第二级运放变换到更高幅度的电压信号，这个运
放的幅度大小可以通过调整板上的可调电阻来改变。通过第二级运放，模拟信号的输出范围高
达-5V~+5V。
下表为数字输入信号和各级运放输出后的电压对照表：
DAC 数据输入值 AD9767 电流输出 第一级运放输出 第二级运放输出
3fff(14 位全高） +20mA -1V +5V
0(14 位全低） -20mA +1V -5V
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 278 / 285
2000（中间值） 0mA 0V 0V
24.1.5 电流电压转换及放大
AD9767 芯片的数字接口可以通过芯片的模式管脚(MODE)来配置成双端口模式(Dual)或者交
叉(Interleaved)模式。在 AN9767 模块设计中，AD9767 芯片是工作在双端口模式，双通道的 DA
数字输入接口是独立分开的。双端口模式(Dual)的数据时序图如下图所示：
给 AD9767 芯片的 DA 数据通过时钟 CLK 和写信号 WRT 的上升沿输入到芯片进行 DA 转
换。
程序设计
例程中提供了 AN9767 模块的 DA 测试程序，通过 AN9767 模块来实现正弦波信号的输
出。
正选波测试程序是通过读取 FPGA 内部的一个 ROM 中存储的正选波数据，然后把正选波
的数据输出到 AN9767 模块进行数模的转换，从而得到正选波的模拟信号。正选波测试程序的
示意图如下:
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 279 / 285
24.2.1 生成 ROM 初始化文件
程序中我们会用到一个 ROM 用于存储 1024 个 14 位的正弦波数据, 首先我们需要准备 ROM
的初始化文件(如果是 ALTERA 开发板的话是 mif 文件，如果是 Xilinx 开发板的话是 coe 文件)。以
下为生成正弦波 ROM 数据文件的方法：
在软件工具及驱动文件夹下找到工具，其图标如下所示：
 
1. 双击.exe 打开工具，打开界面如下：
 
2. 可以根据需要自选波形，本例程中选择正弦波，数据长度 1024，数据位宽 14，其它默认：
示波器 BNC线 开发板 AN9767 模块 FPGA ROM PLL DAC2 DAC1
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 280 / 285
3. 点击保存按钮，将生成的数据文件保存到工程目录文件下（注意保存的文件类型）：
 
4. 保存后出现如下对话框表示保存成功，点击确定后关闭工具
 
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 281 / 285
将 .coe 文件保存到生成的 Rom IP 核中即可，在字符显示实验教程中已做介绍，这里不再
重复。
24.2.2 双通道正弦波发生程序
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
//Two sine wave outputs -10V ~ +10V
//////////////////////////////////////////////////////////////////////////////////
module ad9767_test
(
input sys_clk, // input clock 50Mhz
output da1_clk, //AD9767 CH1 clock
output da1_wrt, //AD9767 CH1 enable
output [13:0] da1_data, //AD9767 CH1 data output
output da2_clk, //AD9767 CH2 clock
output da2_wrt, //AD9767 CH2 enable
output [13:0] da2_data //AD9767 CH2 data output
);
reg [9:0] rom_addr;
wire [13:0] rom_data;
wire clk_125M;
assign da1_clk=clk_125M;
assign da1_wrt=clk_125M;
assign da1_data=rom_data;
assign da2_clk=clk_125M;
assign da2_wrt=clk_125M;
assign da2_data=rom_data;
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 282 / 285
//DA output sin waveform
always @(negedge clk_125M)
begin
rom_addr <= rom_addr + 1'b1 ; //The output sine wave frequency is 122Khz
// rom_addr <= rom_addr + 4 ; //The output sine wave frequency is 488Khz
// rom_addr <= rom_addr + 128 ; //The output sine wave frequency is 15.6Mhz 
end
ROM ROM_inst
(.clka(clk_125M), // input clka
.addra(rom_addr), // input [8 : 0] addra
.douta(rom_data) // output [7 : 0] douta
);
PLL PLL_inst
(// Clock in ports
.clk_in1 (sys_clk ), // IN
// Clock out ports
.clk_out1 ( ), // OUT
.clk_out2 (clk_125M ), // OUT
// Status and control signals
.reset (1'b0 ), // IN
.locked ( )
); 
endmodule
程序中通过一个 PLL IP 来产生 125M 的 DA 输出时钟，然后就是循环读取存放在 ROM 中的
1024 个数据，并同时输出到通道 1 和通道 2 的 DA 数据线上。程序中可以通过地址的加 1，加
4, 或者加 128 来选择输出不同的频率的正弦波。
实验现象
将 AN9767 模块插入开发板的 J11 扩展口，用我们提供的 BNC 线连接 AN9767 的输出到示
波器的输入如下图，然后开发板上电,下载程序就可以从示波器上观察从 DA 模块输出的模拟信
号的波形了。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 283 / 285
AN9767 与 AX7020/AX7010 连接图
示波器上看到的正弦波如下：
我们可以把程序中的地址修改成+4 的方式，如下修改，这样一个正弦波的输出的点为
256 个，输出的正弦波的频率会提高 4 倍：
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 284 / 285
程序修改后，重新下载 FPGA 后，正弦波的频率变高，示波器显示的波形如下：
 用户也可以通过调节 AN9767 模块上的可调电阻来改变 2 个通道输出波形的幅度。
 
ZYNQ 开发平台基础教程
http://www.alinx.com.cn 285 / 285