MOC Meta-Object Compiler,MOC 
Qt的元对象编译器，是一个预处理器，在源程序被编译前先将这些Qt特性的程序转换为标准C++兼容的形式，然后再由标准C++编译器进行编译。这就是为什么在使用信号与槽机制的类里，必须添加 Q_OBJECT 宏的原因，只有添加了这个宏，moc才能对类里的信号与槽的代码进行预处理。

class MainWindow : public QMainWindow
{
    Q_OBJECT


元对象系统由以下三个基础组成。
QObject类是所有使用元对象系统的类的基类。
Q_OBJECT
Q_OBJECT
Q_OBJECT
在一个类的private部分声明Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。
MOC（元对象编译器）为每个QObject的子类提供必要的代码来实现元对象系统的特性。
构建项目时，MOC工具读取C++源文件，当它发现类的定义里有Q_OBJECT宏时，它就会为这个类生成另外一个包含有元对象支持代码的C++源文件，这个生成的源文件连同类的实现文件一起被编译和连接。
除了信号与槽机制外，元对象还提供如下一些功能。

QObject::metaObject()函数返回类关联的元对象，元对象类QMetaObject包含了访问元对象的一些接口函数，例如QMetaObject::className()函数可在运行时返回类的名称字符串。

QObject *obj = new QPushButton;
obj->metaObject()->className();    // 返回 "QPushButton"
QMetaObject::newInstance()函数创建类的一个新的实例。
QObject::inherits(const char *className)函数判断一个对象实例是否是名称为className的类或QObject的子类的实例。例如：QTimer *timer = new QTimer;        // QTimer 是QObject的子类
timer->inherits("QTimer");         // 返回 true
timer->inherits("QObject");        // 返回 true
timer->inherits("QAbstractButton");//返回 false，不是QAbstractButton的子类


qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
qobject_cast()函数进行动态投射
对于QObject及其子类，还可以使用qobject_cast()函数进行动态投射（dynamic cast）。例如，假设QMyWidget是QWidget的子类并且在类定义中声明了Q_OBJECT宏。创建实例使用下面的语句：QObject *obj = new QMyWidget;
变量obj定义为QObject指针，但它实际指向QMyWidget类，所以可以正确投射为QWidget，即：QWidget *widget = qobject_cast<QWidget *>(obj);
从QObject到QWidget的投射是成功的，因为obj实际是QMyWidget类，是QWidget的子



connect()
connect()
connect()
．connect()函数的不同参数形式
QObject::connect()函数有多重参数形式，一种参数形式的函数原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection)
使用这种参数形式的connect()进行信号与槽函数的连接时，一般句法如下：connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));
这里使用了宏SIGNAL()和SLOT()指定信号和槽函数，而且如果信号和槽函数带有参数，还需注明参数类型，如：connect(spinNum, SIGNAL(valueChanged (int)), this, SLOT(updateStatus(int));
另外一种参数形式的connect()函数的原型是：QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal, const QObject *receiver, const QMetaMethod &method, Qt::ConnectionType type = Qt::AutoConnection)
对于具有默认参数的信号与槽（即信号名称是唯一的，没有参数不同而同名的两个信号），可以使用这种函数指针形式进行关联，如：connect(lineEdit, &QLineEdit::textChanged, this, &widget::on_textChanged);
QLineEdit只有一个信号textChanged(QString), 在自定义窗体类widget里定义一个槽函数on_textChanged(QString)，就可以用上面的语句将此信号与槽关联起来，无需出现函数参数。这在信号的参数比较多时更简便一些。
而对于具有不同参数的同名信号就不能采用函数指针的方式进行信号与槽的关联，例如QSpinBox有两个valueChanged()信号，分别是：void QSpinBox::valueChanged(int i)
void QSpinBox::valueChanged(const QString &text)
即使在自定义窗体widget里定义了一个槽函数，如：void onValueChanged(int i);
在使用下面的语句进行关联时，编译会出错。connect(spinNum, &QSpinBox::valueChanged , this, &widget::onValueChanged);
不管是哪种参数形式的connect()函数，最后都有一个参数Qt::ConnectionType type，缺省值为Qt::AutoConnection。枚举类型Qt::ConnectionType表示了信号与槽之间的关联方式，有以下几种取值。
Qt::AutoConnection（缺省值）：如果信号的接收者与发射者在同一个线程，就使用Qt::Direct Connection方式；否则使用Qt::QueuedConnection方式，在信号发射时自动确定关联方式。
Qt::DirectConnection：信号被发射时槽函数立即执行，槽函数与信号在同一个线程。
Qt::QueuedConnection：在事件循环回到接收者线程后执行槽函数，槽函数与信号在不同的线程。
Qt::BlockingQueuedConnection：与Qt::QueuedConnection相似，只是信号线程会阻塞直到槽函数执行完毕。当信号与槽函数在同一个线程时绝对不能使用这种方式，否则会造成死锁。


propertyOffset
propertyOffset
propertyOffset
这种编写代码的方式一般用于为多个同类型组件的同一信号编写一个槽函数，在槽函数里区分信号来源分别做处理，避免为每个组件分别编写槽函数形成的代码冗余。
界面上“类的元对象信息”按钮的响应代码如下：void QmyWidget::on_btnClassInfo_clicked()
{//"类的元对象信息"按钮
   const QMetaObject *meta=boy->metaObject();
   ui->textEdit->clear();
   ui->textEdit->appendPlainText("==元对象信息==\n");
   ui->textEdit->appendPlainText(
            QString("类名称：%1\n").arg(meta->className()));
   ui->textEdit->appendPlainText("property");
   for (int i=meta->propertyOffset();i<meta->propertyCount();i++)
   {
      QMetaProperty prop=meta->property(i);
      const char* propName=prop.name();
      QString   propValue=boy->property(propName).toString();
      ui->textEdit->appendPlainText(
        QString("属性名称=%1，属性值=%2").arg(propName).arg(propValue));
   }

   ui->textEdit->appendPlainText("");
   ui->textEdit->appendPlainText("classInfo");
   for (int i=meta->classInfoOffset();i<meta->classInfoCount();++i)
   {
      QMetaClassInfo classInfo=meta->classInfo(i);
      ui->textEdit->appendPlainText(QString("Name=%1; Value=%2")
                  .arg(classInfo.name()).arg(classInfo.value()));
   }
}
代码里通过boy->metaObject()获得对象boy的元对象。元对象类QMetaObject封装了访问类的元对象的各种接口函数，例如，QMetaObject:: className()返回类的名称。
QMetaObject用于属性操作的函数有以下几种。
propertyOffset()：返回类的第一个属性的序号，第一个属性的序号不一定是0。
propertyCount()：返回类的属性个数。
QMetaProperty property(int index)：返回序号为index的属性对象，返回值是QMetaProperty类型，它封装了对属性的更多特征查询功能，以及属性值的读写功能。
QMetaClassInfo类封装了类的classInfo的访问接口函数，只有name()和value()两个接口函数。


3.2　Qt全局定义
<QtGlobal>头文件包含了Qt类库的一些全局定义，包括基本数据类型、函数和宏，一般的Qt类的头文件都会包含该文件，所以不用显式包含这个头文件也可以使用其中的定义。
3.2.1　数据类型定义
为了确保在各个平台上各数据类型都有统一确定的长度，Qt为各种常见数据类型定义了类型符号，如qint8就是signed char的类型定义，即：typedef  signed char   qint8;
<QtGlobal>中定义的数据类型见表3-1。
表3-1　Qt中的数据类型定义
Qt数据类型    等效定义        字节数
qint8         signed char       1
qint16        signed short      2
qint32		signed int		4
qint64		long long int		8
qlonglong	long long int		8
quint8		unsigned char		1
quint16		unsigned short		2
quint32		unsigned int		4
quint64		unsigned long long int		8
qulonglong  unsigned long long int		8
uchar		unsigned char		1
ushort		unsigned short		2
uint		unsigned int		4
ulong		unsigned long		8
qreal		double		8
qfloat16                2
其中qreal缺省是8字节double类型浮点数，如果Qt使用-qreal float选项进行配置，就是4字节float类型的浮点数。
qfloat16是Qt 5.9.0中新增的一个类，用于表示16位的浮点数，要使用qfloat16，需要包含头文件<QFloat16>。


3.2.2　函数
< QtGlobal >头文件包含一些常用函数的定义，这些函数多以模板类型作为参数，返回相应的模板类型，模板类型可以用任何其他类型替换。若是以double或float类型数作为参数的，一般有两个参数版本的同名函数，如qFuzzyIsNull(double d) 和qFuzzyIsNull(float f)。
表3-2是<QtGlobal>中常用的全局函数定义，列出了函数的输入和输出参数（若存在double和float两种参数版本，只列出double类型参数的版本）。
表3-2　< QtGlobal >中常用的全局函数定义
函数
功能
T qAbs(const T &value)
返回变量value的绝对值
const T &qBound(const T &min, const T &value, const T &max)
返回value限定在min至max范围之内的值
bool qFuzzyCompare(double p1, double p2)
若p1和p2近似相等，返回true
bool qFuzzyIsNull(double d)
如果参数d约等于0，返回true
double qInf()
返回无穷大的数
bool qIsFinite(double d)
若d是一个有限的数，返回true
bool qIsInf(double d)
若d是一个无限大的数，返回true
bool qIsNaN(double d)
若d不是一个数，返回true
const T &qMax(const T &value1, const T &value2)
返回value1和value2中较大的值
const T &qMin(const T &value1, const T &value2)
返回value1和value2中较小的值
qint64 qRound64(double value)
将value近似为最接近的qint64整数
int qRound(double value)
将value近似为最接近的int整数
int qrand()
标准C++中rand()函数的线程安全型版本，返回0至RAND_MAX之间的伪随机数
void qsrand(uint seed)
标准C++中srand()函数的线程安全型版本，使用种子seed对伪随机数序列初始化
还有一些基础的数学运算函数在<QtMath>头文件中定义，比如三角运算函数、弧度与角度之间的转换函数等。
3.2.3　宏定义
<QtGlobal>头文件中定义了很多宏，以下一些是比较常用的。
QT_VERSION
这个宏展开为数值形式0xMMNNPP (MM = major, NN = minor, PP = patch)表示Qt编译器版本，例如Qt编译器版本为Qt 5.9.1，则QT_VERSION为0x050901。这个宏常用于条件编译设



置，根据Qt版本不同，编译不同的代码段。#if QT_VERSION >= 0x040100
   QIcon icon = style()->standardIcon(QStyle::SP_TrashIcon);
#else
   QPixmap pixmap = style()->standardPixmap(QStyle::SP_TrashIcon);
   QIcon icon(pixmap);
#endif
QT_VERSION_CHECK
这个宏展开为Qt版本号的一个整数表示，例如：#if (QT_VERSION >= QT_VERSION_CHECK(5, 0, 0))
#include <QtWidgets>
#else
#include <QtGui>
#endif
QT_VERSION_STR
这个宏展开为Qt版本号的字符串，如“5.9.0”。
Q_BYTE_ORDER、Q_BIG_ENDIAN和Q_LITTLE_ENDIAN
Q_BYTE_ORDER表示系统内存中数据的字节序，Q_BIG_ENDIAN表示大端字节序，Q_LITTLE_ENDIAN表示小端字节序。在需要判断系统字节序时会用到，例如：#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
...
#endif
Q_DECL_IMPORT和Q_DECL_EXPORT
在使用或设计共享库时，用于导入或导出库的内容，12.4节有其使用实例。
Q_DECL_OVERRIDE
在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数paintEvent()，可以定义如下：void  paintEvent(QPaintEvent*) Q_DECL_OVERRIDE;
使用Q_DECL_OVERRIDE宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错。
Q_DECL_FINAL
这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承，示例如下：class QRect Q_DECL_FINAL { // QRect不能再被继承
     // ...
  };
Q_UNUSED(name)
这个宏用于在函数中定义不在函数体里使用的参数，示例如下：void MainWindow::on_imageSaved(int id, const QString &fileName)
{
   Q_UNUSED(id);
   LabInfo->setText("图片保存为： "+fileName);
}






在这个函数里，id参数没有使用。如果不用Q_UNUSED(id)定义，编译器会出现参数未使用的警告。
foreach(variable, container)
foreach用于容器类的遍历，例如：foreach (const QString &codecName, recorder->supportedAudioCodecs())
   ui->comboCodec->addItem(codecName);
forever
forever用于构造一个无限循环，例如：forever {
     ...
  }
qDebug(const char *message, ...)
在debugger窗体显示信息，如果编译器设置了Qt_NO_DEBUG_OUTPUT，则不作任何输出，例如：qDebug("Items in list: %d", myList.size());
类似的宏还有qWarning、qCritical、qFatal、qInfo等，也是用于在debugger窗体显示信息。






3.3　容器类
3.3.1　容器类概述
Qt提供了多个基于模板的容器类，这些容器类可以用于存储指定类型的数据项，例如常用的字符串列表类QStringList就是从容器类 QList<QString>继承的，实现对字符串列表的添加、存储、删除等操作。
Qt的容器类比标准模板库（STL）中的容器类更轻巧、安全和易于使用。这些容器类是隐式共享和可重入的，而且它们进行了速度和存储优化，因此可以减少可执行文件的大小。此外，它们还是线程安全的，也就是说它们作为只读容器时可被多个线程访问。
容器类是基于模板的类，如常用的容器类QList<T>，T是一个具体的类型，可以是int、float等简单类型，也可以是Qstring、QDate等类，但不能是QObject或任何其子类。T必须是一个可赋值的类型，即T必须提供一个缺省的构造函数，一个可复制构造函数和一个赋值运算符。
例如用QList<T>定义一个字符串列表的容器，其定义方法是：QList<QString>  aList;
这样定义了一个QList容器类的变量aList，它的数据项是QString，所以aList可以用于处理字符串列表，例如：aList.append("Monday");
aList.append("Tuesday");
aList.append("Wednesday");
QString  str=aList[0];
Qt的容器类分为顺序容器（sequential containers）和关联容器（associative containers）。





容器迭代类用于遍历容器里的数据项，有Java类型的迭代类和STL类型的迭代类。Java类型的迭代类易于使用，提供高级功能，而STL类型的迭代类效率更高一些。
Qt还提供了foreach宏用于遍历容器内的所有数据项。
3.3.2　顺序容器类
Qt的顺序容器类有QList、QLinkedList、QVector、QStack和QQueue。
1．QList
QList是最常用的容器类，虽然它是以数组列表（array-list）的形式实现的，但是在其前或后添加数据非常快，QList以下标索引的方式对数据项进行访问。
QList用于添加、插入、替换、移动、删除数据项的函数有：insert()、replace()、removeAt()、move()、swap()、append()、prepend()、removeFirst()和removeLast()等。
QList提供下标索引方式访问数据项，如同数组一样，也提供at()函数，例如：QList<QString> list;
list << "one" << "two" << "three";
QString str1=list[1];   //str1=="two"
QString str0=list.at(0);   //str0=="one"
QList的isEmpty()函数在数据项为空时返回true，size()函数返回数据项的个数。
QList是Qt中最常用的容器类，很多函数的参数传递都是采用QList容器类，例如QAudioDeviceInfo的静态函数availableDevices()的函数原型是：QList<QAudioDeviceInfo> QAudioDeviceInfo::availableDevices(QAudio::Mode mode)
其返回数据就是QAudioDeviceInfo类型的QList列表。
2．QLinkedList
QLinkedList<T>是链式列表（linked-list），数据项不是用连续的内存存储的，它基于迭代器访问数据项，并且插入和删除数据项的操作时间相同。
除了不提供基于下标索引的数据项访问外，QLinkedList的其他接口函数与QList基本相同。
3．QVector
QVector<T>提供动态数组的功能，以下标索引访问数据。
QVector的函数接口与QList几乎完全相同，QVector<T>的性能比QList<T>更高，因为QVector<T>的数据项是连续存储的。
4．QStack
QStack<T>是提供类似于堆栈的后入先出（LIFO）操作的容器类，push()和pop()是主要的接口函数。例如：QStack<int> stack;
stack.push(10);
stack.push(20);
stack.push(30);
while (!stack.isEmpty())
   cout << stack.pop() << endl;
程序会依次输出30，20，10。
5．QQueue
QQueue<T>是提供类似于队列先入先出（FIFO）操作的容器类。enqueue()和dequeue()





是主要操作函数。例如：QQueue<int> queue;
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
while (!queue.isEmpty())
   cout << queue.dequeue() << endl;
程序会依次输出10，20，30。
3.3.3　关联容器类
Qt还提供关联容器类QMap、QMultiMap、QHash、QMultiHash和QSet。
QMultiMap和QMultiHash支持一个键关联多个值，QHash和QMultiHash类使用散列（Hash）函数进行查找，查找速度更快。
1．QSet
QSet是基于散列表的集合模板类，它存储数据的顺序是不定的，查找值的速度非常快。QSet<T> 内部就是用QHash实现的。
定义QSet<T>容器和输入数据的实例代码如下：QSet<QString> set;
set << "dog" << "cat" << "tiger";
测试一个值是否包含于这个集合，用contains()函数，示例如下：if (!set.contains("cat"))
     ...
2．QMap
QMap<Key, T>提供一个字典（关联数组），一个键映射到一个值。QMap存储数据是按照键的顺序，如果不在乎存储顺序，使用QHash会更快。
定义QMap<QString, int>类型变量和赋值的示例代码如下：QMap<QString, int> map;
map["one"] = 1;
map["two"] = 2;
map["three "] = 3;
也可以使用insert()函数赋值，或remove()移除一个键值对，示例如下：map.insert("four", 4);
map.remove("two");
要查找一个值，使用运算符“[ ]”或value()函数，示例如下：int num1 = map["one"];
int num2 = map.value("two");
如果在映射表中没有找到指定的键，会返回一个缺省构造值（default-constructed values），例如，如果值的类型是字符串，会返回一个空的字符串。
在使用value()函数查找键值时，还可以指定一个缺省的返回值，示例如下：timeout = map.value("TIMEOUT",30);





这表示如果在map里找到键“TIMEOUT”，就返回关联的值，否则返回值为30。
3．QMultiMap
QMultiMap是QMap的子类，是用于处理多值映射的便利类。
多值映射就是一个键可以对应多个值。QMap正常情况下不允许多值映射，除非使用QMap::insertMulti()添加键值对。
QMultiMap是QMap的子类，所以QMap的大多数函数在QMultiMap都是可用的，但是有几个特殊的，QMultiMap::insert()等效于QMap::insertMulti()，QMultiMap::replace()等效于QMap::insert()。
QMultiMap使用示例如下：QMultiMap<QString, int> map1, map2, map3;
map1.insert("plenty", 100);
map1.insert("plenty", 2000);   // map1.size() == 2
map2.insert("plenty", 5000);   // map2.size() == 1
map3 = map1 + map2;            // map3.size() == 3
QMultiMap不提供“[ ]”操作符，使用value()函数访问最新插入的键的单个值。如果要获取一个键对应的所有值，使用values()函数，返回值是QList<T>类型。QList<int> values = map.values("plenty");
for (int i = 0; i < values.size(); ++i)
   cout << values.at(i) << endl;
4．QHash
QHash是基于散列表来实现字典功能的模板类，QHash<Key, T>存储的键值对具有非常快的查找速度。
QHash与QMap的功能和用法相似，区别在于以下几点：
QHash比QMap的查找速度快；
在QMap上遍历时，数据项是按照键排序的，而QHash的数据项是任意顺序的；
QMap的键必须提供“<”运算符，QHash的键必须提供“==”运算符和一个名称为qHash()的全局散列函数。
5．QMultiHash
QMultiHash是QHash的子类，是用于处理多值映射的便利类，其用法与QMultiMap类似。
3.4　容器类的迭代
迭代器（iterator）为访问容器类里的数据项提供了统一的方法，Qt有两种迭代器类：Java类型的迭代器和STL类型的迭代器。
Java类型的迭代器更易于使用，且提供一些高级功能，而STL类型的迭代器效率更高。
Qt还提供一个关键字foreach（实际是< QtGlobal >里定义的一个宏）用于方便地访问容器里所有数据项。
3.4.1　Java类型迭代器
1．Java类型迭代器总表
对于每个容器类，有两个Java类型迭代器：一个用于只读操作，一个用于读写操作，各个Java类型的容器类见表3-3。





表3-3　Java类型的迭代器类
容器类                                  只读迭代器                 读写迭代器
QList<T>,   QQueue<T>                   QListIterator<T>            QMutableListIterator<T>		
QLinkedList<T>  		                QLinkedListIterator<T>		QMutableLinkedListIterator<T>
QVector<T>, QStack<T>		            QVectorIterator<T>		    QMutableVectorIterator<T>
QSet<T>		                            QSetIterator<T>		        QMutableSetIterator<T>
QMap<Key, T>, QMultiMap<Key, T>		    QMapIterator<Key, T>		QMutableMapIterator<Key, T>
QHash<Key, T>, QMultiHash<Key, T>		QHashIterator<Key, T>		QMutableHashIterator<Key, T>
QMap和QHash等关联容器类的迭代器用法相同，QList和QLinkedList、QSet等容器类的用法相同，所以下面只以QMap和QList为例介绍迭代器的用法。
2．顺序容器类的迭代器的使用
Java类型迭代器的指针不是指向一个数据项，而是在数据项之间，迭代器指针位置示意图如图3-2所示。
图3-2　Java类型迭代器位置示意图
下面是遍历访问一个QList<QString>容器的所有数据项的典型代码。QList<QString> list;
list << "A" << "B" << "C" << "D";
QListIterator<QString> i(list);
while (i.hasNext())
   qDebug() << i.next();
QList< QString>容器对象list作为参数传递给QListIterator< QString >迭代器i的构造函数，i用于对list作只读遍历。起始时刻，迭代器指针在容器第一个数据项的前面（图3-2中数据项“A”的前面），调用hasNext()判断在迭代器指针后面是否还有数据项，如果有，就调用next()跳过一个数据项，并且next()函数返回跳过去的那个数据项。
也可以反向遍历，示例代码如下：QListIterator<QString> i(list);
i.toBack();
while (i.hasPrevious())
   qDebug() << i.previous();
QListIterator用于移动指针和读取数据的函数见表3-4。
表3-4　QListIterator常用函数




函数名
功能
void　toFront()		迭代器移动到列表的最前面（第一个数据项之前）
void　toBack()		迭代器移动到列表的最后面（最后一个数据项之后）
bool　hasNext()		如果迭代器不是位于列表最后位置，返回true
const T & next()		返回下一个数据项，并且迭代器后移一个位置
const T & peekNext()		返回下一个数据项，但是不移动迭代器位置
bool　hasPrevious()		如果迭代器不是位于列表的最前面，返回true
const T & previous()		返回前一个数据项，并且迭代器前移一个位置
const T & peekPrevious()		返回前一个数据项，但是不移动迭代器指针
QListIterator是只读访问容器内数据项的迭代器，若要在遍历过程中对容器的数据进行修改，需要使用QMutableListIterator。例如下面的示例代码为删除容器中数据为奇数的项。QList<int> list;
list <<1 <<2<<3<<4<<5;
QMutableListIterator<int> i(list);
while (i.hasNext()) {
   if (i.next() % 2 != 0)
      i.remove();
}
remove()函数移除next()函数刚刚跳过的一个数据项，不会使迭代器失效。
setValue()函数可以修改刚刚跳过去的数据项的值。
3．关联容器类的迭代器的使用
对于关联容器类QMap<Key T>，使用QMapIterator和QMutableMapIterator迭代器类，它们具有表3-4所示的所有函数，主要是增加了key()和value()函数用于获取刚刚跳过的数据项的键和值。
例如，下面的代码将删除键（城市名称）里以“City”结尾的数据项。QMap<QString, QString> map;
map.insert("Paris", "France");
map.insert("New York", "USA");
map.insert("Mexico City", "USA");
map.insert("Moscow", "Russia");
...
QMutableMapIterator<QString, QString> i(map);
while (i.hasNext()) {
   if (i.next().key().endsWith("City"))
      i.remove();
}
如果是在多值容器里遍历，可以用findNext()或findPrevious()查找下一个或上一个值，如下面的代码将删除上一示例代码中map里值为“USA”的所有数据项。QMutableMapIterator<QString, QString> i(map);
while (i.findNext("USA"))
   i.remove();







3.4.2　STL类型迭代器
1．STL类型迭代器总表
STL迭代器与Qt和STL的原生算法兼容，并且进行了速度优化。具体类型见表3-5。
对于每一个容器类，都有两个STL类型迭代器：一个用于只读访问，一个用于读写访问。无需修改数据时一定使用只读迭代器，因为它们速度更快。
表3-5　STL类型的迭代器类
容器类		只读迭代器		读写迭代器
QList<T>, QQueue<T>		QList<T>::const_iterator		QList<T>::iterator
QLinkedList<T>		QLinkedList<T>::const_iterator		QLinkedList<T>::iterator
QVector<T>, QStack<T>		QVector<T>::const_iterator		QVector<T>::iterator
QSet<T>		QSet<T>::const_iterator		QSet<T>::iterator
QMap<Key, T>QMultiMap<Key, T>		QMap<Key, T>::const_iterator		QMap<Key, T>::iterator
QHash<Key, T>QMultiHash<Key, T>		QHash<Key, T>::const_iterator		QHash<Key, T>::iterator
注意　
在定义只读迭代器和读写迭代器时的区别，它们使用了不同的关键字，const_iterator定义只读迭代器，iterator定义读写迭代器。此外，还可以使用const_reverse_iterator和reverse_iterator定义相应的反向迭代器。
STL类型的迭代器是数组的指针，所以“++”运算符使迭代器指向下一个数据项，“*”运算符返回数据项内容。与Java类型的迭代器不同，STL迭代器直接指向数据项，STL迭代器指向位置示意图如图3-3所示。
图3-3　STL类型迭代器位置示意图
begin()函数使迭代器指向容器的第一个数据项，end()函数使迭代器指向一个虚拟的表示结尾的数据项，end()表示的数据项是无效的，一般用作循环结束条件。
下面仍然以QList和QMap为例说明STL迭代器的用法，其他容器类迭代器的用法类似。
2．顺序容器类的迭代器的用法
下面的示例代码将QList<QString> list里的数据项逐项输出。QList<QString> list;
list << "A" << "B" << "C" << "D";
QList<QString>::const_iterator i;
for (i = list.constBegin(); i != list.constEnd(); ++i)
   qDebug() << *i;






constBegin()和constEnd()是用于只读迭代器的，表示起始和结束位置。
若使用反向读写迭代器，并将上面示例代码中list的数据项都改为小写，代码如下：QList<QString>::reverse_iterator i;
for (i = list.rbegin(); i != list.rend(); ++i)
   *i = i->toLower();
}
3．关联容器类的迭代器的用法
对于关联容器类QMap和QHash，迭代器的“*”操作符返回数据项的值。如果想返回键，使用key()函数。对应的，用value()函数返回一个项的值。
例如，下面的代码将QMap<int, int> map中所有项的键和值输出。QMap<int, int> map;
...
QMap<int, int>::const_iterator i;
for (i = map.constBegin(); i != map.constEnd(); ++i)
   qDebug() << i.key() << ':' << i.value();
Qt API包含很多返回值为QList或QStringList的函数，要遍历这些返回的容器，必须先复制。由于Qt使用了隐式共享，这样的复制并无多大开销。例如下面的代码是正确的。const QList<int> sizes = splitter->sizes();
QList<int>::const_iterator i;
for (i = sizes.begin(); i != sizes.end(); ++i)
   ...提示　
隐式共享（Implicit Sharing）是对象的管理方法。一个对象被隐式共享，只是传递该对象的一个指针给使用者，而不实际复制对象数据，只有在使用者修改数据时，才实质复制共享对象给使用者。如在上面的代码中，splitter->sizes()返回的是一个QList<int>列表对象sizes，但是实际上代码并不将splitter->sizes()表示的列表内容完全复制给变量sizes，只是传递给它一个指针。只有当sizes发生数据修改时，才会将共享对象的数据复制给sizes，这样避免了不必要的复制，减少了资源占用。
而下面的代码是错误的。QList<int>::const_iterator i;
for (i = splitter->sizes().begin(); i != splitter->sizes().end(); ++i)
   ...
对于STL类型的迭代器，隐式共享还涉及另外一个问题，即当有一个迭代器在操作一个容器变量时，不要去复制这个容器变量。
3.4.3　foreach关键字
如果只是想遍历容器中所有的项，可以使用foreach关键字。foreach是<QtGlobal>头文件中定义的一个宏。使用foreach的句法是：foreach (variable, container) 
使用foreach的代码比使用迭代器更简洁。例如，使用foreach遍历一个QLinkedList<QString>的示例代码如下：







QLinkedList<QString> list;
...
QString str;
foreach (str, list)
   qDebug() << str;
用于迭代的变量也可以在foreach语句里定义，foreach语句也可以使用花括号，可以使用break退出迭代，示例代码如下：QLinkedList<QString> list;
...
foreach (const QString &str, list) {
   if (str.isEmpty())
      break;
   qDebug() << str;
}
对于QMap和QHash，foreach会自动访问“键——值”对里的值，所以无需调用values()。如果需要访问键则可以调用keys()，示例代码如下：QMap<QString, int> map;
...
foreach (const QString &str, map.keys())
   qDebug() << str << ':' << map.value(str);
对于多值映射，可以使用两重foreach语句，示例代码如下：QMultiMap<QString, int> map;
...
foreach (const QString &str, map.uniqueKeys()) {
   foreach (int i, map.values(str))
      qDebug() << str << ':' << i;
}注意　
foreach关键字遍历一个容器变量是创建了容器的一个副本，所以不能修改原来容器变量的数据项。
3.5　Qt类库的模块
Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类。
Qt基本模块（Qt Essentials）：提供了Qt在所有平台上的基本功能。
Qt附加模块（Qt Add-Ons）：实现一些特定功能的提供附加价值的模块。
增值模块（Value-Add Modules）：单独发布的提供额外价值的模块或工具。
技术预览模块（Technology Preview Modules）：一些处于开发阶段，但是可以作为技术预览使用的模块。
Qt工具（Qt Tools）：帮助应用程序开发的一些工具。
Qt官网的“All Modules”页面可以查看所有这些模块的信息。
3.5.1　Qt基本模块
Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt 5所有版本上是源代码和二进制兼容的。这些具体的基本模块见表3-6。
表3-6　Qt基本模块












3.5　Qt类库的模块
Qt类库里大量的类根据功能分为各种模块，这些模块又分为几大类。
Qt基本模块（Qt Essentials）：提供了Qt在所有平台上的基本功能。
Qt附加模块（Qt Add-Ons）：实现一些特定功能的提供附加价值的模块。
增值模块（Value-Add Modules）：单独发布的提供额外价值的模块或工具。
技术预览模块（Technology Preview Modules）：一些处于开发阶段，但是可以作为技术预览使用的模块。
Qt工具（Qt Tools）：帮助应用程序开发的一些工具。
Qt官网的“All Modules”页面可以查看所有这些模块的信息。
3.5.1　Qt基本模块
Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt 5所有版本上是源代码和二进制兼容的。这些具体的基本模块见表3-6。
表3-6　Qt基本模块




模块
描述
Qt Core
其他模块都用到的核心非图形类
Qt GUI
设计GUI界面的基础类，包括OpenGL
Qt Multimedia
音频、视频、摄像头和广播功能的类
Qt Multimedia Widgets
实现多媒体功能的界面组件类
Qt Network
使网络编程更简单和轻便的类
Qt QML
用于QML和JavaScript语言的类
Qt Quick
用于构建具有定制用户界面的动态应用程序的声明框架
Qt Quick Controls
创建桌面样式用户界面，基于Qt Quick的用户界面控件
Qt Quick Dialogs
用于Qt Quick的系统对话框类型
Qt Quick Layouts
用于Qt Quick 2界面元素的布局项
Qt SQL
使用SQL用于数据库操作的类
Qt Test
用于应用程序和库进行单元测试的类
Qt Widgets
用于构建GUI界面的C++图形组件类
Qt Core模块是Qt类库的核心，所有其他模块都依赖于此模块，如果使用qmake构建项目，则Qt Core模块是自动被加入项目的。
Qt GUI模块提供了用于开发GUI应用程序的必要的类，使用qmake构建应用程序时，Qt GUI模块是自动被加入项目的。如果项目中不使用GUI功能，则需要在项目配置文件中加入如下的一行：QT -= gui
其他的模块一般不会被自动加入到项目，如果需要在项目中使用某个模块，则可以在项目配置中添加此模块。例如，如果需要在项目中使用Qt Multimedia和Qt Multimedia Widgets模块，需要在项目配置文件中加入如下的语句：QT += multimedia multimediawidgets
需要在项目中使用Qt SQL模块，就在项目配置文件中加入如下的语句：QT += sql
3.5.2　Qt附加模块
Qt附加模块可以实现一些特定目的。这些模块可能只在某些开发平台上有，或只能用于某些操作系统，或只是为了向后兼容。用户安装时可以选择性地安装这些附加模块。
表3-7是附加模块列表（未列出一些过时的模块，以及专门用于QML或Qt Quick的模块）。
表3-7　Qt附加模块





模块
描述
Active Qt
用于开发使用ActiveX和COM的Windows应用程序
Qt 3D
支持2D和3D渲染，提供用于开发近实时仿真系统的功能
Qt Android Extras
提供Android平台相关的API
Qt Bluetooth
提供访问蓝牙硬件的功能
Qt Concurrent
提供一些类，无需使用底层的线程控制就可以编写多线程程序
Qt D-Bus
使进程间通过D-Bus协议通信的一些类
Qt Gamepad
使Qt应用程序支持游戏手柄硬件的使用
Qt Image Formats
支持附加图片格式的插件，包括TIFF、MNG、TGA、WBMP
Qt Mac Extras
提供macOS平台相关的API
Qt NFC
提供访问NFC（近场通信）硬件的功能
Qt Positioning
提供一些类，用于通过GPS卫星、WiFi等定位
Qt Print Support
提供一些用于打印控制的类
Qt Purchasing
提供一些类，在Qt应用程序内实现应用内购买的功能
Qt Sensors
提供访问传感器硬件的功能，以识别运动和手势
Qt Serial Bus
访问串行工业总线的功能，目前只支持CAN和Modbus协议
Qt SVG
提供显示SVG图片文件的类
Qt WebChannel
用于实现服务器端（QML或C++应用程序）与客户端（HTML/ JavaScript或QML应用程序）之间的P2P通信
Qt WebEngine
提供类和函数，实现在应用程序中嵌入网页内容
Qt WebSockets
提供兼容于RFC 6455的WebSocket通信，WebSocket是实现客户端程序与远端主机进行双向通信的基于Web的协议
Qt Windows Extras
提供Windows平台相关的API
Qt XML
该模块不再维护了，应使用Qt Core中的QXmlStreamReader 和 QXmlStreamWriter
Qt XML Patterns
提供对XPath、XQuery、XSLT 和 XML 等的支持
Qt Charts①
用于数据显示的二维图表组件
Qt Data Visualization①
用于3D数据可视化显示的界面组件
Qt Virtual Keyboard①
实现不同输入法的虚拟键盘框架
下面的附加模块只在商业许可，或GPLv3许可的版本里才有。
3.5.3　增值模块





除了随Qt5发布的上述这些模块，还有一些模块（见表3-8）是单独发布的，这些模块只在商业版许可的Qt里才有。
表3-8　Qt的增值模块
特性
描述
Qt for Device Creation
高效、易用、全集成的嵌入式设备应用程序开发工具，包括很多其他增值特性
Qt Quick Compiler
编译.qml源文件生成二进制应用程序的编译器，提高载入时间和代码的安全性
3.5.4　技术预览模块
技术预览模块就是一些还处于开发和测试阶段的模块，一般技术预览模块经过几个版本的发布后会变成正式的模块。表3-9是Qt 5.9中的技术预览模块。
表3-9　技术预览模块
模块
描述
Qt Network Authorization
基于OAuth协议，为应用程序提供网络账号验证的功能
Qt Speech
提供文字转语音（text-to-speech）功能支持
Qt Remote Objects
进程间或设备间通信，共享QObject的API
3.5.5　Qt工具
Qt工具（见表3-10）在所有支持的平台上都可以使用，用于帮助应用程序的开发和设计。
表3-10　Qt工具
工具
描述
Qt Designer
用于扩展Qt Designer的类
Qt Help
在应用程序中集成在线文档的类，实现类似于Qt Assistant的功能
Qt UI Tools
操作Qt Designer生成的窗体的类









第4章　常用界面设计组件
第2章已经介绍了设计GUI应用程序的基本原理和方法，在掌握了用Qt Creator设计应用程序的基本方法之后，要应用Qt编写各种应用程序，重要的就是熟练掌握Qt类库里各种用于界面设计或其他功能的类的使用。
Qt类库为应用程序设计提供了大量的类，本章主要介绍设计GUI应用程序常用的各种界面组件的使用，这些是设计GUI应用程序的基础。
4.1　字符串与输入输出
4.1.1字符串与数值之间的转换
界面设计时使用最多的组件恐怕就是QLabel和QLineEdit了，QLabel用于显示字符串，QLineEdit用于显示和输入字符串。这两个类都有如下的两个函数用于读取和设置显示文字。QString  text() const
void  setText(const QString &)
这两个函数都涉及到QString类。QString类是Qt程序里经常使用的类，用于处理字符串。QString类可以进行字符串与数字之间的转换，使用QLineEdit就可以实现数字量的输入与输出。
图4-1是实例samp4_1设计时的窗体，是基于QWidget创建的可视化窗体。界面设计使用了布局管理，窗体上组件的布局是：上方的几个组件是一个GridLayout，下方的9个组件也是一个GridLayout，两个GridLayout和中间一个VerticalSpacer又组成一个VerticalLayout。
在布局设计时，要巧妙运用VerticalSpacer和HorizontalSpacer，还要会设置组件的MaximumSize和MinimumSize属性，以取得期望的布局效果。例如，在图4-1中，两个GridLayout之间放了一个垂直方向的分隔，当窗体变大时，两个GridLayout的高度并不会发生变化；而如果不放置这个垂直分隔，两个GridLayout的高度都会发生变化，GridLayout内部组件的垂直距离会发生变化。
图4-1　编辑状态的界面
1．普通数值与字符串之间的转换
在UI设计器里，选中图4-1中的“计算”按钮，在右键快捷菜单里单击“Go to slot…”，并在出现的对话框里选择clicked()信号创建槽函数，在自动生成的函数体里编写如下的代码，实现从界面上分别读取数量和单价，相乘计算后将结果再显示到文本框里。void Widget::on_btnCal_clicked()
{  
   QString str=ui->editNum->text();//读取"数量"
   int num=str.toInt();  
   str=ui->editPrice->text();//读取"单价"
   float   price=str.toFloat();
   float   total=num*price;





str=str.sprintf("%.2f",total);  
   ui->editTotal->setText(str); 
}
QString类从字符串转换为整数的函数有：int     toInt(bool *ok = Q_NULLPTR, int base = 10)      const
long    toLong (bool *ok = Q_NULLPTR, int base = 10)    const
short   toShort (bool *ok = Q_NULLPTR, int base = 10)   const
uint    toUInt (bool *ok = Q_NULLPTR, int base = 10)    const
ulong   toULong (bool *ok = Q_NULLPTR, int base = 10)   const
这些函数如果不设置参数，缺省表示从十进制表示的字符串转换为整数；若指定整数基参数，还可以直接将二进制、十六进制字符串转换为整数。
QString将字符串转换为浮点数的函数有：double   toDouble(bool *ok = Q_NULLPTR)    const
float    toFloat (bool *ok = Q_NULLPTR)    const
在得到单价和数量后做相乘运算，得到计算结果变量total，再将此数值显示在编辑框editTotal中。由于计算结果是浮点数，希望显示两位小数，下面4行语句都可以实现这个功能。str=QString::number(total,'f',2); 
str=QString::asprintf("%.2f",total); 
str=str.setNum(total,'f',2); 
str=str.sprintf("%.2f",total);
可以使用QString的静态函数number()和asprintf()，也可以使用其公共函数setNum()和sprintf()。QString的sprintf()函数与C语言里的sprintf()函数的格式是一样的，而setNum()和number()函数使用另外一种格式定义，而且setNum和number有多个重载函数定义，可以处理各种类型的整数和浮点数，在处理整数时还可以指定进制，例如将一个整数直接转换为十六进制或二进制字符串。
2．进制转换
以下是读取十进制数转换为二进制和十六进制字符串的按钮的槽函数代码：void Widget::on_btnDec_clicked()
{ //读取十进制数，转换为其他进制
   QString  str=ui->editDec->text();
   int  val=str.toInt();//缺省为十进制
//   str=QString::number(val,16);// 转换为十六进制的字符串
   str=str.setNum(val,16);//十六进制
   str=str.toUpper(); 
   ui->editHex->setText(str);

   str=str.setNum(val,2);  //二进制
//   str=QString::number(val,2);
   ui->editBin->setText(str);
}
将一个整数转换为不同进制的字符串，可以使用QString的函数setNum()或静态函数number()，它们的函数原型是：Qstring   &setNum (int n, int base = 10)
QString   number (int n, int base = 10)
其中n是待转换的整数，base是使用的进制，缺省为十进制，也可以指定为十六进制和二进制。
下面是读取二进制字符串，然后转换为十进制和十六进制显示的按钮的槽函数代码。






void Widget::on_btnBin_clicked()
{ //读取二进制数，转换为其他进制的数
   QString  str=ui->editBin->text(); //读取二进制字符串
   bool ok;
   int val=str.toInt(&ok,2);//以二进制数读入
   str=QString::number(val,10);//数字显示为十进制字符串
   ui->editDec->setText(str);

   str=str.setNum(val,16);//显示为十六进制
   str=str.toUpper(); 
   ui->editHex->setText(str); 
}
4.1.2　QString的常用功能
QString是Qt编程中常用的类，除了用作数字量的输入输出之外，QString还有很多其他功能，熟悉这些常见的功能，有助于灵活地实现字符串处理功能。
QString存储字符串采用的是Unicode码，每一个字符是一个16位的QChar，而不是8位的char，所以QString处理中文字符没有问题，而且一个汉字算作是一个字符。
图4-2是对QString常用函数的测试实例samp4_2的运行界面。下面在说明函数功能时，对于同名不同参数的函数，只说明某种参数下的使用实例。QString还有很多功能函数没有在此介绍，在使用中如果遇到，可查询Qt的帮助文件。
图4-2　QString函数功能测试实例samp4_2
append()和prepend()
append()在字符串的后面添加字符串，prepend()在字符串的前面添加字符串，如：QString str1="卖", str2="拐";
QString str3=str1;
str1.append(str2);    //str1="卖拐"
str3.prepend(str2);   //str3="拐卖"
toUpper()和toLower()
toUpper()将字符串内的字母全部转换为大写形式，toLower()将字母全部转换为小写形式，如：QString str1="Hello, World", str2;
str2=str1.toUpper();   //str2="HELLO,WORLD"
str2=str1.toLower();   //str2="hello, world"







count()、size()和length()
count()、size()和length()都返回字符串的字符个数，这3个函数是相同的，但是要注意，字符串中如果有汉字，一个汉字算一个字符。QString str1="NI好"
N=str1.count()       //N=3
N=str1.size()        //N=3
N=str1.length()      //N=3
trimmed()和simplified()
trimmed()去掉字符串首尾的空格，simplified()不仅去掉首尾的空格，中间连续的空格也用一个空格替换。QString    str1="   Are    you   OK?   ", str2;
str2=str1.trimmed();       //str1="Are    you   OK? "
str2=str1.simplified();    //str1="Are you OK? "
indexOf ()和lastIndexOf ()
indexOf()函数的原型为：int indexOf (const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
其功能是在自身字符串内查找参数字符串str出现的位置，参数from是开始查找的位置，Qt::CaseSensitivity cs参数指定是否区分大小写。
lastIndexOf()函数则是查找某个字符串最后出现的位置。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1.indexOf("5.9");          // N=13
N=str1.lastIndexOf("\\");       //N=21
“\”是转义字符，如果要查找“\”，需要输入“\”。
isNull()和isEmpty()
两个函数都判读字符串是否为空，但是稍有差别。如果一个空字符串，只有“\0”，isNull()返回false，而isEmpty()返回true；只有未赋值的字符串，isNull()才返回true。QString str1, str2="";
N=str1.isNull();   // N=true    未赋值字符串变量
N=str2.isNull();   // N=false   只有"\0"的字符串，也不是Null
N=str1.isEmpty();  // N=true    
N=str2.isEmpty();  // N=true
QString只要赋值，就在字符串的末尾自动加上“\0”，所以，如果只是要判断字符串内容是否为空，常用isEmpty()。
contains()
判断字符串内是否包含某个字符串，可指定是否区分大小写。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1. contains (".cpp", Qt::CaseInsensitive);    // N=true，不区分大小写
N=str1. contains (".CPP", Qt::CaseSensitive);      // N=false，区分大小写
endsWith()和startsWith()
startsWith ()判断是否以某个字符串开头，endsWith()判断是否以某个字符串结束。QString str1="G:\Qt5Book\QT5.9Study\qw.cpp";
N=str1. endsWith(".cpp", Qt::CaseInsensitive);     // N=true，不区分大小写







N=str1. endsWith(".CPP", Qt::CaseSensitive);       // N=false，区分大小写
N=str1. startsWith("g: ");                         // N=true，缺省为不区分大小写
left()和right()
left表示从字符串中取左边多少个字符，right表示从字符串中取右边多少个字符。注意，一个汉字被当作一个字符。QString str2, str1="学生姓名，男，1984-3-4，汉族，山东";
N=str1.indexOf ("，");                             // N=4，第一个"，"出现的位置
str2=str1.left(N);                                 //str2="学生姓名"
N=str1.lastIndexOf ("，");                         // N=18，最后一个逗号的位置
str2=str1.right(str1.size()-N-1); //str2="山东"，提取最后一个逗号之后的字符串
section()
section()函数的原型为：QString section (const QString &sep, int start, int end = -1, SectionFlags flags = SectionDefault) const
其功能是从字符串中提取以sep作为分隔符，从start端到end端的字符串。QString str2, str1="学生姓名，男，1984-3-4，汉族，山东";
str2=str1. section ("，",0,0);                    // str2="学生姓名"，   第1段的编号为0
str2=str1. section ("，",1,1);                    // str2="男"
str2=str1. section ("，",0,1);                    // str2="学生姓名，男"
str2=str1. section ("，",4,4);                    // str2="山东"
4.2　SpinBox的使用
QSpinBox用于整数的显示和输入，一般显示十进制数，也可以显示二进制、十六进制的数，而且可以在显示框中增加前缀或后缀。
QDoubleSpinBox用于浮点数的显示和输入，可以设置显示小数位数，也可以设置显示的前缀和后缀。
实例samp4_3演示QSpinBox和QDoubleSpinBox这两个组件的使用，图4-3是程序运行界面。程序功能与实例samp4_1类似，但是使用QSpinBox和QDoubleSpinBox作为数字输入输出组件。
图4-3　实例samp4_3运行时界面
QSpinBox和QDoubleSpinBox都是QAbstractSpinBox的子类，具有大多数相同的属性，只是参数类型不同。在UI设计器里进行界面设计时，就可以设置这些属性。QSpinBox和QDoubleSpinBox的主要属性见表4-1。
表4-1　QSpinBox和QDoubleSpinBox的主要属性






属性名称
描述
prefix
数字显示的前缀，例如“$”
suffix
数字显示的后缀，例如“kg”
minimum
数值范围的最小值，如0
maximum
数值范围的最大值，如255
singlestep
单击右侧上下调整按钮时的单步改变值，如设置为1，或0.1
value
当前显示的值
displayIntegerBase
QSpinBox特有属性，显示整数使用的进制，例如2就表示二进制
decimals
QDoubleSpinBox特有属性，显示数值的小数位数，例如2就显示两位小数提示　
一个属性在类的接口中一般有一个读取函数和一个设置函数，如QDoubleSpinBox的decimals属性，读取属性值的函数为int decimals()，设置属性值的函数为void setDecimals(int prec)。
图4-3中各个SpinBox的类型及属性设置一目了然，不再赘述。使用QSpinBox和Qdouble SpinBox进行数值量的输入输出很方便，下面是图4-3中“计算”按钮和“十进制”后面的按钮的槽函数代码。void Widget::on_btnCal_clicked()
{ //计算
   int num=ui->spinNum->value();  
   float price=ui->spinPrice->value();
   float total=num*price;
   ui->spinTotal->setValue(total); 
}
void Widget::on_btnBin_clicked()
{ //读取二进制数，以其他进制显示
   int val=ui->spinBin->value();
   ui->spinDec->setValue(val);
   ui->spinHex->setValue(val);
}
在使用QSpinBox和QDoubleSpinBox读取和设置数值时，无需做字符串与数值之间的转换，也无需做进制的转换，其显示效果（前缀、后缀、进制和小数位数）在设置好之后就自动按照效果进行显示，这对于数值的输入输出是非常方便的。
4.3　其他数值输入和显示组件
4.3.1　实例功能
除了LineEdit和SpinBox之外，还有其他一些用于数值输入和显示的组件。实例samp4_4演示如何使用这些组件，图4-4是实例samp4_4的设计界面。






图4-4　实例Samp4_4设计界面
在这个实例中，用到如下一些组件。
QSlider：滑动条，通过滑动来设置数值，可用于数值输入。实例中使用4个滑动条输入红、绿、蓝三色和Alpha值，然后合成颜色，作为一个QTextEdit组件的底色。
QScrollBar：卷滚条，与QSlider功能类似，还可以用于卷滚区域。
QProgressBar：进度条，一般用于显示任务进度，可用于数值的百分比显示。实例程序中滑动一个Slider，获取其值并更新ScrollBar和ProgressBar。
QDial：表盘式数值输入组件，通过转动表针获得输入值。
QLCDNumber：模仿LCD数字的显示组件，可以显示整数或浮点数，显示整数时可以不同进制显示。实例程序中转动表盘，获得的值显示在LCD组件中。单击“LCD显示进制”的RadioButton时，设置LCD的显示进制。
4.3.2　各组件的主要功能和属性
1．QSlider
QSlider、QScrollBar和Qdial 3个组件都从QAbstractSlider继承而来，有一些共有的属性。QSlider是滑动的标尺型组件，滑动标尺上的一个滑块可以改变值。
基类QAbstractSlider的主要属性包括以下几种。
minimum、maximum：设置输入范围的最小值和最大值，例如，用红、绿、蓝配色时，每种基色的大小范围是0~255，所以设置minimum为0，maximum为255。
singleStep：单步长，拖动标尺上的滑块，或按下左/右光标键时的最小变化数值。
pageStep：在Slider上输入焦点，按PgUp或PgDn键时变化的数值。
value：组件的当前值，拖动滑块时自动改变此值，并限定在minimum和maximum定义的范围之内。
sliderPosition：滑块的位置，若tracking属性设置为true，sliderPosition就等于value。
tracking：sliderPosition是否等同于value，如果tracking=true，改变value时也同时改变sliderPosition。
orientation：Slider的方向，可以设置为水平或垂直。方向参数是Qt的枚举类型enum Qt::Orientation，取值包括以下两种。 
Qt::Horizontal 水平方向
Qt::Vertical 垂直方向
invertedAppearance：显示方式是否反向，invertedAppearance=false时，水平的Slider由左向右数值增大，否则反过来。
invertedControls：反向按键控制，若invertedControls=true，则按下PgUp或PgDn按键时调整数值的方向相反。















































































第13章　多线程
一个应用程序一般只有一个线程，一个线程内的操作是顺序执行的，如果有某个比较消耗时间的计算或操作，比如网络通信中的文件传输，在一个线程内操作时，用户界面就可能会冻结而不能及时响应。这种情况下，可以创建一个单独的线程来执行比较消耗时间的操作，并与主线程之间处理好同步与数据交互，这就是多线程应用程序。
Qt为多线程操作提供了完整的支持。QThread是线程类，是实现多线程操作的核心类，一般从QThread继承定义自己的线程类。线程之间的同步是其交互的主要问题，Qt提供了QMutex、QMutexLocker、QReadWriteLock、QwaitCondition、QSemaphore等多种类用于实现线程之间的同步。Qt还有Qt Concurrent模块，提供一些高级的API实现多线程编程而无需使用QMutex、QwaitCondition和QSemaphore等基础操作。使用Qt Concurrent实现的多线程程序可以自动根据处理器内核个数调整线程个数。
本章主要介绍用QThread实现多线程编程的方法，以及用QMutex、QWaitCondition、QSemaphore等实现线程同步的方法。
13.1　QThread创建多线程程序
13.1.1　QThread类功能简介
QThread类提供不依赖于平台的管理线程的方法。一个QThread类的对象管理一个线程，一般从QThread继承一个自定义类，并重定义虚函数run()，在run()函数里实现线程需要完成的任务。
将应用程序的线程称为主线程，额外创建的线程称为工作线程。一般在主线程里创建工作线程，并调用start()开始执行工作线程的任务。start()会在内部调用run()函数，进入工作线程的事件循环，在run()函数里调用exit()或quit()可以结束线程的事件循环，或在主线程里调用terminate()强制结束线程。
QThread类的主要接口函数、信号和槽函数见表13-1。
表13-1　Qthread类的主要接口
类型		函数		功能
公共函数		bool isFinished()		线程是否结束    
                bool isRunning()		线程是否正在运行		
Priority　      priority()              返回线程的优先级
公共函数        void setPriority (Priority priority)       设置线程的优先级
                 void exit(int returnCode = 0)       退出线程的事件循环，退出码为returnCode，0表示成功退出；否则表示有错误
               bool wait(unsigned long time )    阻止线程执行，直到线程结束（从run()函数返回），或等待时间超过time毫秒

公共槽函数     void　quit()              退出线程的事件循环，并返回代码0，等效于exit(0)
               void start(Priority priority ) 内部调用run()开始执行线程，操作系统根据priority参数进行调度
               void terminate()               终止线程的运行，但不是立即结束线程，而是等待操作系统结束线程。使用terminate()之后应使用wait()
信号            void finished()               在线程就要结束时发射此信号
               void started()                 在线程开始执行、run()函数被调用之前发射此信号
静态公共成员   int idealThreadCount()         返回系统上能运行的线程的理想个数
               void msleep(unsigned long msecs)  强制当前线程休眠msecs毫秒
               void sleep(unsigned long secs)    强制当前线程休眠secs秒
               void usleep(unsigned long usecs)   强制当前线程休眠usecs微秒
保护函数       virtual void run()                 start()调用run()函数开始线程任务的执行，所以在run()函数里实现线程的任务功能
               int exec()                        由run()函数调用，进入线程的事件循环，等待exit()退出
QThread是QObject的子类，所以可以使用信号与槽机制。QThread自身定义了started()和finished()两个信号，started()信号在线程开始执行之前发射，也就是在run()函数被调用之前，finished()信号在线程就要结束时发射。
13.1.2　掷骰子的线程QDiceThread
作为实例，定义一个掷骰子的线程类QDiceThread，类的声明部分如下：#include   <Qthread>
class QDiceThread : public Qthread
{
   Q_OBJECT
private:
   int    m_seq=0;          //掷骰子次数序号
   int    m_diceValue;      //骰子点数
   bool   m_Paused=true;    //暂停
   bool   m_stop=false;     //停止
protected:
   void   run() Q_DECL_OVERRIDE;  //线程任务
public:
   QDiceThread();
   void   diceBegin();      //掷一次骰子
   void   dicePause();      //暂停
   void   stopThread();     //结束线程
signals:
   void   newValue(int seq,int diceValue); //产生新点数的信号
};
重载虚函数run()，在此函数里完成线程的主要任务。
自定义diceBegin()、dicePause()、stopThread() 3个公共函数用于线程控制，这3个函数由







主线程调用。
定义了一个信号newValue(int seq,int diceValue) 用于在掷一次骰子得到新的点数之后发射此信号，由主线程的槽函数响应以获取值。
QDiceThread类的实现代码如下：#include   " qdicethread.h"
#include   <QTime>
QDiceThread::QDiceThread()
{//构造函数
}
void QDiceThread::diceBegin()
{ //开始掷骰子
   m_Paused=false;
}
void QDiceThread::dicePause()
{//暂停掷骰子
   m_Paused=true;
}
void QDiceThread::stopThread()
{//停止线程
   m_stop=true;
}
void QDiceThread::run()
{//线程任务
   m_stop=false;//启动线程时令m_stop=false
   m_seq=0; //掷骰子次数
   qsrand(QTime::currentTime().msec());//随机数初始化，qsrand是线程安全的
   while(!m_stop)//循环主体
   {
      if (!m_Paused)
      {
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
         emit newValue(m_seq,m_diceValue);  //发射信号
      }
      msleep(500); //线程休眠500ms
   }
   quit();//相当于exit(0),退出线程的事件循环
}
其中，run()是线程任务的实现部分，线程开始就执行run()函数。run()函数一般是事件循环过程，根据各种条件或事件处理各种任务。当run()函数退出时，线程的事件循环就结束了。
在run()函数里，初始化变量m_stop和m_seq，用qsrand()函数对随机数种子初始化。run()函数的主循环体是一个while循环，在主线程调用stopThread()函数使m_stop为true，才会退出while循环，调用quit()之后结束线程。
在while循环体内，又根据m_Paused判断当前是否需要掷骰子，如果需要掷骰子，则用随机函数生成一次骰子的点数m_diceValue，然后发射信号newValue()，将m_seq和m_diceValue作为信号参数传递出去。主线程可以设计槽函数与此信号关联，获取这两个值并进行显示。
13.1.3　掷骰子的多线程应用程序
使用QDiceThread类，设计一个应用程序samp13_1，程序运行界面如图13-1所示。






图13-1　掷骰子多线程应用程序samp13_1运行界面
窗体上方的几个按钮用于控制线程的启动与停止，控制开始与暂停掷骰子。中间的文本框显示次数和点数，右边根据点数显示资源文件里面的一个图片，图片存储在项目的资源文件里。下方的一个标签根据QDiceThread的started()和finished()两个信号显示线程的状态。
窗口类是从QDialog继承的类Dialog，其类定义如下（省略了按钮槽函数的定义）：class Dialog : public QDialog
{
   Q_OBJECT
private:
   QDiceThread   threadA;
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit Dialog(QWidget *parent = 0);
   ~Dialog();
private slots:
//自定义槽函数
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onthreadA_newValue(int seq, int diceValue);
private:
   Ui::Dialog *ui;
};
这里定义了一个QDiceThread类型的变量threadA，重定义了closeEvent()事件，自定义了3个槽函数。
Dialog类的构造函数代码如下：Dialog::Dialog(QWidget *parent) : QDialog(parent),  ui(new Ui::Dialog)
{//构造函数
   ui->setupUi(this);
   connect(&threadA,SIGNAL(started()),this,SLOT(onthreadA_started()));
   connect(&threadA,SIGNAL(finished()),this,SLOT(onthreadA_finished()));
   connect(&threadA,SIGNAL(newValue(int,int)),
             this,SLOT(onthreadA_newValue(int,int)));
}
构造函数主要是将threadA的3个信号与Dialog自定义的3个槽函数相关联，这3个槽函数的代码如下：void Dialog::onthreadA_started()
{//线程的started()信号的响应槽函数
   ui->LabA->setText("Thread状态：thread started");
}
void Dialog::onthreadA_finished()
{//线程的 finished()信号的响应槽函数
   ui->LabA->setText("Thread状态：thread finished");
}






void Dialog::onthreadA_newValue(int seq,int diceValue)
{//QDiceThread的newValue()信号的响应槽函数，显示骰子次数和点数
   QString  str=QString::asprintf("第 %d 次掷骰子，点数为：%d",seq,diceValue);
   ui->plainTextEdit->appendPlainText(str);
   QPixmap pic; //图片显示
   QString filename=QString::asprintf(":/dice/images/d%d.jpg",diceValue);
   pic.load(filename);
   ui->LabPic->setPixmap(pic);
}
started()信号发射时，表示线程开始执行，在标签里显示状态文字。
finished()信号发射时，表示线程结束执行，在标签里显示状态文字。
newValue()是QDiceThread定义的信号，在掷一次骰子获得新的点数后发射，将掷骰子的次数和点数传递过来。槽函数onthreadA_newValue()获取这两个值并显示在文本框里，再根据点数从资源文件里获取相应的图片并显示。
窗口上5个按钮的代码如下：void Dialog::on_btnStartThread_clicked()
{//启动线程 按钮
   threadA.start();
   ui->btnStartThread->setEnabled(false);
   ui->btnStopThread->setEnabled(true);
   ui->btnDiceBegin->setEnabled(true);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnStopThread_clicked()
{//结束线程 按钮
   threadA.stopThread();//结束线程的run()函数执行
   threadA.wait();
   ui->btnStartThread->setEnabled(true);
   ui->btnStopThread->setEnabled(false);
   ui->btnDiceBegin->setEnabled(false);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnDiceBegin_clicked()
{//开始 掷骰子按钮
   threadA.diceBegin();
   ui->btnDiceBegin->setEnabled(false);
   ui->btnDiceEnd->setEnabled(true);
}
void Dialog::on_btnDiceEnd_clicked()
{//暂停 掷骰子按钮
   threadA.dicePause();
   ui->btnDiceBegin->setEnabled(true);
   ui->btnDiceEnd->setEnabled(false);
}
void Dialog::on_btnClear_clicked()
{ //清空文本 按钮
   ui->plainTextEdit->clear();
}
“启动线程”按钮调用线程的start()函数，start()函数会内部调用run()函数开始线程任务的执行。run()函数将内部变量m_Paused初始化为true，所以，启动线程后并不会立即开始掷骰子。
“开始”按钮调用diceBegin()函数，使threadA线程内部变量m_Paused变为false，那么run()函数里就开始每隔500毫秒产生一次骰子点数，并发射信号newValue()。
“暂停”按钮调用dicePause()函数，使threadA线程内部变量m_Paused变为true，run()函数里不再掷骰子，但是run()函数并没有结束，也就是线程并没有结束。




“结束线程”按钮调用stopThread()函数，使threadA线程内部的m_stop变为true，run()函数体的while循环结束，执行quit()后线程结束。所以，线程结束就是run()函数执行退出。
重载closeEvent()事件，在窗口关闭时确保线程被停止，代码如下：void Dialog::closeEvent(QCloseEvent *event)
{ //窗口关闭事件，必须结束线程
   if (threadA.isRunning())
   {
      threadA.stopThread();
      threadA.wait();
   }
   event->accept();
}
13.2　线程同步
13.2.1　线程同步的概念
在多线程应用程序中，由于多个线程的存在，线程之间可能需要访问同一个变量，或一个线程需要等待另外一个线程完成某个操作后才产生相应的动作。例如，在上一节的实例samp13_1中，工作线程产生随机的骰子点数，主线程读取骰子点数并显示，主线程需要等待工作线程产生一个新的骰子点数后再读取数据。实例samp13_1中使用了信号与槽的机制，在产生新的骰子数之后通过信号通知主线程读取新的数据。
如果不使用信号与槽机制，QDiceThread的run()函数变为如下的代码：void QDiceThread::run()
{
   m_stop=false;//启动线程时令m_stop=false
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化，qsrand是线程安全的
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
      }
      msleep(500); //线程休眠
   }
}
那么，QDiceThread需要定义公共函数，返回m_diceValue的值，如：int QDiceThread::diceValue () { return = m_diceValue;}
以便在主线程中调用此函数读取骰子的点数。
由于没有信号与槽的关联（信号与槽的关系类似于硬件的中断与中断处理函数），主线程只能采用不断查询的方式主动查询是否有新数据，并读取它。但是在主线程调用diceValue()读取骰子点数时，工作线程可能正在执行run()函数里修改m_diceValue值的语句，即：m_diceValue=qrand(); //获取随机数
m_diceValue=(m_diceValue % 6)+1;
m_seq++;
而且这几条语句计算量大，需要执行较长时间。执行这两条语句时不希望被主线程调用的diceValue()函数中断，如果中断，则主线程得到的可能是错误的值。







这种情况下，这样的代码段是希望被保护起来的，在执行过程中不能被其他线程打断，以保证计算结果的完整性，这就是线程同步的概念。
在Qt中，有多个类可以实现线程同步的功能，包括QMutex、QMutexLocker、QReadWriteLock、QReadLocker、QWriteLocker、QWaitCondition和QSemaphore。下面将分别介绍这些类的用法。
13.2.2　基于互斥量的线程同步
QMutex和QMutexLocker是基于互斥量的线程同步类，QMutex定义的实例是一个互斥量，QMutex主要提供3个函数。
lock()：锁定互斥量，如果另外一个线程锁定了这个互斥量，它将阻塞执行直到其他线程解锁这个互斥量。
unlock()：解锁一个互斥量，需要与lock()配对使用。
tryLock()：试图锁定一个互斥量，如果成功锁定就返回true；如果其他线程已经锁定了这个互斥量，就返回false，但不阻塞程序执行。
使用互斥量，对QDiceThread类重新定义，不采用信号与槽机制，而是提供一个函数用于主线程读取数据。更改后的QDiceThread类定义如下：class QDiceThread : public Qthread
{
   Q_OBJECT
private:
   QMutex  mutex; //互斥量
   int    m_seq=0;//序号
   int    m_diceValue;
   bool   m_paused=true;
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QDiceThread();
   void   diceBegin();//掷一次骰子
   void   diceEnd();
   void   stopThread();
   bool   readValue(int *seq, int *diceValue); //用于主线程读取数据的函数
};
QDiceThread类里用QMutex类定义了一个互斥量变量mutex。
定义了函数readValue()，用于外部线程读取掷骰子的次数和点数，传递参数采用指针变量，以便一次读取两个数据。
下面是QDiceThread类中关键的run()和readValue()函数的实现代码。void QDiceThread::run()
{
   m_stop=false;
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         mutex.lock();
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
         mutex.unlock();







    }
      msleep(500); //线程休眠
   }
}
bool QDiceThread::readValue(int *seq, int *diceValue)
{
   if (mutex.tryLock())
   {
      *seq=m_seq;
      *diceValue=m_diceValue;
      mutex.unlock();
      return true;
   }
   else
      return false;
}
在run()函数中，对重新计算骰子点数和掷骰子次数的3行代码用互斥量mutex的lock()和unlock()进行了保护，这部分代码的执行就不会被其他线程中断。注意，lock()与unlock()必须配对使用。
在readValue()函数中，用互斥量mutex的tryLock()和unlock()进行了保护。如果tryLock()成功锁定互斥量，读取数值的两行代码执行时不会被中断，执行完后解锁；如果tryLock()锁定失败，函数就立即返回，而不会等待。
原理上，对于两个或多个线程可能会同时读或写的变量应该使用互斥量进行保护，例如QDiceThread中的变量m_stop和m_paused，在run()函数中读取这两个变量，要在diceBegin()、diceEnd()和stopThread()函数里修改这些值，但是这3个函数都只有一条赋值语句，可以认为是原子操作，所以，可以不用锁定保护。
定义的互斥量mutex相当于一个标牌，可以这样来理解互斥量：列车上的卫生间一次只能进一个人，当一个人尝试进入卫生间就是lock()，如果有人占用，他就只能等待；等里面的人出来，腾出了卫生间是unlock()，这个等待的人才可以进入并且锁住卫生间的门，就是lock()，使用完卫生间之后他再出来时就是unlock()。
QMutex需要配对使用lock()和unlock()来实现代码段的保护，在一些逻辑复杂的代码段或可能发生异常的代码中，配对就可能出错。
QMutexLocker是另外一个简化了互斥量处理的类。QMutexLocker的构造函数接受一个互斥量作为参数并将其锁定，QMutexLocker的析构函数则将此互斥量解锁，所以在QMutexLocker实例变量的生存期内的代码段得到保护，自动进行互斥量的锁定和解锁。例如，QDiceThread的run()函数的代码可以改写如下：void QDiceThread::run()
{
   m_stop=false;
   m_seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      if (!m_paused)
      {
         QMutexLocker  Locker(&mutex);
         m_diceValue=qrand(); //获取随机数
         m_diceValue=(m_diceValue % 6)+1;
         m_seq++;
      }
      msleep(500); //线程休眠
   }
}







这样定义的QDiceThread类，在主程序中只能调用其readValue()函数来不断读取数值。实例samp13_2采用QMutex进行线程同步，实例samp13_3采用QMutex和QMutexLocker进行线程同步，其界面与samp13_1完全相同，只是增加了定时器，用于定时主动去读取掷骰子线程的数值。
实例程序samp13_2的Dialog类的主要定义如下（省略了一些系统生成的声明）：class Dialog : public QDialog
{
private:
   int  mSeq, mDiceValue;
   QDiceThread   threadA;
   QTimer  mTimer;//定时器
public:
   explicit Dialog(QWidget *parent = 0);
private slots:
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onTimeOut(); //定期器处理槽函数
};
主要是增加了一个定时器mTimer和其时间溢出响应槽函数onTimeOut()，在Dialog的构造函数中将mTimer的timeout信号与此槽函数关联。connect(&mTimer,SIGNAL(timeout()),this,SLOT(onTimeOut()));
onTimeOut()函数的主要功能是调用threadA的readValue()函数读取数值。定时器的定时周期设置为100ms，小于threadA产生一次新数据的周期（500ms），所以可能读出旧的数据，通过存储的掷骰子的次数与读取的掷骰子次数是否不同，判断是否为新数据。onTimeOut()函数的代码如下：void Dialog::onTimeOut()
{ //定时器溢出处理槽函数
  int  tmpSeq=0,tmpValue=0;
  bool  valid=threadA.readValue(&tmpSeq,&tmpValue); //读取数值
  if (valid && (tmpSeq!=mSeq)) //有效，并且是新数据
  {
    mSeq=tmpSeq;
    mDiceValue=tmpValue;
    QString  str=QString::asprintf("第 %d 次掷骰子，点数为：%d", mSeq,mDiceValue);
   ui->plainTextEdit->appendPlainText(str);
   QPixmap pic;
   QString filename=QString::asprintf(":/dice/images/d%d.jpg",mDiceValue);
   pic.load(filename);
   ui->LabPic->setPixmap(pic);
  }
}
窗口上几个按钮的代码如下（省略了按钮使能控制的代码）：void Dialog::on_btnStartThread_clicked()
{//启动线程
   mSeq=0;
   threadA.start();
}
void Dialog::on_btnStopThread_clicked()
{//结束线程
   threadA.stopThread();//结束线程的run()函数执行
   threadA.wait();
}
void Dialog::on_btnDiceBegin_clicked()
{//开始掷骰子
   threadA.diceBegin();
   mTimer.start(100); //定时器100ms读取一次数据





}

void Dialog::on_btnDiceEnd_clicked()
{//暂停掷骰子
   threadA.diceEnd(); 
   mTimer.stop();//定时器暂停
}
实例samp13_2和samp13_3实现的效果与实例samp13_1相同，只是实现的方式不同。
13.2.3　基于QReadWriteLock的线程同步
使用互斥量时存在一个问题：每次只能有一个线程获得互斥量的权限。如果在一个程序中有多个线程读取某个变量，使用互斥量时也必须排队。而实际上若只是读取一个变量，是可以让多个线程同时访问的，这样互斥量就会降低程序的性能。
例如，假设有一个数据采集程序，一个线程负责采集数据到缓冲区，一个线程负责读取缓冲区的数据并显示，另一个线程负责读取缓冲区的数据并保存到文件，示意代码如下：int   buffer[100];
QMutex  mutex;
void   threadDAQ::run()
{   ...
   mutex.lock();
   get_data_and_write_in_buffer();   //数据写入buffer
   mutex.unlock();
   ...   
}
void   threadShow::run()
{   ...
   mutex.lock();
   show _buffer();   //读取 buffer里的数据并显示
   mutex.unlock();
   ...   
}
void   threadSaveFile::run()
{   ...
   mutex.lock();
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   mutex.unlock();
   ...  
}
数据缓冲区buffer和互斥量mutex都是全局变量，线程threadDAQ将数据写到buffer，线程threadShow和threadSaveFile只是读取buffer，但是因为使用互斥量，这3个线程任何时候都只能有一个线程可以访问buffer。而实际上，threadShow和threadSaveFile都只是读取buffer的数据，它们同时访问buffer是不会发生冲突的。
Qt提供了QReadWriteLock类，它是基于读或写的模式进行代码段锁定的，在多个线程读写一个共享数据时，可以解决上面所说的互斥量存在的问题。
QReadWriteLock以读或写锁定的同步方法允许以读或写的方式保护一段代码，它可以允许多个线程以只读方式同步访问资源，但是只要有一个线程在以写方式访问资源时，其他线程就必须等待直到写操作结束。
QReadWriteLock提供以下几个主要的函数：
lockForRead()，以只读方式锁定资源，如果有其他线程以写入方式锁定，这个函数会阻塞；
lockForWrite()，以写入方式锁定资源，如果本线程或其他线程以读或写模式锁定资源，这个函数就阻塞；







unlock()，解锁；
tryLockForRead()，是lockForRead()的非阻塞版本；
tryLockForWrite()，是lockForWrite()的非阻塞版本。
使用QReadWriteLock，上面的三线程代码可以改写为如下的形式：int   buffer[100];
QReadWriteLock   Lock;
void   threadDAQ::run()
{   ...
   Lock.lockForWrite();
   get_data_and_write_in_buffer();   //数据写入buffer
   Lock.unlock();
   ...   
}
void   threadShow::run()
{   ...
   Lock.lockForRead();
   show_buffer();   //读取 buffer里的数据并显示
   Lock.unlock();
   ...   
}
void   threadSaveFile::run()
{   ...
   Lock.lockForRead();
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   Lock.unlock();
   ...  
}
这样，如果threadDAQ没有以lockForWrite()锁定Lock，threadShow和threadSaveFile可以同时访问buffer，否则threadShow和threadSaveFile都被阻塞；如果threadShow和threadSaveFile都没有锁定，那么threadDAQ能以写入方式锁定，否则threadDAQ就被阻塞。
QReadLocker和QWriteLocker是QReadWriteLock的简便形式，如同QMutexLocker是QMutex的简便版本一样，无需与unlock()配对使用。使用QReadLocker 和QWriteLocker，则上面的代码改写为：int   buffer[100];
QReadWriteLock   Lock;
void   threadDAQ::run()
{   ...
   QWriteLocker  Locker(&Lock);
   get_data_and_write_in_buffer();   //数据写入buffer
   ...   
}
void   threadShow::run()
{   ...
QReadLocker Locker(&Lock);
   show _buffer();   //读取 buffer里的数据并显示
   ...   
}
void   threadSaveFile::run()
{   ...
QReadLocker Locker(&Lock);
   Save_buffer_toFile();   //读取 buffer里的数据并保存到文件
   ...  
}
13.2.4　基于QWaitCondition的线程同步






在多线程的程序中，多个线程之间的同步实际上就是它们之间的协调问题。例如上一小节讲到的3个线程的例子中，假设threadDAQ写满一个缓冲区之后，threadShow和threadSaveFile才能对缓冲区进行读操作。前面采用的互斥量和基于QReadWriteLock的方法都是对资源的锁定和解锁，避免同时访问资源时发生冲突。在一个线程解锁资源后，不能及时通知其他线程。
QWaitCondition提供了另外一种改进的线程同步方法，QWaitCondition与QMutex结合，可以使一个线程在满足一定条件时通知其他多个线程，使它们及时作出响应，这样比只使用互斥量效率要高一些。例如，threadDAQ在写满一个缓冲区之后，及时通知threadShow和threadSaveFile，使它们可以及时读取缓冲区数据。
QWaitCondition提供如下一些函数：
wait(QMutex *lockedMutex)，解锁互斥量lockedMutex，并阻塞等待唤醒条件，被唤醒后锁定lockedMutex并退出函数；
wakeAll()，唤醒所有处于等待状态的线程，线程唤醒的顺序不确定，由操作系统的调度策略决定；
wakeOne()，唤醒一个处于等待状态的线程，唤醒哪个线程不确定，由操作系统的调度策略决定。
QWaitCondition一般用于“生产者/消费者”（producer/consumer）模型中。“生产备”产生数据，“消费者”使用数据，前述的数据采集、显示与存储的三线程例子就适用这种模型。
创建实例程序samp13_4，将掷骰子的程序修改为producer/consumer模型，一个线程类QThreadProducer专门负责掷骰子产生点数；一个线程类QThreadConsumer专门及时读取数据，并送给主线程进行显示。这两个类定义在一个文件qmythread.h里，定义代码如下：class QThreadProducer : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadProducer();
   void   stopThread();
};

class QThreadConsumer : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadConsumer();
   void   stopThread();
signals:
   void   newValue(int seq,int diceValue);
};
QThreadProducer用于掷骰子，但是去掉了开始和暂停的功能，线程一启动就连续地掷骰子。QThreadConsumer用于读取掷骰子的次数和点数，并用发射信号方式把数据传递出去。这两个类的实现代码在一个文件qmythread.cpp里，下面是这两个类的实现代码的主要部分：QMutex  mutex;
QWaitCondition  newdataAvailable;
int    seq=0;//序号
int    diceValue;
void QthreadProducer::run()
{





  m_stop=false;
   seq=0;
   qsrand(QTime::currentTime().msec());//随机数初始化
   while(!m_stop)//循环主体
   {
      mutex.lock();
      diceValue=qrand(); //获取随机数
      diceValue=(diceValue % 6)+1;
      seq++;
      mutex.unlock();
      newdataAvailable.wakeAll(); //唤醒所有线程，有新数据了
      msleep(500); //线程休眠
   }
}

void QthreadConsumer::run()
{
   m_stop=false;
   while(!m_stop)//循环主体
   {
      mutex.lock();
      newdataAvailable.wait(&mutex);//先解锁mutex，使其他线程可以使用mutex
      emit  newValue(seq,diceValue);
      mutex.unlock();
   }
}
掷骰子的次数和点数的变量定义为共享变量，这样两个线程都可以访问。定义了互斥量mutex，定义了QWaitCondition实例newdataAvailable，表示有新数据可用了。
QThreadProducer::run()函数负责每隔500毫秒掷骰子产生一次数据，新数据产生后通过等待条件唤醒所有等待的线程，即：newdataAvailable.wakeAll();
QThreadConsumer::run()函数中的while循环，首先需要将互斥量锁定，再执行下面的一条语句：newdataAvailable.wait(&mutex);
这条语句以mutex作为输入参数，内部会首先解锁mutex，使其他线程可以使用mutex，newdataAvailable进入等待状态。当QThreadProducer产生新数据使用newdataAvailable.wakeAll()唤醒所有线程后，newdataAvailable.wait(&mutex)会再次锁定mutex，然后退出阻塞状态，以执行后面的语句。
所以，使用QWaitCondition可以使QThreadConsumer线程的执行过程进入等待状态。在QThreadProducer线程满足条件后，唤醒QThreadConsumer线程及时退出等待状态，继续执行后面的程序。
使用QThreadProducer和QThreadConsumer实现掷骰子的实例程序samp13_4运行时界面如图13-2所示，与实例samp13_1的运行界面类似，只是取消了开始和暂停掷骰子的按钮，下方的状态标签显示了两个线程的状态







图13-2　使用QWaitCondition的线程同步实例程序samp13_4运行界面
窗口的Dialog类的定义如下（省略了按钮槽函数等一些不重要的部分）：class Dialog : public QDialog
{   Q_OBJECT
private:
   QthreadProducer   threadProducer;
   QthreadConsumer   threadConsumer;
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit Dialog(QWidget *parent = 0);
private slots:
   void   onthreadA_started();
   void   onthreadA_finished();
   void   onthreadB_started();
   void   onthreadB_finished();
   void   onthreadB_newValue(int seq, int diceValue);
};
这里主要是定义了两个线程的实例，并定义了几个自定义槽函数。采用信号与槽的方式与threadConsumer建立通信并获取数据。Dialog的构造函数主要完成信号与槽函数的关联，5个自定义槽函数的代码与实例samp13_1的相同或相似，这几个函数的代码不再详细列出。
“启动线程”按钮的代码如下：void Dialog::on_btnStartThread_clicked()
{//启动线程
   threadConsumer.start();
   threadProducer.start();
   ui->btnStartThread->setEnabled(false);
   ui->btnStopThread->setEnabled(true);
}
两个线程启动的先后顺序不应调换，应先启动threadConsumer，使其先进入wait状态，后启动threadProducer，这样在threadProducer里wakeAll()时threadConsumer就可以及时响应，否则会丢失第一次掷骰子的数据。
“结束线程”按钮的代码如下：void Dialog::on_btnStopThread_clicked()
{//结束线程
   threadProducer.stopThread();//结束线程的run()函数执行
   threadProducer.wait();
   threadConsumer.terminate(); //可能处于等待状态，用terminate强制结束
   threadConsumer.wait();
   ui->btnStartThread->setEnabled(true);
   ui->btnStopThread->setEnabled(false);
}
结束线程时，若按照上面的顺序先结束threadProducer线程，则必须使用terminate()来强









制结束threadConsumer线程，因为threadConsumer可能还处于条件等待的阻塞状态中，将无法正常结束线程。
13.2.5　基于信号量的线程同步
1．信号量的原理
信号量（Semaphore）是另一种限制对共享资源进行访问的线程同步机制，它与互斥量（Mutex）相似，但是有区别。一个互斥量只能被锁定一次，而信号量可以多次使用。信号量通常用来保护一定数量的相同的资源，如数据采集时的双缓冲区。
QSemaphore是实现信号量功能的类，它提供以下几个基本的函数：
acquire(int n)尝试获得n个资源。如果没有这么多资源，线程将阻塞直到有n个资源可用；
release(int n)释放n个资源，如果信号量的资源已全部可用之后再release()，就可以创建更多的资源，增加可用资源的个数；
int available()返回当前信号量可用的资源个数，这个数永远不可能为负数，如果为0，就说明当前没有资源可用；
bool tryAcquire(int n = 1)，尝试获取n个资源，不成功时不阻塞线程。
定义QSemaphore的实例时，可以传递一个数值作为初始可用的资源个数。
下面的一段示意代码，说明QSemaphore的几个函数的作用。QSemaphore  WC(5);  // WC.available() == 5，初始资源个数为5个
WC.acquire(4);      // WC.available() == 1，用了4个资源，还剩余1个可用
WC.release(2);      // WC.available() == 3，释放了2个资源，剩余3个可用
WC.acquire(3);      // WC.available() == 0，又用了3个资源，剩余0个可用
WC.tryAcquire(1);   //因为WC.available() == 0, 返回 false，
WC.acquire();      //因为WC.available() == 0, 没有资源可用，阻塞
为了理解信号量及上面这段代码的意义，可以假想变量WC是一个公共卫生间，初始化时定义WC有5个位置可用。
WC.acquire(4)，成功进去4个人，占用了4个位置，还剩余1个位置；
WC.release (2)，出来了2个人，剩余3个位置可用；
WC.acquire(3)，又进去3个人，剩余0个位置可用；
WC.tryAcquire(1)，有一个人尝试进去，但是因为没有位置了，他不等待，走了，tryAcquire()函数返回false；
WC.acquire()，有一个人必须进去，但是因为没有位置了，他就一直在外面等着，直到有其他人出来，空余出位置来。
互斥量相当于列车上的卫生间，一次只允许一个人进出，信号量则是多人公共卫生间，允许多人进出。n个资源就是信号量需要保护的共享资源，至于资源如何分配，就是内部处理的问题了。
2．双缓冲区数据采集和读取线程类设计
信号量通常用来保护一定数量的相同的资源，如数据采集时的双缓冲区，适用于Producer/Consumer模型。
在实例samp13_5中，创建类似于Producer/Consumer模型的两个线程类QThreadDAQ和QThreadShow。qmythread.h文件中这两个类的定义如下：class QThreadDAQ : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadDAQ();






void   stopThread();
};

class QThreadShow : public Qthread
{   Q_OBJECT
private:
   bool   m_stop=false; //停止线程
protected:
   void   run() Q_DECL_OVERRIDE;
public:
   QThreadShow();
   void   stopThread();
signals:
   void   newValue(int *data,int count, int seq);
};
QThreadDAQ是数据采集线程，例如在使用数据采集卡进行连续数据采集时，需要一个单独的线程将采集卡采集的数据读取到缓冲区内。
QThreadShow是数据读取线程，用于读取已存满数据的缓冲区中的数据并传递给主线程显示，采用信号与槽机制与主线程交互。
QThreadDAQ/QThreadShow类的定义与使用QWaitCondition的实例samp13_4中的QThreadProducer/QThreadConsumer类的定义类似，只是QThreadShow的信号newValue()采用了指针作为传递参数，用于一次传递出一个缓冲区的数据。
qmythread.cpp文件中QThreadDAQ和QThreadShow的主要功能代码如下：#include   "qmythread.h"
#include   <QSemaphore>
const int BufferSize = 8;
int buffer1[BufferSize];
int buffer2[BufferSize];
　
int curBuf=1; //当前正在写入的Buffer
int bufNo=0; //采集的缓冲区序号
quint8   counter=0;//数据生成器
　
QSemaphore emptyBufs(2);//信号量，空的缓冲区个数，初始资源个数为2
QSemaphore fullBufs; //满的缓冲区个数，初始资源为0
　
void QThreadDAQ::run()
{
   m_stop=false;//启动线程时令m_stop=false
   bufNo=0;//缓冲区序号
   curBuf=1; //当前写入使用的缓冲区
   counter=0;//数据生成器
   int n=emptyBufs.available();
   if (n<2)  //保证线程启动时emptyBufs.available==2
     emptyBufs.release(2-n);
   while(!m_stop)//循环主体
   {
      emptyBufs.acquire();//获取一个空的缓冲区
      for(int i=0;i<BufferSize;i++) //产生一个缓冲区的数据
      {
         if (curBuf==1)
            buffer1[i]=counter; //向缓冲区写入数据
         else
            buffer2[i]=counter;
         counter++; //模拟数据采集卡产生数据
         msleep(50); //每50ms产生一个数
      }
      bufNo++;//缓冲区序号
      if (curBuf==1) // 切换当前写入缓冲区





curBuf=2;
      else
        curBuf=1;
      fullBufs.release(); //有了一个满的缓冲区,available==1
   }
}
　
void QThreadShow::run()
{
   m_stop=false;
   int n=fullBufs.available();
   if (n>0)
     fullBufs.acquire(n); //将fullBufs可用资源个数初始化为0
   while(!m_stop)//循环主体
   {
      fullBufs.acquire(); //等待有缓冲区满,当fullBufs.available==0阻塞
      int bufferData[BufferSize];
      int seq=bufNo;
　
      if(curBuf==1) //当前在写入的缓冲区是1，那么满的缓冲区是2
         for (int i=0;i<BufferSize;i++)
            bufferData[i]=buffer2[i]; //快速拷贝缓冲区数据
      else
         for (int i=0;i<BufferSize;i++)
            bufferData[i]=buffer1[i];
　
      emptyBufs.release();//释放一个空缓冲区
      emit   newValue(bufferData,BufferSize,seq);//给主线程传递数据
   }
}
在共享变量区定义了两个缓冲区buffer1和buffer2，都是长度为BufferSize的数组。
变量curBuf记录当前写入操作的缓冲区编号，其值只能是1或2，表示buffer1或buffer2，bufNo是累积的缓冲区个数编号，counter是模拟采集数据的变量。
信号量emptyBufs初始资源个数为2，表示有2个空的缓冲区可用。
信号量fullBufs初始化资源个数为0，表示写满数据的缓冲区个数为零。
QThreadDAQ::run()采用双缓冲方式进行模拟数据采集，线程启动时初始化共享变量，特别的是使emptyBufs的可用资源个数初始化为2。
在while循环体里，第一行语句emptyBufs.acquire()使信号量emptyBufs获取一个资源，即获取一个空的缓冲区。用于数据缓存的有两个缓冲区，只要有一个空的缓冲区，就可以向这个缓冲区写入数据。
while循环体里的for循环每隔50毫秒使counter值加1，然后写入当前正在写入的缓冲区，当前写入哪个缓冲区由curBuf决定。counter是模拟采集的数据，连续增加可以判断采集的数据是否连续。
完成for循环后正好写满一个缓冲区，这时改变curBuf的值，切换用于写入的缓冲区。
写满一个缓冲区之后，使用fullBufs.release()为信号量fullBufs释放一个资源，这时fullBufs. available==1，表示有一个缓冲区被写满了。这样，QThreadShow线程里使用fullBufs.acquire()就可以获得一个资源，可以读取已写满的缓冲区里的数据。
QThreadShow::run()用于监测是否有已经写满数据的缓冲区，只要有缓冲区写满了数据，就立刻读取出数据，然后释放这个缓冲区给QThreadDAQ线程用于写入。
QThreadShow::run()函数的初始化部分使fullBufs. available==0，即线程刚启动时是没有资








源的。
在while循环体里第一行语句就是通过fullBufs.acquire()以阻塞方式获取一个资源，只有当QThreadDAQ线程里写满一个缓冲区，执行一次fullBufs.release()后，fullBufs.acquire()才获得资源并执行后面的代码。后面的代码就立即用临时变量将缓冲区里的数据读取出来，再调用emptyBufs.release()给信号量emptyBufs释放一个资源，然后发射信号newValue，由主线程读取数据并显示。
所以，这里使用了双缓冲区、两个信号量实现采集和读取两个线程的协调操作。采集线程里使用emptyBufs.acquire()获取可以写入的缓冲区。
实际使用数据采集卡进行连续数据采集时，采集线程是不能停顿下来的，也就是说万一读取线程执行较慢，采集线程是不会等待的。所以实际情况下，读取线程的操作应该比采集线程快。
3．QThreadDAQ和QThreadShow的使用
设计窗口基于QDialog应用程序samp13_5，对话框的类定义如下（省略了一些不重要的或与前面实例重复的部分内容）：class Dialog : public QDialog
{
   Q_OBJECT
private:
   QThreadDAQ   threadProducer;
   QThreadShow   threadConsumer;
private slots:
   void   onthreadB_newValue(int *data, int count, int bufNo);
};
Dialog类定义了两个线程的实例，threadProducer和threadConsumer。
自定义了一个槽函数onthreadB_newValue()，用于与threadConsumer的信号关联，在Dialog的构造函数里进行了关联。connect(&threadConsumer,SIGNAL(newValue(int*,int,int)),
      this,SLOT(onthreadB_newValue(int*,int,int)));
槽函数onthreadB_newValue()的功能就是读取一个缓冲区里的数据并显示，其实现代码如下：void Dialog::onthreadB_newValue(int *data, int count, int bufNo)
{ //读取threadConsumer 传递的缓冲区的数据
   QString  str=QString::asprintf("第 %d 个缓冲区：",bufNo);
   for (int i=0;i<count;i++)
   {
      str=str+QString::asprintf("%d, ",*data);
      data++;
   }
   str=str+'\n';
   ui->plainTextEdit->appendPlainText(str);
}
传递的指针型参数int *data 是一个数组指针，count是缓冲区长度。
“启动线程”和“结束线程”两个按钮的代码如下（省略了按键使能控制的代码）：void Dialog::on_btnStartThread_clicked()
{//启动线程
   threadConsumer.start();
   threadProducer.start();
}
void Dialog::on_btnStopThread_clicked()
{//结束线程









threadConsumer.terminate(); 
   threadConsumer.wait();
   threadProducer.terminate();
   threadProducer.wait();
}
启动线程时，先启动threadConsumer，再启动threadProducer，否则可能丢失第1个缓冲区的数据。
结束线程时，都采用terminate()函数强制结束线程，因为两个线程之间有互锁的关系，若不使用terminate()强制结束会出现线程无法结束的问题。
程序运行时的界面如图13-3所示。
图13-3　实例samp13_5运行界面
从图13-3可以看出，没有出现丢失缓冲区或数据点的情况，两个线程之间协调的很好，将QThreadDAQ::run()函数中模拟采样率的延时时间调整为2毫秒也没问题（正常设置为50毫秒）。
在实际的数据采集中，要保证不丢失缓冲区或数据点，数据读取线程的速度必须快过数据写入缓冲区的线程的速度。














第14章　网络编程
Qt网络模块提供了用于编写TCP/IP客户端和服务器端程序的各种类，如用于TCP通信的QTcpSocket和QTcpServer，用于UDP通信的QUdpSocket，还有用于实现HTTP、FTP等普通网络协议的高级类如QNetworkRequest，QNetworkReply和QNetworkAccessManager。Qt网络模块还提供用于网络代理、网络承载管理的类，提供基于安全套接字层（Secure Sockets Layer，SSL）协议的安全网络通信的类。
本章主要介绍基本的TCP和UDP网络通信类的使用，基于HTTP的网络下载管理的实现。要在程序中使用Qt网络模块，需要在项目配置文件中增加一条配置语句：Qt  += network
14.1　主机信息查询
14.1.1　QHostInfo和QNetworkInterface类
查询一个主机的MAC地址或IP地址是网络应用程序中经常用到的功能，Qt提供了QHostInfo和QNetworkInterface类可以用于此类信息的查询。
QHostInfo的静态函数localHostName()可获取本机的主机名，静态函数fromName()可以通过主机名获取IP地址，静态函数ookupHost()可以通过一个主机名，以异步方式查找这个主机的IP地址。表14-1是QHostInfo类主要的功能函数（省略了函数中的const关键字）。
表14-1　QHostInfo类的主要函数
类别
函数原型
作用
公共函数
QList<QHostAddress>　addresses()
返回与hostName()主机关联的IP地址列表
HostInfoError　error()
如果主机查找失败，返回失败类型
QString　errorString()
如果主机查找失败，返回错误描述字符串
QString　hostName()
返回通过IP查找的主机的名称
int　lookupId()
返回本次查找的ID
静态函数
void　abortHostLookup(int id)
中断主机查找
QHostInfo　fromName(QString &name)
返回指定的主机名的IP地址
QString　localDomainName()
返回本机DNS域名
QString　localHostName()
返回本机主机名
int　lookupHost(QString &name, QObject receiver, char member)
以异步方式根据主机名查找主机的IP地址，并返回一个表示本次查找的ID，可用于abortHostLookup()









14.2　TCP通信
14.2.1　TCP通信概述
TCP(Transmission Control Protocol)是一种被大多数Internet网络协议（如HTTP 和FTP）用于数据传输的低级网络协议，它是可靠的、面向流、面向连接的传输协议，特别适合用于连续数据传输。
TCP通信必须先建立TCP连接，通信端分为客户端和服务器端（如图14-2所示）。Qt提供QTcpSocket类和QTcpServer类用于建立TCP通信应用程序。服务器端程序必须使用QTcpServer用于端口监听，建立服务器；QTcpSocket用于建立连接后使用套接字（Socket）进行通信。
图14-2　客户端与服务器端TCP通信示意图
QTcpServer是从QObject继承的类，它主要用于服务器端建立网络监听，创建网络Socket连接。QTcpServer类的主要接口函数见表14-4（省略了函数中的const关键字，省略了缺省参数）。
表14-4　QTcpServer类的主要接口函数
类型
函数
功能
公共函数
void　close()
关闭服务器，停止网络监听
bool　listen()
在给定IP地址和端口上开始监听，若成功就返回true
bool　isListening()
返回true表示服务器处于监听状态
QTcpSocket * nextPendingConnection()
返回下一个等待接入的连接
QHostAddress　serverAddress()
如果服务器处于监听状态，返回服务器地址
quint16　serverPort()
如果服务器处于监听状态，返回服务器监听端口
bool　waitForNewConnection()
以阻塞方式等待新的连接
信号
void acceptError( QAbstractSocket::SocketError socketError )
当接受一个新的连接发生错误时发射此信号，参数socketError描述了错误信息
void　newConnection()
当有新的连接时发射此信号







保护函数
void　incomingConnection(qintptr socketDescriptor)
当有一个新的连接可用时，QTcpServer内部调用此函数，创建一个QTcpSocket对象，添加到内部可用新连接列表，然后发射newConnection()信号。用户若从QTcpServer继承定义类，可以重定义此函数，但必须调用addPendingConnection()
void　addPendingConnection(QTcpSocket *socket)
由incomingConnection()调用，将创建的QTcpSocket添加到内部新可用连接列表
服务器端程序首先需要用QTcpServer::listen()开始服务器端监听，可以指定监听的IP地址和端口，一般一个服务程序只监听某个端口的网络连接。
当有新的客户端接入时，QTcpServer内部的incomingConnection()函数会创建一个与客户端连接的QTcpSocket对象，然后发射信号newConnection()。在newConnection()信号的槽函数中，可以用nextPendingConnection()接受客户端的连接，然后使用QTcpSocket与客户端通信。
所以在客户端与服务器建立TCP连接后，具体的数据通信是通过QTcpSocket完成的。QTcpSocket类提供了TCP协议的接口，可以用QTcpSocket类实现标准的网络通信协议如POP3、SMTP和NNTP，也可以设计自定义协议。
QTcpSocket是从QIODevice间接继承的类，所以具有流读写的功能。QTcpSocket和下一节要讲到的QUdpSocket的类继承关系如图14-3所示。
图14-3　QTcpSocket和QUdpSocket的类继承关系
QTcpSocket类除了构造函数和析构函数，其他函数都是从QAbstractSocket继承或重定义的。QAbstractSocket用于TCP通信的主要接口函数见表14-5（省略了函数中的const关键字，省略了缺省参数）。
表14-5　QAbstractSocket类的主要接口函数
类型
函数
功能
公共函数
void　connectToHost(QHostAddress &address, quint16 port,)
以异步方式连接到指定IP地址和端口的TCP服务器，连接成功后会发射connected()信号
void　disconnectFromHost()
断开socket，关闭成功后发射disconnected()信号
bool　waitForConnected()
等待直到建立socket连接
bool　waitForDisconnected()
等待直到断开socket连接
QHostAddress　localAddress()
返回本socket的地址






quint16　localPort()
返回本socket的端口
QHostAddress　peerAddress()
在已连接状态下，返回对方socket的地址
QString　peerName()
返回connectToHost()连接到的对方的主机名
quint16　peerPort()
在已连接状态下，返回对方socket的端口
qint64　readBufferSize()
返回内部读取缓冲区的大小，该大小决定了read()和readAll()函数能读出的数据的大小
void　setReadBufferSize(qint64 size)
设置内部读取缓冲区大小
qint64　bytesAvailable()
返回需要读取的缓冲区的数据的字节数
bool　canReadLine()
如果有行数据要从socket缓冲区读取，就返回true
SocketState　state()
返回socket当前的状态
信号
void　connected()
connectToHost()成功连接到服务器后发射此信号
void　disconnected()
当socket断开连接后发射此信号
void　error(QAbstractSocket::SocketError socketError)
当socket发生错误时发射此信号
void　hostFound()
调用connectToHost()找到主机后发射此信号
void　stateChanged(QAbstractSocket::SocketState socketState)
当socket的状态变化时发射此信号，参数socketState表示了socket当前的状态
void　readyRead()
当缓冲区有新数据需要读取时发射此信号，在此信号的槽函数里读取缓冲区的数据
TCP客户端使用QTcpSocket与TCP服务器建立连接并通信。
客户端的QTcpSocket实例首先通过connectToHost()尝试连接到服务器，需要指定服务器的IP地址和端口。connectToHost()是异步方式连接服务器，不会阻塞程序运行，连接后发射connected()信号。
如果需要使用阻塞方式连接服务器，则使用waitForConnected()函数阻塞程序运行，直到连接成功或失败。例如：socket->connectToHost("192.168.1.100", 1340);
  if (socket->waitForConnected(1000))
     qDebug("Connected!");
与服务器端建立socket连接后，就可以向缓冲区写数据或从接收缓冲区读取数据，实现数据的通信。当缓冲区有新数据进入时，会发射readyRead()信号，一般在此信号的槽函数里读取缓冲区数据。
QTcpSocket是从QIODevice间接继承的，所以可以使用流数据读写功能。一个QTcpSocket实例既可以接收数据也可以发送数据，且接收与发射是异步工作的，有各自的缓冲区。
作为演示TCP通信的实例，创建了一个TCPClient程序和一个TCPServer程序，两个程序运行时界面如图14-4和图14-5所示。




图14-4　TCPServer程序
图14-5　TCPClient程序
TCPServer程序具有如下的功能：
根据指定IP地址（本机地址）和端口打开网络监听，有客户端连接时创建socket连接；
采用基于行的数据通信协议，可以接收客户端发来的消息，也可以向客户端发送消息；
在状态栏显示服务器监听状态和socket的状态。
TCPClient程序程序具有如下的功能：
通过IP地址和端口号连接到服务器；
采用基于行的数据通信协议，与服务器端收发消息；
处理QTcpSocket的StateChange()信号，在状态栏显示socket的状态。
14.2.2　TCP服务器端程序设计
1．主窗口定义与构造函数
TCPServer是一个窗口基于QMainWindow的应用程序，界面由UI设计器设计，MainWindow类的定义如下（忽略了UI设计器自动生成的actions和按钮的槽函数）：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QLabel  *LabListen;//状态栏标签
   QLabel  *LabSocketState;//状态栏标签
   QTcpServer *tcpServer; //TCP服务器
   QTcpSocket *tcpSocket;//TCP通信的Socket
   QString getLocalIP();//获取本机IP地址
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit MainWindow(QWidget *parent = 0);





~MainWindow();
private slots:
//自定义槽函数
   void   onNewConnection();//QTcpServer的newConnection()信号
   void   onSocketStateChange(QAbstractSocket::SocketState socketState);
   void   onClientConnected(); //Client Socket connected
   void   onClientDisconnected();//Client Socket disconnected
   void   onSocketReadyRead();//读取socket传入的数据
private:
   Ui::MainWindow *ui;
};
MainWindow中定义了私有变量tcpServer用于建立TCP服务器，定义了tcpSocket用于与客户端进行socket连接和通信。
定义了几个槽函数，用于与QTcpServer和QTcpSocket的相关信号连接，实现相应的处理。MainWindow构造函数代码如下：MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{
   ui->setupUi(this);
   LabListen=new QLabel("监听状态:");
   LabListen->setMinimumWidth(150);
   ui->statusBar->addWidget(LabListen);

   LabSocketState=new QLabel("Socket状态：");
   LabSocketState->setMinimumWidth(200);
   ui->statusBar->addWidget(LabSocketState);

   QString localIP=getLocalIP();//本机IP
   this->setWindowTitle(this->windowTitle()+"----本机IP："+localIP);
   ui->comboIP->addItem(localIP);
   tcpServer=new QTcpServer(this);
  connect(tcpServer,SIGNAL(newConnection()),this,SLOT(onNewConnection()));
}

QString MainWindow::getLocalIP()
{//获取本机IPv4地址
   QString  hostName=QHostInfo::localHostName();//本地主机名
   QHostInfo   hostInfo=QHostInfo::fromName(hostName);
   QString   localIP="";
   QList<QHostAddress> addList=hostInfo.addresses();

   if (!addList.isEmpty())
   for (int i=0;i<addList.count();i++)
   {
      QHostAddress aHost=addList.at(i);
      if (QAbstractSocket::IPv4Protocol==aHost.protocol())
      {  localIP=aHost.toString();  break; }
   }
   return localIP;
}
MainWindow的构造函数创建状态栏上的标签用于信息显示，调用自定义函数getLocalIP()获取本机IP地址，并显示到标题栏上。创建QTcpServer实例tcpServer，并将其newConnection()信号与onNewConnection()槽函数关联。
2．网络监听与socket连接的建立
作为TCP服务器，QTcpServer类需要调用listen()在本机某个IP地址和端口上开始TCP监听，以等待TCP客户端的接入。单击主窗口上“开始监听”按钮可以开始网络监听，其代码如下：void MainWindow::on_actStart_triggered()






{//开始监听
   QString    IP=ui->comboIP->currentText();//IP地址
   quint16    port=ui->spinPort->value();//端口
   QHostAddress   addr(IP);
   tcpServer->listen(addr,port);//开始监听
   ui->plainTextEdit->appendPlainText("**开始监听...");
   ui->plainTextEdit->appendPlainText("**服务器地址："
                   +tcpServer->serverAddress().toString());
   ui->plainTextEdit->appendPlainText("**服务器端口："
                   +QString::number(tcpServer->serverPort()));
   ui->actStart->setEnabled(false);
   ui->actStop->setEnabled(true);
   LabListen->setText("监听状态：正在监听");
}
程序读取窗口上设置的监听地址和监听端口，然后调用QTcpServer的listen()函数开始监听。TCP服务器在本机上监听，所以IP地址可以是表示本机的“127.0.0.1”，或是本机的实际IP，亦或是常量QHostAddress::LocalHost，即在本机上监听某个端口也可以写成：tcpServer->listen(QHostAddress::LocalHost,port);
tcpServer开始监听后，TCPClient就可以通过IP地址和端口连接到此服务器。当有客户端接入时，tcpServer会发射newConnection()信号，此信号关联的槽函数onNewConnection()的代码如下：void MainWindow::onNewConnection()
{
   tcpSocket = tcpServer->nextPendingConnection(); //获取socket
   //connect(tcpSocket, SIGNAL(connected()), this, SLOT(onClientConnected()));
   onClientConnected();
   connect(tcpSocket, SIGNAL(disconnected()),
              this, SLOT(onClientDisconnected()));
   connect(tcpSocket,SIGNAL(stateChanged(QAbstractSocket::SocketState)),
         this,SLOT(onSocketStateChange(QAbstractSocket::SocketState)));
   onSocketStateChange(tcpSocket->state());
   connect(tcpSocket,SIGNAL(readyRead()), this,SLOT(onSocketReadyRead()));
}
程序首先通过nextPendingConnection()函数获取与接入连接进行通信的QTcpSocket对象实例tcpSocket，然后将tcpSocket的几个信号与相应的槽函数连接起来。QTcpSocket的这几个信号的作用是：
connected()信号，客户端socket连接建立时发射此信号；
disconnected()信号，客户端socket连接断开时发射此信号；
stateChanged()，本程序的socket状态变化时发射此信号；
readyRead()，本程序的socket的读取缓冲区有新数据时发射此信号。
涉及状态变化的几个信号的槽函数代码如下：void MainWindow::onClientConnected()
{//客户端接入时
   ui->plainTextEdit->appendPlainText("**client socket connected");
   ui->plainTextEdit->appendPlainText("**peer address:"+
                       tcpSocket->peerAddress().toString());
   ui->plainTextEdit->appendPlainText("**peer port:"+
                       QString::number(tcpSocket->peerPort()));
}
void MainWindow::onClientDisconnected()
{//客户端断开连接时
   ui->plainTextEdit->appendPlainText("**client socket disconnected");
   tcpSocket->deleteLater();
}







void MainWindow::onSocketStateChange(QAbstractSocket::SocketState socketState)
{//socket状态变化时
   switch(socketState)
   {
   case QAbstractSocket::UnconnectedState:
      LabSocketState->setText("scoket状态：UnconnectedState");    break;
   case QAbstractSocket::HostLookupState:
      LabSocketState->setText("scoket状态：HostLookupState");    break;
   case QAbstractSocket::ConnectingState:
      LabSocketState->setText("scoket状态：ConnectingState");    break;
   case QAbstractSocket::ConnectedState:
      LabSocketState->setText("scoket状态：ConnectedState");     break;
   case QAbstractSocket::BoundState:
      LabSocketState->setText("scoket状态：BoundState");        break;
   case QAbstractSocket::ClosingState:
      LabSocketState->setText("scoket状态：ClosingState");      break;
   case QAbstractSocket::ListeningState:
      LabSocketState->setText("scoket状态：ListeningState");
   }
}
TCP服务器停止监听，只需调用QTcpServer的close()函数即可。窗口上的“停止监听”响应代码如下：void MainWindow::on_actStop_triggered()
{//停止监听
   if (tcpServer->isListening()) //tcpServer正在监听
   {
      tcpServer->close();//停止监听
      ui->actStart->setEnabled(true);
      ui->actStop->setEnabled(false);
      LabListen->setText("监听状态：已停止监听");
   }
}
3．与TCPClient的数据通信
TCP服务器端和客户端之间通过QTcpSocket通信时，需要规定两者之间的通信协议，即传输的数据内容如何解析。QTcpSocket间接继承于QIODevice，所以支持流读写功能。
Socket之间的数据通信协议一般有两种方式，基于行的或基于数据块的。基于行的数据通信协议一般用于纯文本数据的通信，每一行数据以一个换行符结束。canReadLine()函数判断是否有新的一行数据需要读取，再用readLine()函数读取一行数据，例如：while(tcpClient-><em>canReadLine</em>())
   ui->plainTextEdit->appendPlainText("[in] "+tcpClient->readLine());基于块的数据通信协议用于一般的二进制数据的传输，需要自定义具体的格式。
实例程序TCPServer和TCPClient只是进行字符串的信息传输，类似于一个简单的聊天程序，程序采用基于行的数据通信协议。
单击窗口上的“发送消息”，将文本框里的字符串发送给客户端，其实现代码如下：void MainWindow::on_btnSend_clicked()
{//发送一行字符串，以换行符结束
   QString  msg=ui->editMsg->text();
   ui->plainTextEdit->appendPlainText("[out] "+msg);
   ui->editMsg->clear();
   ui->editMsg->setFocus();






QByteArray  str=msg.toUtf8();
   str.append('\n');//添加一个换行符
   tcpSocket->write(str);
}
从上面的代码中可以看到，读取文本框中的字符串到msg后，先将其转换为QByteArray类型字节数组str，然后在str最后面添加一个换行符，用QIODevice的write()函数写入缓冲区，这样就向客户端发送一行文字。
QTcpSocket接收到数据后，会发射readyRead()信号，在onNewConnection()槽函数中已经建立了这个信号与槽函数onSocketReadyRead()的连接。
槽函数onSocketReadyRead()实现缓冲区数据的读取，其代码如下：void MainWindow::onSocketReadyRead()
{//读取缓冲区行文本
   while(tcpSocket->canReadLine())
     ui->plainTextEdit->appendPlainText("[in] "+tcpSocket->readLine());
}
这样，TCPServer就可以与TCPClient之间进行双向通信了，且这个连接将一直存在，直到某一方的QTcpSocket对象调用disconnectFromHost()函数断开socket连接。
14.2.3　TCP客户端程序设计
1．主窗口定义与构造函数
客户端程序TCPClient只需要使用一个QTcpSocket对象，就可以和服务器端程序TCPServer进行通信。
TCPClient也是一个窗口基于QMainWindow的应用程序，其主窗口的定义如下：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QTcpSocket  *tcpClient;  //socket
   QLabel  *LabSocketState;  //状态栏显示标签
   QString getLocalIP();//获取本机IP地址
protected:
   void   closeEvent(QCloseEvent *event);
public:
   explicit MainWindow(QWidget *parent = 0);
   ~MainWindow();
private slots:
//自定义槽函数   
   void   onConnected();
   void   onDisconnected();
   void   onSocketStateChange(QAbstractSocket::SocketState socketState);
   void   onSocketReadyRead();//读取socket传入的数据
private:
   Ui::MainWindow *ui;
};
这里只定义了一个用于socket连接和通信的QTcpSocket变量tcpClient，自定义了几个槽函数，用于与tcpClient的相关信号关联。
下面是MainWindow的构造函数，主要功能是创建tcpClient，并建立信号与槽函数的关联。MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{




   ui->setupUi(this);
   tcpClient=new QTcpSocket(this); //创建socket变量
   LabSocketState=new QLabel("Socket状态：");//状态栏标签
   LabSocketState->setMinimumWidth(250);
   ui->statusBar->addWidget(LabSocketState);
   QString localIP=getLocalIP();//本机IP
   this->setWindowTitle(this->windowTitle()+"----本机IP："+localIP);
   ui->comboServer->addItem(localIP);

   connect(tcpClient,SIGNAL(connected()),this,SLOT(onConnected()));
   connect(tcpClient,SIGNAL(disconnected()),this,SLOT(onDisconnected()));
   connect(tcpClient,SIGNAL(stateChanged(QAbstractSocket::SocketState)),
          this,SLOT(onSocketStateChange(QAbstractSocket::SocketState)));
   connect(tcpClient,SIGNAL(readyRead()),
          this,SLOT(onSocketReadyRead()));
}
2．与服务器端建立socket连接
在窗口上设置服务器IP地址和端口后，调用QTcpSocket的函数connectToHost()连接到服务器，也可以使用disconnectFromHost()函数断开与服务器的连接。
下面是两个按钮的响应代码，以及两个相关槽函数的代码：void MainWindow::on_actConnect_triggered()
{//“连接到服务器”按钮
   QString    addr=ui->comboServer->currentText();
   quint16    port=ui->spinPort->value();
   tcpClient->connectToHost(addr,port);
}
void MainWindow::on_actDisconnect_triggered()
{//“断开连接”按钮
   if (tcpClient->state()==QAbstractSocket::ConnectedState)
      tcpClient->disconnectFromHost();
}
void MainWindow::onConnected()
{ //connected()信号槽函数
   ui->plainTextEdit->appendPlainText("**已连接到服务器");
   ui->plainTextEdit->appendPlainText("**peer address:"+
                         tcpClient->peerAddress().toString());
   ui->plainTextEdit->appendPlainText("**peer port:"+
                         QString::number(tcpClient->peerPort()));
   ui->actConnect->setEnabled(false);
   ui->actDisconnect->setEnabled(true);
}
void MainWindow::onDisconnected()
{//disConnected()信号槽函数
   ui->plainTextEdit->appendPlainText("**已断开与服务器的连接");
   ui->actConnect->setEnabled(true);
   ui->actDisconnect->setEnabled(false);
}
槽函数onSocketStateChange()的功能和代码与TCPServer中的完全一样，这里不再赘述。
3．与TCPServer的数据收发
TCPClient与TCPServer之间采用基于行的数据通信协议。单击“发送消息”按钮将发送一行字符串。在readyRead()信号的槽函数里读取行字符串，其相关代码如下：void MainWindow::on_btnSend_clicked()
{//发送数据
   QString  msg=ui->editMsg->text();
   ui->plainTextEdit->appendPlainText("[out] "+msg);
   ui->editMsg->clear();
   ui->editMsg->setFocus();





QByteArray  str=msg.toUtf8();
   str.append('\n');
   tcpClient->write(str);
}
void MainWindow::onSocketReadyRead()
{//readyRead()信号槽函数
   while(tcpClient->canReadLine())
      ui->plainTextEdit->appendPlainText("[in] "+tcpClient->readLine());
}
实例TCPServer和TCPClient只是简单演示了TCP通信的基本原理，TCPServer只允许一个TCPClient客户端接入。而一般的TCP服务器程序允许多个客户端接入，为了使每个socket连接独立通信互不影响，一般采用多线程，即为一个socket连接创建一个线程。
实例TCPServer和TCPClient之间的数据通信采用基于行的通信协议，只能传输字符串数据。QTcpSocket间接继承于QIODevice，可以使用数据流的方式传输二进制数据流，例如传输图片、任意格式文件等，但是这涉及到服务器端和客户端之间通信协议的定义，本书不具体介绍了。
14.3　QUdpSocket实现UDP通信
14.3.1　UDP通信概述
UDP (User Datagram Protocol，用户数据报协议)是轻量的、不可靠的、面向数据报（datagram）、无连接的协议，它可以用于对可靠性要求不高的场合。与TCP通信不同，两个程序之间进行UDP通信无需预先建立持久的socket连接，UDP每次发送数据报都需要指定目标地址和端口（如图14-6所示）。
QUdpSocket类用于实现UDP通信，它从QAbstractSocket类继承，因而与QTcpSocket共享大部分的接口函数。主要区别是QUdpSocket以数据报传输数据，而不是以连续的数据流。发送数据报使用函数QUdpSocket::writeDatagram()，数据报的长度一般少于512字节，每个数据报包含发送者和接收者的IP地址和端口等信息。
要进行UDP数据接收，要用QUdpSocket::bind()函数先绑定一个端口，用于接收传入的数据报。当有数据报传入时会发射readyRead()信号，使用readDatagram()函数来读取接收到的数据报。
UDP消息传送有单播、广播、组播三种模式，其示意图如图14-7所示。
图14-6　UDP收发器之间通信示意图
图14-7　UDP客户端之间通信的三种模式
单播（unicast）模式：一个UDP客户端发出的数据报只发送到另一个指定地址和端口的UDP客户端，是一对一的数据传输。
广播（broadcast）模式：一个UDP客户端发出的数据报，在同一网络范围内其他所有的UDP客户端都可以收到。QUdpSocket支持IPv4广播。广播经常用于实现网络发现的协议。要获取广播数据只需在数据报中指定接收端地址为QHostAddress::Broadcast，一般的广播地址是255.255.255.255。




组播（multicast）模式：也称为多播。UDP客户端加入到另一个组播IP地址指定的多播组，成员向组播地址发送的数据报组内成员都可以接收到，类似于QQ群的功能。QUdpSocket::joinMulticastGroup()函数实现加入多播组的功能，加入多播组后，UDP数据
的收发与正常的UDP数据收发方法一样。
使用广播和多播模式，UDP可以实现一些比较灵活的通信功能，而TCP通信只有单播模式，没有广播和多播模式。所以，UDP通信虽然不能保证数据传输的准确性，但是具有灵活性，一般的即时通信软件都是基于UDP通信的。
QUdpSocket类从QAbstractSocket继承而来，但是又定义了较多新的功能函数用于实现UDP特有的一些功能，如数据报读写和多播通信功能。QUdpSocket没有定义新的信号。QUdpSocket的主要功能函数见表14-6（包括从QAbstractSocket继承的函数，省略了函数中的const关键字，省略了缺省参数）。
表14-6　QUdpSocket类的主要接口函数
函数
功能
bool　bind(quint16 port = 0)
为UDP通信绑定一个端口
qint64　writeDatagram(QByteArray &datagram, QHostAddress &host, quint16 port)
向目标地址和端口的UDP客户端发送数据报，返回成功发送的字节数
bool　hasPendingDatagrams()
当至少有一个数据报需要读取时，返回true
qint64　pendingDatagramSize()
返回第一个待读取的数据报的大小
qint64　readDatagram(char *data, qint64 maxSize)
读取一个数据报，返回成功读取的数据报的字节数
bool　joinMulticastGroup(QHostAddress &groupAddress)
加入一个多播组
bool　leaveMulticastGroup(QHostAddress &groupAddress)
离开一个多播组
在单播、广播和多播模式下，UDP程序都是对等的，不像TCP通信那样分为客户端和服务器端。多播和广播的实现方式基本相同，只是数据报的目标IP地址设置不同，多播模式需要加入多播组，实现方式有较大差异。
为分别演示这三种UDP通信模式，本节设计了两个实例。Samp14_3实例演示UDP单播和广播通信，Samp14_4实例演示UDP组播通信。
14.3.2　UDP单播和广播
1．UDP通信实例程序功能
实例程序samp14_3实现UDP单播和广播，其主窗口是继承自QMainWindow的类，界面用UI设计器设计。程序可以进行UDP数据报的发送和接收，samp14_3的两个运行实例之间可以进行UDP通信，这两个实例可以运行在同一台计算机上，也可以运行在不同的计算机上。图14-8和图14-9是samp14_3两个实例在一台计算机上运行时通信的界面。
在同一台计算机上运行时，两个运行实例需要绑定不同的端口，例如实例A绑定端口1200，实例B绑定端口3355。实例A向实例B发送数据报时，需要指定实例B所在主机的IP地址、绑定端口作为目标地址和目标端口，这样实例B才能接收到数据报。
如果两个实例在不同计算机上运行，则可以使用相同的端口，因为IP地址不同了，不会导致绑



定时发生冲突。一般的UDP通信程序都是在不同的计算机上运行的，约定一个固定的端口作为通信端口。
2．主窗口类定义和构造函数
主窗口是基于QMainWindow的类MainWindow，界面采用UI设计器设计。MainWindow类的定义如下（省略了UI设计器为actions和按钮生成的槽函数声明）：
图14-8　samp14_3运行实例A（绑定端口1200）
图14-9　samp14_3运行实例B（绑定端口3355）class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QLabel  *LabSocketState; //socket状态显示标签
   QUdpSocket  *udpSocket;
   QString getLocalIP();//获取本机IP地址
public:
   explicit MainWindow(QWidget *parent = 0);
   ~MainWindow();
private slots:
//自定义槽函数
   void   onSocketStateChange(QAbstractSocket::SocketState socketState);
   void   onSocketReadyRead();//读取socket传入的数据
private:
   Ui::MainWindow *ui;
};




QUdpSocket类型的私有变量udpSocket是用于UDP通信的socket。
定义了两个自定义槽函数，onSocketStateChange()与udpSocket的stateChange()信号关联，用于显示udpSocket当前的状态；onSocketReadyRead()信号与udpSocket的readyRead()信号关联，用于读取缓冲区的数据报。
MainWindow的构造函数主要完成udpSocket的创建、信号与槽函数的关联，代码如下：MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{
   ui->setupUi(this);
   LabSocketState=new QLabel("Socket状态：");
   LabSocketState->setMinimumWidth(200);
   ui->statusBar->addWidget(LabSocketState);
   QString localIP=getLocalIP();//本机IP
   this->setWindowTitle(this->windowTitle()+"----本机IP："+localIP);
   ui->comboTargetIP->addItem(localIP);

   udpSocket=new QUdpSocket(this);
   connect(udpSocket,SIGNAL(stateChanged(QAbstractSocket::SocketState)),
         this,SLOT(onSocketStateChange(QAbstractSocket::SocketState)));
   onSocketStateChange(udpSocket->state());
   connect(udpSocket,SIGNAL(readyRead()),this,SLOT(onSocketReadyRead()));
}
槽函数onSocketStateChange()的功能与14.2节TCP通信程序里的完全一样，不再显示其具体代码。
3．UDP通信的实现
要实现UDP数据的接收，必须先用QUdpSocket::bind()函数绑定一个端口，用于监听传入的数据报，解除绑定则使用abort()函数。程序主窗口上的“绑定端口”和“解除绑定”按钮的响应代码如下：void MainWindow::on_actStart_triggered()
{//绑定端口
   quint16  port=ui->spinBindPort->value(); //本机UDP端口
   if (udpSocket->bind(port))//绑定端口成功
   {
      ui->plainTextEdit->appendPlainText("**已成功绑定");
      ui->plainTextEdit->appendPlainText("**绑定端口："
            +QString::number(udpSocket->localPort()));
      ui->actStart->setEnabled(false);
      ui->actStop->setEnabled(true);
   }
   else
      ui->plainTextEdit->appendPlainText("**绑定失败");
}

void MainWindow::on_actStop_triggered()
{//解除绑定
   udpSocket->abort(); //解除绑定
   ui->actStart->setEnabled(true);
   ui->actStop->setEnabled(false);
   ui->plainTextEdit->appendPlainText("**已解除绑定");
}
绑定端口后，socket的状态变为已绑定状态“BoundState”，解除绑定后状态变为未连接状态“UnconnectedState”。
发送点对点消息和广播消息都使用QUdpSocket:: writeDatagram()函数，窗口上“发送消息”和“广播消息”两个按钮的代码如下：





void MainWindow::on_btnSend_clicked()
{//发送消息 按钮
   QString    targetIP=ui->comboTargetIP->currentText(); //目标IP
   QHostAddress   targetAddr(targetIP);
   quint16    targetPort=ui->spinTargetPort->value();//目标port
   QString  msg=ui->editMsg->text();//发送的消息内容
   QByteArray  str=msg.toUtf8();
   udpSocket->writeDatagram(str,targetAddr,targetPort); //发出数据报
   ui->plainTextEdit->appendPlainText("[out] "+msg);
   ui->editMsg->clear();
   ui->editMsg->setFocus();
}

void MainWindow::on_btnBroadcast_clicked()
{ //广播消息 按钮
   quint16   targetPort=ui->spinTargetPort->value(); //目标端口
   QString  msg=ui->editMsg->text();
   QByteArray  str=msg.toUtf8();
   udpSocket->writeDatagram(str,QHostAddress::Broadcast,targetPort);
   ui->plainTextEdit->appendPlainText("[broadcast] "+msg);
   ui->editMsg->clear();
   ui->editMsg->setFocus();
}
使用writeDatagram()函数向一个目标用户发送消息时，需要指定目标地址和端口。
在广播消息时，只需将目标地址更换为一个特殊地址，即广播地址QHostAddress::Broadcast，一般是255.255.255.255。
QUdpSocket发送的数据报是QByteArray类型的字节数组，数据报的长度一般不超过512字节。数据报的内容可以是文本字符串，也可以自定义格式的二进制数据，文本字符串无需以换行符结束。
QUdpSocket接收到数据报后发射readyRead()信号，在关联的槽函数onSocketReadyRead()里读取缓冲区的数据报，代码如下：void MainWindow::onSocketReadyRead()
{//读取收到的数据报
   while(udpSocket->hasPendingDatagrams())
   {
      QByteArray   datagram;
      datagram.resize(udpSocket->pendingDatagramSize());
      QHostAddress   peerAddr;
      quint16 peerPort;
      udpSocket->readDatagram(datagram.data(), datagram.size(), &peerAddr,&peerPort);
      QString str=datagram.data();
      QString peer="[From "+peerAddr.toString() +":" +QString::number(peerPort)+"] ";
      ui->plainTextEdit->appendPlainText(peer+str);
   }
}
hasPendingDatagrams()表示是否有待读取的传入数据报。
pendingDatagramSize()返回待读取数据报的字节数。
readDatagram()函数用于读取数据报的内容，其函数原型为：qint64 QUdpSocket::readDatagram(char *data, qint64 maxSize, QHostAddress *address = Q_NULLPTR, quint16 *port = Q_NULLPTR)
输入参数data和maxSize是必须的，表示最多读取maxSize字节的数据到变量data里。address和port变量是可选的，用于获取数据报来源的地址和端口。上面的代码中使用了完整的




参数形式，从而可以获得数据报来源的地址peerAddr和端口peerPort。如果无需获取来源地址和端口，可以采用简略形式，即：udpSocket->readDatagram(datagram.data(),datagram.size());
读取的数据报内容是QByteArray字节数组，因为本程序只是传输字符串，所以简单地将其转换为字符串即可。如果传输的是自定义格式的字符串或二进制数据，需要对接收到的数据进行解析。
14.3.3　UDP组播
1．UDP组播的特性
图14-7的示意图简单表示了组播的原理。UDP组播是主机之间“一对一组”的通信模式，当多个客户端加入由一个组播地址定义的多播组之后，客户端向组播地址和端口发送的UDP数据报，组内成员都可以接收到，其功能类似于QQ群。
组播报文的目的地址使用D类IP地址，D类地址不能出现在IP报文的源IP地址字段。用同一个IP多播地址接收多播数据报的所有主机构成了一个组，称为多播组（或组播组）。所有的信息接收者都加入到一个组内，并且一旦加入之后，流向组地址的数据报立即开始向接收者传输，组中的所有成员都能接收到数据报。组中的成员是动态的，主机可以在任何时间加入和离开组。
所以，采用UDP组播必须使用一个组播地址。组播地址是D类IP地址，有特定的地址段。多播组可以是永久的也可以是临时的。多播组地址中，有一部分由官方分配，称为永久多播组。永久多播组保持不变的是它的IP地址，组中的成员构成可以发生变化。永久多播组中成员的数量可以是任意的，甚至可以为零。那些没有保留下来的供永久多播组使用的IP组播地址，可以被临时多播组利用。关于组播IP地址，有如下的一些约定：
224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其他地址供路由协议使用；
224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；
224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；
239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。
所以，若是在家庭或办公室局域网内测试UDP组播功能，可以使用的组播地址范围是239.0.0.0～239.255.255.255。
QUdpSocket支持UDP组播，joinMulticastGroup()函数使主机加入一个多播组，leaveMulticast Group()函数使主机离开一个多播组，UDP组播的特点是使用组播地址，其他的端口绑定、数据报收发等功能的实现与单播UDP完全相同。
2．UDP组播实例程序的功能
设计一个UDP组播实例程序Samp14_4，在两台计算机上分别运行，进行组播通信。图14-10是运行于主机192.168.1.104上的程序，图14-11是运行于主机192.168.1.106上的程序。两个主机上的程序都加入地址为239.255.43.21的多播组，绑定端口35320进行通信。
从图14-10和图14-11可以看到，两个Samp14_4程序都可以发送和接收组播数据报，且在自己主机上发出的数据报，自己也可以接收到。


图14-10　主机A上运行的Samp14_4程序（主机地址192.168.1.104）
图14-11　主机B上运行的Samp14_4程序（主机地址192.168.1.106）
3．组播功能的程序实现
程序的主窗口是基于QMainWindow的类MainWindow，界面由UI设计器设计，其类定义如下（忽略UI设计器生成的槽函数）：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QLabel  *LabSocketState;
   QUdpSocket  *udpSocket;
   QHostAddress   groupAddress; //组播地址
   QString getLocalIP(); //获取本机IP地址
public:
   explicit MainWindow(QWidget *parent = 0);
   ~MainWindow();
private slots:
//自定义槽函数
   void   onSocketStateChange(QAbstractSocket::SocketState socketState);
   void   onSocketReadyRead();//读取socket传入的数据
private:
   Ui::MainWindow *ui;
};
其中定义了一个QHostAddress类型变量groupAddress，用于记录组播地址。下面是MainWindow的构造函数的代码：MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{
   ui->setupUi(this);
   LabSocketState=new QLabel("Socket状态：");
   LabSocketState->setMinimumWidth(200);
   ui->statusBar->addWidget(LabSocketState);
   QString localIP=getLocalIP();//本地主机名





this->setWindowTitle(this->windowTitle()+"----本机IP："+localIP);
   udpSocket=new QUdpSocket(this);
   udpSocket->setSocketOption(QAbstractSocket::MulticastTtlOption,1);

   connect(udpSocket,SIGNAL(stateChanged(QAbstractSocket::SocketState)),
         this,SLOT(onSocketStateChange(QAbstractSocket::SocketState)));
   onSocketStateChange(udpSocket->state());
   connect(udpSocket,SIGNAL(readyRead()), this,SLOT(onSocketReadyRead()));
}
其中使用了QUdpSocket::setSocketOption()函数，对socket进行参数设置。udpSocket->setSocketOption(QAbstractSocket::MulticastTtlOption,1);
将socket的QAbstractSocket::MulticastTtlOption值设置为1。MulticastTtlOption是UDP组播的数据报的生存期，数据报每跨1个路由会减1。缺省值为1，表示多播数据报只能在同一路由下的局域网内传播。
要进行UDP组播通信，UDP客户端必须先加入UDP多播组，也可以随时退出多播组。主窗口上的“加入组播”和“退出组播”按钮的代码如下：void MainWindow::on_actStart_triggered()
{//加入组播
   QString   IP=ui->comboIP->currentText();
   groupAddress=QHostAddress(IP);//多播组地址
   quint16   groupPort=ui->spinPort->value();//端口
   if (udpSocket->bind(QHostAddress::AnyIPv4, groupPort, QUdpSocket::ShareAddress))
   {
     udpSocket->joinMulticastGroup(groupAddress); //加入多播组
     ui->plainTextEdit->appendPlainText("**加入组播成功");
     ui->plainTextEdit->appendPlainText("**组播地址IP："+IP);
     ui->plainTextEdit->appendPlainText("**绑定端口："+ QString::number(groupPort));
     ui->actStart->setEnabled(false);
     ui->actStop->setEnabled(true);
     ui->comboIP->setEnabled(false);
   }
   else
     ui->plainTextEdit->appendPlainText("**绑定端口失败");
}
void MainWindow::on_actStop_triggered()
{//退出组播
   udpSocket->leaveMulticastGroup(groupAddress);//退出组播
   udpSocket->abort(); //解除绑定
   ui->actStart->setEnabled(true);
   ui->actStop->setEnabled(false);
   ui->comboIP->setEnabled(true);
   ui->plainTextEdit->appendPlainText("**已退出组播,解除端口绑定");
}
加入组播之前，必须先绑定端口，绑定端口的语句是：udpSocket->bind(QHostAddress::AnyIPv4, groupPort, QUdpSocket::ShareAddress)
这里指定地址为QHostAddress::AnyIPv4，端口为多播组统一的一个端口。
使用QUdpSocket:: joinMulticastGroup()函数加入多播组，即：udpSocket->joinMulticastGroup(groupAddress);
多播组地址groupAddress由界面上的组合框里输入。注意，局域网内的组播地址的范围是239.0.0.0～239.255.255.255，绝对不能使用本机地址作为组播地址。
退出多播组，使用QUdpSocket::leaveMulticastGroup()函数，即：




udpSocket->leaveMulticastGroup(groupAddress);
加入多播组后，发送组播数据报也是使用writeDatagram()函数，只是目标地址使用的是组播地址，在readyRead()信号的槽函数里用readDatagram()读取数据报。下面是发送和读取数据报的代码：void MainWindow::on_btnMulticast_clicked()
{//发送组播消息
   quint16   groupPort=ui->spinPort->value();
   QString   msg=ui->editMsg->text();
   QByteArray  datagram=msg.toUtf8();
   udpSocket->writeDatagram(datagram,groupAddress,groupPort);
   ui->plainTextEdit->appendPlainText("[multicst] "+msg);
   ui->editMsg->clear();
   ui->editMsg->setFocus();
}
void MainWindow::onSocketReadyRead()
{//读取数据报
   while(udpSocket->hasPendingDatagrams())
   {
      QByteArray   datagram;
      datagram.resize(udpSocket->pendingDatagramSize());
      QHostAddress   peerAddr;
      quint16 peerPort;
      udpSocket->readDatagram(datagram.data(), datagram.size(), &peerAddr, &peerPort);
      QString str=datagram.data();
      QString peer="[From "+peerAddr.toString()+":" +QString::number(peerPort)+"] ";
      ui->plainTextEdit->appendPlainText(peer+str);
   }
}
14.4　基于HTTP协议的网络应用程序
14.4.1　实现高层网络操作的类
Qt网络模块提供一些类实现OSI 7层网络模型中高层的网络协议，如HTTP、FTP、SNMP等，这些类主要是QNetworkRequest、QNetworkReply和QNetworkAccessManager。
QNetworkRequest类通过一个URL地址发起网络协议请求，也保存网络请求的信息，目前支持HTTP、FTP和局部文件URLs的下载或上传。
QNetworkAccessManager类用于协调网络操作。在QNetworkRequest发起一个网络请求后，QNetworkAccessManager类负责发送网络请求，创建网络响应。
QNetworkReply类表示网络请求的响应。由QNetworkAccessManager在发送一个网络请求后创建一个网络响应。QNetworkReply提供的信号finished()、readyRead()和downloadProgress()可以监测网络响应的执行情况，执行相应操作。
QNetworkReply是QIODevice的子类，所以QNetworkReply支持流读写功能，也支持异步或同步工作模式。
14.4.2　基于HTTP协议的网络文件下载
基于上述三个类，设计一个基于HTTP协议的网络文件下载程序，实例程序名称samp14_5，图14-12是程序运行下载文件时的界面。



图14-12　基于HTTP的文件下载
在URL地址编辑框里输入一个网络文件URL地址，设置下载文件保存路径后，单击“下载”按钮就可以开始下载文件到设置的目录下。进度条可以显示文件下载进度，下载完成后还可以用缺省的软件打开下载的文件。URL里的HTTP地址可以是任何类型的文件，如html、pdf、doc、exe等。
实例samp14_5主界面是基于QMainWindow的窗口类MainWindow，使用UI设计器设计界面，删除了主窗口上的工具栏和状态栏。MainWindow类的定义如下：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QNetworkAccessManager networkManager;//网络管理
   QNetworkReply *reply;   //网络响应
   QFile  *downloadedFile;//下载保存的临时文件
public:
   explicit MainWindow(QWidget *parent = 0);
   ~MainWindow();
private slots:
//自定义槽函数
   void on_finished();
   void on_readyRead();
   void on_downloadProgress(qint64 bytesRead, qint64 totalBytes);
private:
   Ui::MainWindow *ui;
};
要下载文件，先在窗口上的URL编辑框里输入下载地址（可以使用Ctrl+V组合键粘贴URL地址），再设置下载文件保存的目录。单击“缺省路径”按钮会在程序的当前目录下创建一个临时文件夹，代码如下：void MainWindow::on_btnDefaultPath_clicked()
{//缺省路径  按钮
   QString  curPath=QDir::currentPath();
   QDir   dir(curPath);
   QString  sub="temp";
   dir.mkdir(sub);
   ui->editPath->setText(curPath+"/"+sub+"/");
}
输入这些设置后，单击“下载”按钮开始下载过程，“下载”按钮的响应代码如下：void MainWindow::on_btnDownload_clicked()
{//开始下载
   QString urlSpec = ui->editURL->text().trimmed();
   if (urlSpec.isEmpty())
   {   QMessageBox::information(this, "错误", "请指定需要下载的URL");
      return;
   }

   QUrl newUrl = QUrl::fromUserInput(urlSpec);
   if (!newUrl.isValid())
   {   QMessageBox::information(this, "错误",




QString("无效URL: %1 \n 错误信息: %2").arg(urlSpec, newUrl.errorString()));
      return;
   }

   QString tempDir =ui->editPath->text().trimmed();
   if (tempDir.isEmpty())
   {  QMessageBox::information(this, "错误", "请指定保存下载文件的目录");
      return;
   }
   QString fullFileName =tempDir+newUrl.fileName(); 
   if (QFile::exists(fullFileName))
      QFile::remove(fullFileName);

   downloadedFile =new QFile(fullFileName);
   if (!downloadedFile->open(QIODevice::WriteOnly))
   {   QMessageBox::information(this, "错误","临时文件打开错误");
      return;
   }
   ui->btnDownload->setEnabled(false);
   reply = networkManager.get(QNetworkRequest(newUrl));
   connect(reply, SIGNAL(finished()), this, SLOT(on_finished()));
   connect(reply, SIGNAL(readyRead()), this, SLOT(on_readyRead()));
   connect(reply, SIGNAL(downloadProgress(qint64,qint64)),
         this, SLOT(on_downloadProgress(qint64,qint64)));
}
代码在读取URL地址后，将其转换为一个QUrl类变量newUrl，并检查其有效性，再检查临时文件目录，创建临时文件downloadedFile。
这些准备好之后，用QNetworkAccessManager发布网络请求，请求下载URL地址表示的文件，并创建网络响应，关键代码为：reply = networkManager.get(QNetworkRequest(newUrl));
reply为网络响应，将其3个信号与相关的自定义槽函数相关联，实现相应的操作。这3个槽函数的代码如下：void MainWindow::on_readyRead()
{//读取下载的数据
   downloadedFile->write(reply->readAll());
}
void MainWindow::on_downloadProgress(qint64 bytesRead, qint64 totalBytes)
{//下载进程
   ui->progressBar->setMaximum(totalBytes);
   ui->progressBar->setValue(bytesRead);
}
void MainWindow::on_finished()
{//网络响应结束
   QFileInfo fileInfo;
   fileInfo.setFile(downloadedFile->fileName());
   downloadedFile->close();
   delete downloadedFile;
   downloadedFile = Q_NULLPTR;
   reply->deleteLater(); 
   reply = Q_NULLPTR;
   if (ui->checkOpen->isChecked())
      QDesktopServices::openUrl(QUrl::fromLocalFile( 
                     fileInfo.absoluteFilePath()));
   ui->btnDownload->setEnabled(true);
}
在缓冲区有新下载的数据等待读取时，会发射readyRead()信号，槽函数on_readyRead()读取下载缓冲区的数据到临时文件。




downloadProgress()是表示网络操作进度的信号，传递bytesRead和totalBytes两个参数，表示已读取字节数和总的字节数；on_downloadProgress()槽函数将这两个参数用于进度条的显示，可以显示下载进度。
finished()信号在下载结束后发射，槽函数on_finished()的功能是关闭临时文件，删除文件变量和网络响应变量。然后用QDesktopServices::openUrl()函数调用缺省的应用软件打开下载的文件，例如，如果下载的是一个PDF文件，会自动用相关联的PDF阅读器软件打开此文件。










第15章　多媒体
多媒体功能指的主要是计算机的音频和视频的输入、输出、显示和播放等功能，Qt的多媒体模块为音频和视频播放、录音、摄像头拍照和录像等提供支持，甚至还提供数字收音机的支持。本章将介绍Qt多媒体模块的功能和使用。
15.1　Qt多媒体模块功能概述
Qt多媒体模块提供了很多类，可以实现如下的一些功能：
访问原始音频设备进行输入或输出；
低延迟播放音效文件，如WAV文件；
使用播放列表播放压缩的音频和视频文件，如mp3、wmv等；
录制声音并且压制文件；
使用摄像头进行预览、拍照和视频录制；
音频文件解码到内存进行处理；
录制音频或视频时，访问其视频帧或音频缓冲区；
数字广播调谐和收听。
要在C++项目中使用Qt多媒体模块，需要在项目配置文件中添加如下一行语句：Qt += multimedia
如果在项目中使用视频播放功能，还需要加入下面的一行，以使用QVideoWidget或QGraphicsVideoItem进行视频播放。Qt += multimediawidgets
Qt多媒体模块包括多个类，表15-1是一些典型的多媒体应用所需要用到的主要的类。
表15-1　各类多媒体功能用到的类
应用功能
用到的类
播放压缩音频（MP3、AAC等）
QMediaPlayer，QMediaPlaylist
播放音效文件（WAV文件）
QSoundEffect，QSound
播放低延迟的音频
QAudioOutput
访问原始音频输入数据
QAudioInput
录制编码的音频数据
QAudioRecorder
发现音频设备
QAudioDeviceInfo
视频播放
QMediaPlayer，QVideoWidget，QGraphicsVideoItem
视频处理
QMediaPlayer，QVideoFrame，QAbstractVideoSurface
摄像头取景框
QCamera，QVideoWidget，QGraphicsVideoItem
取景框预览处理
QCamera，QAbstractVideoSurface，QVideoFrame
摄像头拍照
QCamera，QCameraImageCapture







摄像头录像
QCamera，QMediaRecorder
收听数字广播
QRadioTuner，QRadioData
利用Qt多媒体模块提供的各种类，可以实现一般的音频、视频的输入和输出。这在一些实际应用中是需要的，如语音识别需要录制音频并对音频数据进行处理，车牌自动识别需要先拍照然后进行图像处理。
本章将介绍音频的播放和录制、视频播放、摄像头拍照与录像等功能的实现。数字广播需要具有数字调频功能的硬件设备，一般用户没有这样的硬件设备，本书就不予介绍了。
15.2　音频播放
15.2.1　使用QMediaPlayer播放音乐文件
1．音频播放器实例程序
QMediaPlayer可以播放经过压缩的音频或视频文件，如mp3、mp4、wmv等文件，QMediaPlayer可以播放单个文件，也可以和QMediaPlaylist类结合，对一个播放列表进行播放。所以使用QMediaPlayer和QMediaPlaylist可以轻松地设计一个自己的音乐或视频播放器。
QMediaPlayer的主要公共函数和槽函数见表15-2（省略了函数中的const关键字和缺省参数）。
表15-2　QMediaPlayer的主要函数
函数原型
功能描述
qint64　duration()
当前文件播放时间总长，单位ms
void　setPosition(qint64 position)
设置当前文件播放位置，单位ms
void　setMuted(bool muted)
设置是否静音
bool　isMuted()
返回是否静音的状态，true表示静音
void　setPlaylist(QMediaPlaylist *playlist)
设置播放列表
QMediaPlaylist*　playlist()
返回设置的播放列表
State　state()
返回播放器当前的状态
void　setVolume(int volume)
设置播放音量，0至100之间
void　setPlaybackRate(qreal rate)
设置播放速度，缺省为1，表示正常速度
void　setMedia(QMediaContent &media)
设置播放媒体文件
QMediaContent　currentMedia()
返回当前播放的媒体文件
void　play()
开始播放






void　pause()
暂停播放
void　stop()
停止播放
使用QMediaPlayer播放媒体文件时，有几个有用的信号可以反映播放状态或文件信息。
stateChanged(QMediaPlayer::State state)信号在调用play()、pause()和stop()函数时发射，反映播放器当前的状态。枚举类型QMediaPlayer::State有3种取值，表示播放器的状态：
QMediaPlayer::StoppedState，停止状态；
QMediaPlayer::PlayingState，正在播放；
QMediaPlayer::PausedState，暂停播放状态。
durationChanged(qint64 duration)信号在文件的时间长度变化时发射，一般在切换播放文件时发射。
positionChanged(qint64 position)当前文件播放位置变化时发射，可以反映文件播放进度。
QMediaPlayer可以通过setMedia()函数设置播放单个文件，也可以通过setPlaylist()函数设置一个QMediaPlaylist类实例表示的播放列表，对列表文件进行播放，并且自动播放下一个文件，或循环播放等。QMediaPlayer播放的文件可以是本地文件，也可以是网络上的文件。
QMediaPlaylist记录播放媒体文件信息，可以添加、移除文件，也可以设置循环播放形式，在列表文件中自动切换文件。在当前播放文件切换时会发射currentIndexChanged()信号和currentMediaChange()信号。
使用QMediaPlayer和QMediaPlaylist的这些功能，可以实现一个完整功能的音乐播放器。图15-1是使用QMediaPlayer和QMediaPlaylist实现的一个音乐播放器实例程序samp15_1，它实现了一个音乐播放器的基本功能。
图15-1　使用QMediaPlayer和QmediaPlaylist实现的音乐播放器
2．界面设计与主窗口类的定义
实例samp15_1是一个界面基于QMainWindow的应用程序，主窗口上删除了菜单栏、工具栏和状态栏，界面采用UI设计器设计，中间是一个QListWidget组件显示播放列表的文件名。其他的界面组件和布局设计不再赘述。
下面是主窗口类的定义（省略了UI设计器自动生成的界面组件的槽函数）：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:








QMediaPlayer   *player;//播放器
   QMediaPlaylist  *playlist;//播放列表
   QString  durationTime;//总长度
   QString  positionTime;//当前播放到的位置
public:
   explicit MainWindow(QWidget *parent = 0);
private slots:
//自定义槽函数
   void onStateChanged(QMediaPlayer::State state);
   void onPlaylistChanged(int position);
   void onDurationChanged(qint64 duration);
   void onPositionChanged(qint64 position);
private:
   Ui::MainWindow *ui;
};
主要是定义了4个私有变量，4个自定义槽函数。
onStateChanged()在播放器播放状态变化时发射，以更新界面上的“播放”“暂停”“停止”按钮的使能状态。
onPlaylistChanged()在播放列表的当前文件变化时发射，用以更新界面上显示当前媒体文件名。
onDurationChanged()在文件时长变化时发射，用于更新界面上文件时间长度的显示。
onPositionChanged()在当前文件播放位置变化时发射，用于更新界面上的播放进度显示。
下面是MainWindow构造函数的代码，主要功能是创建player和playlist，然后进行信号与自定义槽函数的关联。MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{
   ui->setupUi(this);
   player = new QMediaPlayer(this);//播放器
   playlist = new QMediaPlaylist(this);//播放列表
   playlist->setPlaybackMode(QMediaPlaylist::Loop); //循环模式
   player->setPlaylist(playlist);

   connect(player,SIGNAL(stateChanged(QMediaPlayer::State)),
         this, SLOT(onStateChanged(QMediaPlayer::State)));
   connect(player,SIGNAL(positionChanged(qint64)),
         this, SLOT(onPositionChanged(qint64)));
   connect(player,SIGNAL(durationChanged(qint64)),
         this, SLOT(onDurationChanged(qint64)));
   connect(playlist,SIGNAL(currentIndexChanged(int)),
         this, SLOT(onPlaylistChanged(int)));
}
下面是4个自定义槽函数的代码：void MainWindow::onStateChanged(QMediaPlayer::State state)
{//播放器状态变化，更新按钮状态
   ui->btnPlay->setEnabled(!(state==QMediaPlayer::PlayingState));
   ui->btnPause->setEnabled(state==QMediaPlayer::PlayingState);
   ui->btnStop->setEnabled(state==QMediaPlayer::PlayingState);
}
void MainWindow::onPlaylistChanged(int position)
{//播放列表变化,更新当前播放文件名显示
   ui->listWidget->setCurrentRow(position);
   QListWidgetItem  *item=ui->listWidget->currentItem();
   if (item)
      ui->LabCurMedia->setText(item->text());
}
void MainWindow::onDurationChanged(qint64 duration)
{//文件时长变化，更新进度显示





ui->sliderPosition->setMaximum(duration);
    int   secs=duration/1000;//秒
    int   mins=secs/60; //分钟
    secs=secs % 60;//余数秒
    durationTime=QString::asprintf("%d:%d",mins,secs);
    ui->LabRatio->setText(positionTime+"/"+durationTime);
}
void MainWindow::onPositionChanged(qint64 position)
{//当前文件播放位置变化，更新进度显示
   if (ui->sliderPosition->isSliderDown())//正处于手动调整状态，不处理
      return;
   ui->sliderPosition->setSliderPosition(position);
   int   secs=position/1000;//秒
   int   mins=secs/60; //分钟
   secs=secs % 60;//余数秒
   positionTime=QString::asprintf("%d:%d",mins,secs);
   ui->LabRatio->setText(positionTime+"/"+durationTime);
}
3．播放列表控制
窗口中间以一个QListWidget组件显示播放的文件列表，界面上显示的文件列表与playlist存储的文件列表保持同步。
窗口上方的“添加”“移除”“清空”3个按钮的代码如下：void MainWindow::on_btnAdd_clicked()
{//添加文件
    QString curPath=QDir::homePath();//获取用户目录
    QString dlgTitle="选择音频文件"; 
    QString filter="音频文件(*.mp3 *.wav *.wma);;mp3文件(*.mp3);;wav文件(*.wav);;wma文件(*.wma);;所有文件(*.*)"; 
    QStringList fileList=QFileDialog::getOpenFileNames(this, dlgTitle, curPath, filter);
    if (fileList.count()<1)
       return;
    for (int i=0; i<fileList.count();i++)
    {
      QString aFile=fileList.at(i);
      playlist->addMedia(QUrl::fromLocalFile(aFile));//添加文件
      QFileInfo   fileInfo(aFile);
      ui->listWidget->addItem(fileInfo.fileName());//添加到界面文件列表
    }
    if (player->state()!=QMediaPlayer::PlayingState)
       playlist->setCurrentIndex(0);
    player->play();
}
void MainWindow::on_btnRemove_clicked()
{//移除一个文件
   int pos=ui->listWidget->currentRow();
   QListWidgetItem *item=ui->listWidget->takeItem(pos);
   delete item;//从listWidget里删除
   playlist->removeMedia(pos); //从播放列表里删除
}
void MainWindow::on_btnClear_clicked()
{//清空列表
   playlist->clear();
   ui->listWidget->clear();
   player->stop();
}
用到的QMediaPlaylist的主要函数有：
addMedia()函数添加一个文件；
removeMedia()移除一个文件；
setCurrentIndex()设置当前播放文件序号；






clear()清空播放列表。
在播放列表中前移和后移使用previous()和next()函数，移动时播放列表会发射currentIndex Changed()信号，从而自动更新界面上listWidget里的当前条目。
在界面上的listWidget里双击一个条目时，切换到播放这个文件，其实现代码为：void MainWindow::on_listWidget_doubleClicked(const QModelIndex &index)
{//双击时切换播放文件
   int rowNo=index.row();
   playlist->setCurrentIndex(rowNo);
   player->play();
}
4．播放控制
播放、暂停或停止播放器，只需调用QMediaPlayer相应函数即可，界面上3个按钮的代码如下：void MainWindow::on_btnPlay_clicked()
{//播放
   if (playlist->currentIndex()<0)
      playlist->setCurrentIndex(0);
   player->play();
}
void MainWindow::on_btnPause_clicked()
{//暂停播放
   player->pause();
}
void MainWindow::on_btnStop_clicked()
{//停止播放
   player->stop();
}
播放状态变化时会发射stateChanged()信号，在关联的自定义槽函数onStateChanged()里更新3个按钮的使能状态。
音量控制由一个“静音”按钮和音量滑动条控制，相关代码如下：void MainWindow::on_btnSound_clicked()
{//静音控制
   bool mute=player->isMuted();
   player->setMuted(!mute);
   if (mute)
      ui->btnSound->setIcon(QIcon(":/images/images/volumn.bmp"));
   else
      ui->btnSound->setIcon(QIcon(":/images/images/mute.bmp"));
}
void MainWindow::on_sliderVolumn_valueChanged(int value)
{//调整音量
   player->setVolume(value);
}
文件播放进度条在onDurationChanged()和onPositionChanged()两个自定义槽函数里会更新，显示当前文件播放进度。当拖动滑动条的滑块可以设置文件播放位置，代码如下：void MainWindow::on_sliderPosition_valueChanged(int value)
{//文件进度调控
   player->setPosition(value);
}
15.2.2　使用QSoundEffect和QSound播放音效文件





QSoundEffect用于播放低延迟的音效文件，如无压缩的WAV文件，用于实现一些音效效果，如按键音、提示音等。使用QSoundEffect播放音效文件的示例代码如下：QSoundEffect effect;
effect.setSource(QUrl::fromLocalFile("engine.wav"));
effect.setLoopCount(3);
effect.setVolume(1);
effect.play();
QSoundEffect不仅可以播放本地文件，还可以播放网络文件。
还有一个类QSound只能播放本地WAV文件，而且是异步方式播放。可以直接使用QSound的静态函数播放WAV文件，如：QSound::play("mysounds/bells.wav");
15.3　音频输入
音频输入可以使用QAudioRecorder或QAudioInput两个类实现。QAudioRecorder是高层次的实现，输入的音频数据直接保存为文件，也可以通过QAudioProbe访问原始的音频数据。QAudioInput是低层次的实现，直接控制音频输入设备的参数，并将音频录制数据写入一个流设备。
15.3.1　使用QAudioRecorder录制音频
1．使用QAudioRecorder录制音频
QAudioRecorder是用于录制音频的类，它从QMediaRecorder类继承而来，只需要较少的代码，就可以实现音频录制并存储到文件。图15-2是使用QAudioRecorder录制音频文件的实例程序samp15_3运行时界面。
图15-2　实例samp15_3运行时界面
QAudioRecorder需要使用一个QAudioEncoderSettings类型的变量进行输入音频设置，主要是编码格式、采样率、通道数、音频质量等高级设置，图15-2窗口左侧是音频输入设置。
设置一个输出保存文件后就可以使用QAudioRecorder录制文件，录制的数据会自动保存到文件里。音频输入设备会根据音频设置自动确定底层的采样参数，使用QAudioProbe类可以获取音频输入缓冲区的参数和原始数据。图15-2窗口右侧显示了音频输入缓冲区的数据参数，包括缓冲区字节数、帧数、采样数、采样字长、采样率等，通过这些参数就可以从缓冲区读取出原始的音频数据。
2．QAudioRecorder录音功能的实现







samp15_3的主窗口从QMainWindow继承，界面采用UI设计器设计，界面组件和布局的设计不再详述。主窗口类MainWindow的定义如下（省略了UI生成的界面组件的槽函数定义）：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   QAudioRecorder *recorder;//音频录音
   QAudioProbe *probe; //探测器
public:
   explicit MainWindow(QWidget *parent = 0);
private slots:
//自定义槽函数
   void onStateChanged(QMediaRecorder::State state);
   void onDurationChanged(qint64 duration);
   void processBuffer(const QAudioBuffer& buffer);
private:
   Ui::MainWindow *ui;
};
QAudioRecorder类型变量recorder用于录音，QAudioProbe类型变量probe用于探测缓冲区数据。
还定义了3个槽函数，用于与recorder和probe的信号进行关联。在窗口的构造函数里创建变量和进行信号与槽的关联。下面是窗口构造函数的代码：MainWindow::MainWindow(QWidget *parent) :   QMainWindow(parent),
   ui(new Ui::MainWindow)
{  ui->setupUi(this);
   recorder = new QAudioRecorder(this);
   connect(recorder,SIGNAL(stateChanged(QMediaRecorder::State)),
          this,SLOT(onStateChanged(QMediaRecorder::State)));
   connect(recorder, SIGNAL(durationChanged(qint64)), this,
          SLOT(onDurationChanged(qint64)));

   probe = new QAudioProbe;//探测器
   connect(probe, SIGNAL(audioBufferProbed(QAudioBuffer)),
          this, SLOT(processBuffer(QAudioBuffer)));
   probe->setSource(recorder);

   if (recorder->defaultAudioInput().isEmpty())
      return;  //无音频输入设备
   foreach (const QString &device, recorder->audioInputs())
      ui->comboDevices->addItem(device); //音频输入设备列表
   foreach (const QString &codecName, recorder->supportedAudioCodecs())
      ui->comboCodec->addItem(codecName); //支持的音频编码
   foreach (int sampleRate, recorder->supportedAudioSampleRates())
      ui->comboSampleRate->addItem(QString::number(sampleRate)); //采样率
   //channels
   ui->comboChannels->addItem("1");
   ui->comboChannels->addItem("2");
   ui->comboChannels->addItem("4");
   //quality
   ui->sliderQuality->setRange(0, int(QMultimedia::VeryHighQuality));
   ui->sliderQuality->setValue(int(QMultimedia::NormalQuality));
   //bitrates:
   ui->comboBitrate->addItem("32000");
   ui->comboBitrate->addItem("64000");
   ui->comboBitrate->addItem("96000");
   ui->comboBitrate->addItem("128000");
}
槽函数onStateChanged()与recorder的stateChanged()信号关联，在recorder的状态变化




时控制界面上“录音”“暂停”“停止”等按钮的使能状态。
槽函数onDurationChanged()与recorder的durationChanged()信号关联，该信号在录制持续时间变化时发射，以更新界面上的时间显示。下面是这两个槽函数的代码：void MainWindow::onStateChanged(QMediaRecorder::State state)
{ //录音状态变化
   ui->actRecord->setEnabled(state!=QMediaRecorder::RecordingState);
   ui->actPause->setEnabled(state==QMediaRecorder::RecordingState);
   ui->actStop->setEnabled(state==QMediaRecorder::RecordingState);
   ui->btnGetFile->setEnabled(state==QMediaRecorder::StoppedState);
   ui->editOutputFile->setEnabled(state==QMediaRecorder::StoppedState);
}
void MainWindow::onDurationChanged(qint64 duration)
{//录音持续时间变化
   ui->LabPassTime->setText(QString("已录制 %1 秒").arg(duration / 1000));
}
探测器probe通过setSource()指定探测对象，这里probe的探测对象是recorder。probe->setSource(recorder);
QAudioProbe也可以在音频播放时进行缓冲区探测，也就是可以指定一个QMediaPlayer对象作为探测对象。
槽函数processBuffer()与probe的信号audioBufferProbed()关联，这个信号会传递一个QAudioBuffer类型的变量，这个变量里存储了缓冲区的信息和音频原始数据。
构造函数的后部分对界面上录音设置的组件的内容进行初始化，用到QAudioRecorder类的如下一些函数：
defaultAudioInput()函数获取缺省的音频输入设备名称；
audioInputs()函数获取音频输入设备列表；
supportedAudioCodecs()函数获取支持的音频编码列表；
supportedAudioSampleRates()获取支持的音频采样率列表。
选择一个录音输出文件后，就可以通过界面上“录音”“暂停”“停止”三个按钮进行录音控制，三个按钮代码如下：void MainWindow::on_actRecord_triggered()
{ //开始录音
   if (recorder->state() == QMediaRecorder::StoppedState) //已停止，重新设置
   {
     QString selectedFile=ui->editOutputFile->text().trimmed();
     if (selectedFile.isEmpty())
     {
       QMessageBox::critical(this,"错误","请先设置录音输出文件");
       return;
     }
     if (QFile::exists(selectedFile))
      if (!QFile::remove(selectedFile))
      {
       QMessageBox::critical(this,"错误","所设置录音输出文件无法删除");
       return;
      }
     recorder->setOutputLocation(QUrl::fromLocalFile(selectedFile));
     recorder->setAudioInput(ui->comboDevices->currentText()); //输入设备
     QAudioEncoderSettings settings; //音频编码设置
     settings.setCodec(ui->comboCodec->currentText());//编码
     settings.setSampleRate(ui->comboSampleRate->currentText().toInt());
     settings.setBitRate(ui->comboBitrate->currentText().toInt());//比特率
     settings.setChannelCount(ui->comboChannels->currentText().toInt());




settings.setQuality(QMultimedia::EncodingQuality( 
              ui->sliderQuality->value()));
     if (ui->radioQuality->isChecked())//编码模式为固定品质
       settings.setEncodingMode(QMultimedia::ConstantQualityEncoding);
     else
       settings.setEncodingMode(QMultimedia::ConstantBitRateEncoding);
     recorder->setAudioSettings(settings); //音频设置
   }
   recorder->record();
}
void MainWindow::on_actPause_triggered()
{ //暂停
   recorder->pause();
}
void MainWindow::on_actStop_triggered()
{//停止
   recorder->stop();
}
开始、暂停和停止录音只需调用QAudioRecorder的record()、pause()和stop()函数，这会导致QAudioRecorder的state()发生变化，并发射stateChanged()信号，在关联的槽函数onStateChanged()里更新界面按钮的使能状态。
在“录音”按钮的代码里，如果是从停止状态单击“录音”，将会根据界面的输入用setOutput Location()设置保存文件；并用setAudioInput()设置音频输入设备；然后用一个QaudioEncoder Settings类型变量settings获取录音设置，设置的内容包括：
setCodec()设置音频编码，如“audio/pcm”是未经编码的音频格式；
setSampleRate()设置采样率，如8000Hz是最低的采样率，44100Hz是一般CD、MP3的采样率，96000Hz是高清晰音轨使用的采样率；
setChannelCount()设置通道数，常见的有单声道、立体声（双声道）和四声环绕（四声道）；
setBitRate()设置比特率，若用QAudioEncoderSettings::setEncodingMode()设置，编码模式为QMultimedia::ConstantBitRateEncoding，则音频输入设备采用固定的比特率采样，比特率越高，音质越好，一般较高音质如128 kbps；
setQuality()设置录音质量，传递的参数是表示录音质量的枚举类型QMultimedia::Encoding Quality，有“VeryLowQuality”到“VeryHighQuality”五个等级。若编码模式设置为固定质量，则音频输入设备会根据质量要求自动设置底层的采样率、字长等参数。
在配置好settings的内容后，为录音器设置音频参数，即：recorder->setAudioSettings(settings);
3．QAudioProbe 获取音频输入缓冲区数据参数
单击“录音”按钮后，就可以根据设置进行录音，录音的数据会自动保存到指定的存储文件里。
由于使用了一个QAudioProbe类型变量probe进行录音数据的探测，在录音过程中，probe会在录音的缓冲区更新数据后发射audioBufferProbed()信号。与audioBufferProbed()信号关联的自定义槽函数processBuffer()对缓冲区的数据信息进行查询和显示，代码如下：void MainWindow::processBuffer(const QAudioBuffer &buffer)
{ //处理探测到的缓冲区
   ui->spin_byteCount->setValue(buffer.byteCount());//缓冲区字节数
   ui->spin_duration->setValue(buffer.duration()/1000);//缓冲区时长
   ui->spin_frameCount->setValue(buffer.frameCount());//缓冲区帧数
   ui->spin_sampleCount->setValue(buffer.sampleCount());//缓冲区采样数
   QAudioFormat audioFormat=buffer.format();//缓冲区格式




ui->spin_channelCount->setValue(audioFormat.channelCount()); //通道数
   ui->spin_sampleSize->setValue(audioFormat.sampleSize());//采样大小
   ui->spin_sampleRate->setValue(audioFormat.sampleRate());//采样率
   ui->spin_bytesPerFrame->setValue(audioFormat.bytesPerFrame());
   if (audioFormat.byteOrder()==QAudioFormat::LittleEndian)
      ui->edit_byteOrder->setText("LittleEndian");//字节序
   else
      ui->edit_byteOrder->setText("BigEndian");
   ui->edit_codec->setText(audioFormat.codec());//编码格式

   if (audioFormat.sampleType()==QAudioFormat::SignedInt)//采样点类型
      ui->edit_sampleType->setText("SignedInt");
   else if(audioFormat.sampleType()==QAudioFormat::UnSignedInt)
      ui->edit_sampleType->setText("UnSignedInt");
   else if(audioFormat.sampleType()==QAudioFormat::Float)
      ui->edit_sampleType->setText("Float");
   else
      ui->edit_sampleType->setText("Unknown");
}
信号audioBufferProbed()传递一个QAudioBuffer类型的参数buffer，该参数存储了缓冲区的音频采样参数和音频原始数据。通过QAudioBuffer::format()函数可以获得音频格式参数。QAudioFormat audioFormat=buffer.format();
buffer.format()返回一个QAudioFormat类型的变量，存储了音频的格式参数信息。如果要使用音频的原始数据，需要对这些参数有所了解，结合图15-2显示的内容对QAudioFormat的一些函数表示的参数作解释。
channelCount()返回音频数据的实际通道数，与前面的音频设置的通道数一致。
sampleSize()返回采样点位数，是指一个采样数据点的量化位数，一般有8位、16位和32位。位数越多，声音的分辨率越高，保真度也越高，一般16位即可达到CD的音频质量。
sampleRate()返回实际的采样频率，一般等于或大于音频输入设置的采样率，也会根据设置的质量要求自动设置实际的采样率。
sampleType()返回采样点格式，是指一个采样点得用什么类型的数据来表示，有无符号整型（UnSignedInt）、有符号整型（SignedInt）和浮点数（Float）。
byteOrder()返回字节序，分为大端字节序和小端字节序。
codec()返回实际的编码方式。
bytesPerFrame()返回每帧字节数，不同音频编码格式的帧的定义不一样，PCM（Pulse Code Modulation，脉冲编码调制）编码的一帧就是各个通道的一次采样数据。
QAudioBuffer还有其他一些函数来说明缓冲区数据的信息，结合图15-2对这些参数进行解释如下。
frameCount()返回帧数，对于PCM格式编码的音频数据，一帧就是一次采样点，这个函数返回了缓冲区中数据点的帧数，如320帧。
sampleCount()返回采样数，采样数=帧数*通道数，因为是2个通道，所以采样数为640。
byteCount()返回缓冲区字节数，字节数=采样数*采样字节数，因为采样点位数位8位，即1个字节，所以缓冲区字节数为640。
duration()返回缓冲区时长，时长由帧数和采样频率决定，图中的缓冲区时长为40 ms。因为帧数为320，采样频率为8000 Hz，所以时长为：
QAudioBuffer::data()函数返回缓冲区存储的音频的原始数据，获取这些原始数据，就可以对数据进行分析或处理，如进行语音识别必须先获得这些音频原始数据。
使用QAudioRecorder进行音频输入时，由于设置的采集参数不同，如要求音频质量不



同时，底层的音频采样参数会自动调整。与图15-2中的设置相似，只是将音频编码质量设置为最高质量，录音时缓冲区的信息就发生较大的变化，如图15-3所示。图中可以看到缓冲区的采样字长变为了16位，采样率变为了96000 Hz，每帧字节数变为了4字节。
所以在采用QAudioBuffer::data()读取原始数据时，需要根据QAudioBuffer::format()返回的格式参数以及缓冲区帧数、采样数等参数才能正确读取原始数据，这实现起来比较复杂，本例就不演示原始数据的读取了。
图15-3　固定品质为最高品质时录音的缓冲区参数
15.3.2　使用QAudioInput获取音频输入
1．QAudioInput获取音频输入功能概述
QAudioInput类提供了接收音频设备输入数据的接口，创建QAudioInput对象实例时，需要用两个参数，一个是QAudioDeviceInfo类表示的音频设备，一个是QAudioFormat表示的音频输入格式。QAudioInput::start()函数开始音频数据输入时，需要指定一个流设备接收输入的音频数据，如可以指定一个QFile表示的文件。
QAudioInput与QaudioRecorder的不同之处如下。
QAudioInput创建时指定的QaudioFormat将直接作用于音频输入设备，也就是音频输入的数据将直接按照设置的参数进行采样，而QAudioRecorder不能直接控制采样字长、采样点类型等底层参数。
QAudioInput::start(QIODevice *device)指定一个QIODevice设备作为数据输出对象，可以是文件，也可以是其他从QIODevice继承的类。如从QIODevice继承一个类，对输入的缓冲区数据进行处理，而不是保存到文件。而QAudioRecorder只能指定文件作为保存对象。所以，QAudioInput可以实现更加底层的音频输入控制。
图15-4是使用QAudioInput实现的一个音频数据输入并实时显示原始信号波形的实例程序samp15_4的运行界面。
图15-4左侧显示的是用QAudioDeviceInfo类获取的音频设备，以及设备支持的各种参数，单击“测试音频设置”可以判断音频设备是否支持所设置的采集配置。为了更方便读取原始数据，在开始采集时采用固定的设置，即8000Hz、1通道、8位、无符号整数。
窗口右侧是一个QChart组件，采用QLineSeries作为显示序列。开始采集后，从缓冲区读取的数据将实时显示在图表上。






图15-4　使用QAudioInput获取音频输入并显示原始数据波形
2．主窗口定义与初始化
samp15_4的主窗口是基于QMainWindow的类MainWindow，窗口界面设计由UI设计器实现。主窗口类MainWindow的定义如下：class MainWindow : public QMainWindow
{
   Q_OBJECT
private:
   const qint64  displayPointsCount=4000;
   QLineSeries  *lineSeries;//曲线序列
   QList<QAudioDeviceInfo> deviceList;  //音频输入设备列表
   QAudioDeviceInfo   curDevice;//当前输入设备
   QmyDisplayDevice   *displayDevice; //用于显示的IODevice
   QAudioInput       *audioInput;//音频输入设备
   QString  SampleTypeString(QAudioFormat::SampleType sampleType);
   QString  ByteOrderString(QAudioFormat::Endian endian);
public:
   explicit  MainWindow(QWidget *parent = 0);
   ~MainWindow();
private slots:
//自定义槽函数
   void   on_IODevice_UpdateBlockSize(qint64 blockSize);
private:
   Ui::MainWindow *ui;
};
这里定义了较多的私有变量，其中QmyDisplayDevice是一个自定义的从QIODevice继承的类，用于读取音频输入缓冲区的数据，并在图表上显示。其具体实现在后面介绍。
MainWindow的构造函数代码如下：MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
   ui(new Ui::MainWindow)
{
   ui->setupUi(this);
   setCentralWidget(ui->splitter);
//创建显示图表
   QChart *chart = new QChart;
   chart->setTitle("音频输入原始信号");
   ui->chartView->setChart(chart);
   lineSeries= new QLineSeries(); //序列
   chart->addSeries(lineSeries);

   QValueAxis *axisX = new QValueAxis;  //坐标轴
   axisX->setRange(0, displayPointsCount); //chart显示4000个采样点数据
   axisX->setLabelFormat("%g");
   axisX->setTitleText("Samples");
   QValueAxis *axisY = new QValueAxis;  //坐标轴




axisY->setRange(0, 256); // UnSingedInt采样，数据范围0-255
   axisY->setTitleText("Audio level");

   chart->setAxisX(axisX, lineSeries);
   chart->setAxisY(axisY, lineSeries);
   chart->legend()->hide();

   ui->comboDevices->clear();
   deviceList=QAudioDeviceInfo::availableDevices(QAudio::AudioInput); 
   for(int i=0;i<deviceList.count();i++)
   {
      QAudioDeviceInfo device=deviceList.at(i);
      ui->comboDevices->addItem(device.deviceName());
    }

   if (deviceList.size()>0)
   {
     ui->comboDevices->setCurrentIndex(0); 
     curDevice =deviceList.at(0);//
   }
   else
   {
      ui->actStart->setEnabled(false);
      ui->actDeviceTest->setEnabled(false);
      ui->groupBoxDevice->setTitle("支持的音频输入设置(无设备)");
   }
}
构造函数创建了用于图表显示的QChart对象chart，创建了QLineSeries类型的序列lineSeries，创建了X和Y坐标轴；其X轴的范围等于0到显示的数据点的总数4000，Y轴的范围是0至256，采用8位无符号整数，采样数据范围是0至255。
QAudioDeviceInfo::availableDevices(QAudio::AudioInput)可以获取音频输入设备列表，设备名称被添加到窗口上的comboDevices下拉列表框里。
3．音频输入设备支持的格式
在主窗口的构造函数中，向comboDevices下拉列表框中添加了系统所有的音频输入设备。在下拉列表框里选择一个设备时，发射currentIndexChanged(int index)信号，在其槽函数里获取设备支持的各种音频输入参数，包括支持的音频编码、采样率、通道数、采样点类型和采样点大小等，以此更新窗口上的组件显示。void MainWindow::on_comboDevices_currentIndexChanged(int index)
{//选择音频输入设备
  curDevice =deviceList.at(index);//当前音频设备
  ui->comboCodec->clear(); //支持的音频编码
  QStringList codecs = curDevice.supportedCodecs();
  for (int i = 0; i < codecs.size(); ++i)
   ui->comboCodec->addItem(codecs.at(i));

  ui->comboSampleRate->clear(); //支持的采样率
  QList<int> sampleRate = curDevice.supportedSampleRates();
  for (int i = 0; i < sampleRate.size(); ++i)
   ui->comboSampleRate->addItem(QString("%1").arg(sampleRate.at(i)));

  ui->comboChannels->clear();//支持的通道数
  QList<int> Channels = curDevice.supportedChannelCounts();
  for (int i = 0; i < Channels.size(); ++i)
   ui->comboChannels->addItem(QString("%1").arg(Channels.at(i)));

  ui->comboSampleTypes->clear(); //支持的采样点类型
  QList<QAudioFormat::SampleType> sampleTypes = curDevice.supportedSampleTypes();
  for (int i = 0; i < sampleTypes.size(); ++i)
   ui->comboSampleTypes->addItem(SampleTypeString(sampleTypes.at(i)), QVariant(sampleTypes.at(i)));




ui->comboSampleSizes->clear();//采样点大小
  QList<int> sampleSizes = curDevice.supportedSampleSizes();
  for (int i = 0; i < sampleSizes.size(); ++i)
   ui->comboSampleSizes->addItem(QString("%1").arg(sampleSizes.at(i)));

  ui->comboByteOrder->clear();//字节序
  QList<QAudioFormat::Endian> endians = curDevice.supportedByteOrders();
  for (int i = 0; i < endians.size(); ++i)
   ui->comboByteOrder->addItem(ByteOrderString(endians.at(i)));
}

QString MainWindow::SampleTypeString(QAudioFormat::SampleType sampleType)
{//将QAudioFormat::SampleType类型转换为字符串
   QString result("Unknown");
   switch (sampleType) {
   case QAudioFormat::SignedInt:
      result = "SignedInt";      break;
   case QAudioFormat::UnSignedInt:
      result = "UnSignedInt";     break;
   case QAudioFormat::Float:
      result = "Float";         break;
   case QAudioFormat::Unknown:
      result = "Unknown";
   }
   return result;
}

QString MainWindow::ByteOrderString(QAudioFormat::Endian endian)
{ //将QAudioFormat::Endian  转换为字符串
  if (endian==QAudioFormat::LittleEndian)
   return "LittleEndian";
  else if (endian==QAudioFormat::BigEndian)
   return "BigEndian";
  else
   return "Unknown";
}
创建一个QAudioInput对象时需要传递一个QAudioFormat类型作为参数，用于指定音频输入配置，而音频设备是否支持这些配置需要进行测试。窗口上的“测试音频设置”按钮可以进行测试，代码如下：void MainWindow::on_actDeviceTest_triggered()
{//测试音频输入设备是否支持选择的设置
  QAudioFormat settings;
  settings.setCodec(ui->comboCodec->currentText());
  settings.setSampleRate(ui->comboSampleRate->currentText().toInt());
  settings.setChannelCount(ui->comboChannels->currentText().toInt());
  settings.setSampleType(QAudioFormat::SampleType(
        ui->comboSampleTypes->currentData().toInt()));
  settings.setSampleSize(ui->comboSampleSizes->currentText().toInt());
  if (ui->comboByteOrder->currentText()=="LittleEndian")
   settings.setByteOrder(QAudioFormat::LittleEndian);
  else
   settings.setByteOrder(QAudioFormat::BigEndian);

  if (curDevice.isFormatSupported(settings))
   QMessageBox::information(this,"音频测试","测试成功，输入设备支持此设置");
  else
   QMessageBox::critical(this,"音频测试","测试失败，输入设备不支持此设置");
}
QAudioFormat类对象settings从界面上各个组件获取设置，包括编码格式、采样率、通道数等，然后用QAudioDeviceInfo::isFormatSupported()函数测试是否支持此设置；如果不支持，





还可以使用QAudioDeviceInfo的nearestFormat()函数获取最接近的配置。
4．开始音频输入
单击窗口工具栏上“开始”按钮，即可开始音频数据输入，其代码如下：void MainWindow::on_actStart_triggered()
{//开始音频输入
   QAudioFormat defaultAudioFormat; //缺省格式
   defaultAudioFormat.setSampleRate(8000);
   defaultAudioFormat.setChannelCount(1);
   defaultAudioFormat.setSampleSize(8);
   defaultAudioFormat.setCodec("audio/pcm");
   defaultAudioFormat.setByteOrder(QAudioFormat::LittleEndian);
   defaultAudioFormat.setSampleType(QAudioFormat::UnSignedInt);
   if (!curDevice.isFormatSupported(defaultAudioFormat))
   {
      QMessageBox::critical(this,"测试","测试失败，输入设备不支持此设置");
      return;
   }

   audioInput = new QAudioInput(curDevice,defaultAudioFormat, this);
   audioInput->setBufferSize(displayPointsCount);
// 接收音频输入数据的流设备
   displayDevice = new QmyDisplayDevice(lineSeries, displayPointsCount,this);
   connect(displayDevice,SIGNAL(updateBlockSize(qint64)),
          this,SLOT(on_IODevice_UpdateBlockSize(qint64)));
   displayDevice->open(QIODevice::WriteOnly); 

   audioInput->start(displayDevice); 
   ui->actStart->setEnabled(false);
   ui->actStop->setEnabled(true);
}
为了便于解析音频输入的原始数据，音频输入的配置采用固定的简单方式，而不是根据界面上的设置进行配置。音频输入配置固定为8000 Hz采样率、1个通道、8位无符号整数、audio/pcm编码和小端字节序。
创建QAudioInput类对象audioInput时，传递defaultAudioFormat和curDevice作为参数，并设置缓冲区大小为displayPointsCount（等于4000）。audioInput = new QAudioInput(curDevice,defaultAudioFormat, this);
audioInput->setBufferSize(displayPointsCount);
使用setBufferSize设置的缓冲区，需要在调用start()之前设置才有效。缓冲区的大小大于每次更新输入的原始数据块的大小，在图15-4中可见缓冲区大小为4000，而每次更新的原始数据的数据字节数为800。
随后程序创建一个QmyDisplayDevice类型的IO设备displayDevice，这个类实现了流设备的writeData()函数，用于读取音频输入的数据并在曲线上显示。其构造函数接收lineSeries和displayPointsCount作为参数。再将displayDevice的信号updateBlockSize()与一个自定义槽函数关联，然后将displayDevice以只写方式打开。
最后调用QAudioInput::start()函数开始音频输入，以displayDevice作为IO流设备。audioInput->start(displayDevice);
自定义槽函数on_IODevice_UpdateBlockSize()用于显示缓冲区大小和数据块大小，代码如下：void MainWindow::on_IODevice_UpdateBlockSize(qint64 blockSize)
{//显示缓冲区大小和数据块大小
   ui->LabBufferSize->setText(QString::asprintf(






"QAudioInput::bufferSize()=%d",audioInput->bufferSize()));
   ui->LabBlockSize->setText(
             QString("IODevice数据块字节数=%1").arg(blockSize));
}
5．流设备QmyDisplayDevice的功能实现
使用QAudioInput获取音频输入数据时，需要使用一个QIODevice类型的设备作为流输出设备，一般采用QFile可以将数据记录到文件。本例中使用一个自定义的类QmyDisplayDevice，用于获取音频输入数据并在曲线上实时显示。
QmyDisplayDevice类的定义如下：#include  <QtCharts>
#include  <QIODevice>
class QmyDisplayDevice : public QIODevice
{
   Q_OBJECT
public:
   explicit QmyDisplayDevice(QXYSeries * series, qint64 pointsCount,QObject *parent = 0);
protected:
   qint64 readData(char * data, qint64 maxSize);
   qint64 writeData(const char * data, qint64 maxSize);
private:
   QXYSeries *m_series;
   qint64  range=4000;
signals:
   void  updateBlockSize(qint64 blockSize);
};
因为QmyDisplayDevice类从QIODevice继承，所以具有流数据读写功能。重新实现的readData()和writeData()是实现流数据读写功能的。
定义了m_series和range两个私有变量。m_series是用于图表曲线显示的QXYSeries序列，range缺省值为4000，是序列最多显示的数据点数。构造函数里接收series和pointsCount对上述两个变量进行初始化。
QmyDisplayDevice类的实现代码如下：QmyDisplayDevice::QmyDisplayDevice(QXYSeries * series, qint64 pointsCount, QObject *parent) :   QIODevice(parent)
{// 构造函数
   m_series= series;
   range=pointsCount;
}

qint64 QmyDisplayDevice::readData(char * data, qint64 maxSize)
{// 流的读操作,不处理
   Q_UNUSED(data)
   Q_UNUSED(maxSize)
   return -1;
}
qint64 QmyDisplayDevice::writeData(const char * data, qint64 maxSize)
{ //读取数据块内的数据，更新到序列
   QVector<QPointF> oldPoints = m_series->pointsVector();
   QVector<QPointF> points; //临时
   if (oldPoints.count() < range)
   { //m_series序列的数据未满4000点，
      points = m_series->pointsVector();
   }
   else
   {//将原来maxSize至4000的数据点前移
      for (int i = maxSize; i < oldPoints.count(); i++)




points.append(QPointF(i - maxSize, oldPoints.at(i).y()));
   }

   qint64 size = points.count();
   for (int k = 0; k < maxSize; k++) //数据块内的数据填充序列的尾部
      points.append(QPointF(k + size, (quint8)data[k]));

   m_series->replace(points); 
   emit updateBlockSize(maxSize);
   return maxSize;
}
QmyDisplayDevice无需实现流的读操作，所以readData()函数不做什么处理，重点是流的写操作writeData()函数的实现。
writeData()传递进来的参数data是数据块的指针，maxSize是数据块的字节数，这是需要读取出来的音频输入数据。
由于音频输入配置为1通道8位无符号的整数采样，所以一个数据点就是一个字节的数据。
显示序列m_series存储的显示数据点个数限定为4000个点，大于maxSize（此例中为800），所以对于序列的数据点的更新采用FIFO（先入先出）的方式。
更新临时数据点向量points，采用序列的replace()函数替换序列原有的数据点向量，是最快的方式。
writeData()函数最后发射信号updateBlockSize(maxSize)，用于主窗口的关联槽函数on_IODevice_UpdateBlockSize()则显示数据块的大小。
15.4　视频播放
使用QMediaPlayer可以进行视频文件解码，视频播放必须将视频帧在某个界面组件上显示，有QVideoWidget和QGraphicsVideoItem两种视频显示组件，也可以从这两个类继承，自定义视频显示组件。
QMediaPlayer也可以结合QMediaPlaylist实现视频文件列表播放。
15.4.1　在QVideoWidget上播放视频
1．视频播放器实例程序
QVideoWidget是用于显示视频的界面组件，要在项目中使用QVideoWidget，需要在项目配置文件中添加下面一行语句：****Qt += multimediawidgets
使用QMediaPlayer和QVideoWidget实现的一个视频播放器实例程序samp15_5运行时界面如图15-5所示。该程序没有使用QMediaPlaylist，只播放单个文件。



































































































































































































































































































































































